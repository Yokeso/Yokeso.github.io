<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-17T08:18:25.985Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS-ch-2</title>
    <link href="http://yoursite.com/2020/08/14/OS-ch-2/"/>
    <id>http://yoursite.com/2020/08/14/OS-ch-2/</id>
    <published>2020-08-14T13:47:57.000Z</published>
    <updated>2020-08-17T08:18:25.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h2><p>为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进程或线程。</p><h3 id="2-1-进程的基本概念"><a href="#2-1-进程的基本概念" class="headerlink" title="2.1 进程的基本概念"></a>2.1 进程的基本概念</h3><h4 id="2-1-1-程序的基本特征"><a href="#2-1-1-程序的基本特征" class="headerlink" title="2.1.1 程序的基本特征"></a>2.1.1 程序的基本特征</h4><p>程序执行的两种方式：<font color="red">顺序执行</font>和<font color="red">并发执行</font></p><p>(1)顺序执行：单道批处理系统的执行方式：<br><strong>特征</strong>：</p><ul><li><strong>顺序性</strong>：按照程序结构所指定的次序执行。</li><li><strong>封闭性</strong>：独占全部资源，计算机的状态只由于该程序的控制逻辑所决定，结果不受外界因素的影响。</li><li><strong>可再现性</strong>：初始条件相同则结果相同</li></ul><p>(2)为了提高资源利用率并发执行</p><p>特征：</p><ul><li>间断性：程序中途停下来失去原有时序的联系。</li><li>失去封闭性：共享资源受到其他程序控制影响</li><li>失去可再现性：外界环境在程序两次执行期间发生变化</li></ul><p>并发执行条件：达到封闭性和可再现性。</p><h4 id="2-1-2-进程的定义与特征"><a href="#2-1-2-进程的定义与特征" class="headerlink" title="2.1.2 进程的定义与特征"></a>2.1.2 进程的定义与特征</h4><p>进程：一个具有一定独立功能的程序在一个数据集合上一次动态执行的一个过程。</p><p>​            处理机、存储器和外设等资源的分配和回收的基本单位</p><p>一个进程应该包括：</p><ul><li>程序代码</li><li>程序处理的数据，堆栈</li><li>程序计数器中的值，指示下一条将运行的指令</li><li>一组通用的寄存器当前值</li><li>一组系统资源</li></ul><p>进程包括了正在运行的一个程序的所有状态信息。</p><h5 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h5><ul><li><p><strong>程序是产生进程的基础；进程是程序功能的体现。</strong></p></li><li><p><strong>程序是</strong><font color="red">静态</font>实体；进程是<font color="red">动态</font>过程。</p></li><li><p><strong>程序是指令、数据及其组织形式的描述；进程是程序（那些指令和数据）的真正运行实例。</strong></p></li><li><p><strong>进程是暂时的</strong>，是一个状态变化的过程；程序是永久的，可长久保存。</p></li><li><p><strong>通过多次执行，</strong>一个程序可产生多个进程；<strong>通过调用关系</strong>，一个进程可包括多个程序。</p></li><li><p><strong>进程需要一些资源才能完成工作，如</strong>CPU使用时间、存储器、文件以及I/O设备。</p></li></ul><h5 id="进程特征："><a href="#进程特征：" class="headerlink" title="进程特征："></a>进程特征：</h5><ul><li><p>动态性：创建产生，调度执行，受制于资源，撤销消亡。</p></li><li><p>进程具有动态的地址空间（数量和内容），地址空间上包括：代码、数据、进程控制块（PCB）</p></li><li><p>并发性：多个进程同时存在于内存，宏观上同时运行。</p></li><li><p>独立性：资源分配的单位。</p></li><li><p>各进程的地址空间相互独立，除非采用进程间通信手段</p></li><li><p>异步性：进程按各自独立的、不可预知的速度向前推进。</p></li><li><p>结构化：进程实体由代码段，数据段和进程控制块(PCB) 组成。</p><ul><li><p>进程控制块包含在核心区。内存核心段通常存放OS核心部分，由各个进程共享，包括各进程的PCB。</p></li><li><p>程序文件中通常划分为代码段和数据段</p></li></ul></li></ul><h4 id="2-1-3-进程控制块"><a href="#2-1-3-进程控制块" class="headerlink" title="2.1.3 进程控制块"></a>2.1.3 进程控制块</h4><p>描述进程的数据结构：进程控制块（PCB）</p><p>操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p><p><img src="/2020/08/14/OS-ch-2/2.1-1.jpg" alt></p><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB:"></a><strong>PCB</strong>:</h5><ul><li>OS中最重要的结构类型，记录描述进程执行情况以及控制进程运行的全部信息</li><li>进程存在的唯一标志，每个进程在OS中登记的表项，OS通过对PCB的组织管理来对进程进行控制管理。</li><li>进程创建时生成PCB，终止时回收PCB</li><li>PCB常驻于由OS维护的内存核心区，不能由应用程序自身的代码来直接访问，而要通过系统调用间接访问。</li><li>OS专门开辟PCB区将所有的PCB组织成若干个链表或队列。</li></ul><h5 id="PCB中信息："><a href="#PCB中信息：" class="headerlink" title="PCB中信息："></a><strong>PCB中信息</strong>：</h5><ul><li><p>程序描述信息：进程标识符，唯一内部标识符；进程名，外部标识符；本进程的产生者标识(父进程标识)； 用户标识符，以指示拥有该进程的用户。<br>处理机状态信息，保存进程运行现场信息。</p></li><li><p>通用寄存器  8-32个，用户程序可使用的数据、地址等寄存器</p></li><li><p>指令计数器  要访问的下一条指令地址</p></li><li><p>程序状态字PSW  条件码、执行方式、中断屏蔽标志 </p></li><li><p>用户栈指针  用户进程拥有的系统栈，存放过程和系统调用参数及调用地址</p></li><li><p>进程调度信息, 用于操作系统调度进程并占用处理机： </p><ul><li>进程的当前状态； </li><li>优先级(priority)； </li><li>运行统计信息（执行时间、页面调度）； </li><li>事件：阻塞原因等。</li></ul></li><li><p>进程控制信息： </p><ul><li>程序段和数据段的地址；  </li><li>进程间同步和通信； </li><li>资源占用信息：除CPU外的进程所需的全部资源及已分配资源清单</li><li>链接指针：本进程所在队列的下一个进程的PCB首地址。</li></ul></li></ul><h5 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h5><p><img src="/2020/08/14/OS-ch-2/2.1-2.jpg" alt></p><h5 id="进程调度队列："><a href="#进程调度队列：" class="headerlink" title="进程调度队列："></a>进程调度队列：</h5><ul><li><p>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态。</p></li><li><p>不同的状态分别用不同的队列来表示（就绪队列，各种类型的堵塞队列）</p><ul><li>作业队列：系统中所有进程的集合</li><li>就绪队列：驻留主存的所有就绪态进程集合</li><li>设备队列：等待I/O设备的进程集合</li></ul></li><li><p>队列在各种队列中的迁移：</p><ul><li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</li></ul></li></ul><p><img src="/2020/08/14/OS-ch-2/2.1-3.jpg" alt="就绪队列和各种IO队列"></p><h5 id="PCB组织方式（两种）"><a href="#PCB组织方式（两种）" class="headerlink" title="PCB组织方式（两种）"></a>PCB组织方式（两种）</h5><p>链表：同一状态的进程其PCB构成一个链表，多个状态对应多个不同的链表</p><p><img src="/2020/08/14/OS-ch-2/2.1-4.jpg" alt="链表方式"></p><p>索引表：同一状态的进程归入一个Index表，（由index指向PCB）多个状态对应多个不同的PCB表</p><p><img src="/2020/08/14/OS-ch-2/2.1-5.jpg" alt="链表方式"></p><h5 id="利用PCB完成进程切换"><a href="#利用PCB完成进程切换" class="headerlink" title="利用PCB完成进程切换"></a>利用PCB完成进程切换</h5><p><img src="/2020/08/14/OS-ch-2/2.1-6.jpg" alt></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>进程管理中最基本的功能是<font color="red">进程控制</font></p><p>进程的生命周期：</p><ul><li>进程创建</li><li>进程运行</li><li>进程等待</li><li>进程唤醒</li><li>进程终止</li></ul><p>进程控制任务</p><ul><li>进程的创建，终止，进程状态的转变等</li></ul><p>进程控制一般由OS内核的原语来实现</p><ul><li>原语：由若干指令构成的原子操作</li><li>许多系统调用是原语，但不是所有的系统调用都是原语</li></ul><h4 id="2-2-1-进程的创建"><a href="#2-2-1-进程的创建" class="headerlink" title="2.2.1 进程的创建"></a>2.2.1 进程的创建</h4><h5 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h5><ul><li>树状结构，父子进程关系</li><li>子进程可以继承父进程的所有资源，如打开文件，缓冲区等。当子进程被撤销，应将继承的资源还给父进程。撤销父进程也必须同时撤销所有的子进程。</li><li>PCB中设置了家族关系表项。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-1.jpg" alt="进程图"></p><p>$$<br>引起进程创建的事件\<br>\begin{equation}<br>由操作系统内核创建\begin{cases}<br>1.操作系统初始化\<br>-分时系统中用户登录\<br>-批处理中作业调度\<br>2.提供服务\<br>-用户请求创建进程\<br>\end{cases}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>由应用程序自身创建\begin{cases}<br>3.应用请求\<br>-正在运行的进程执行了\创建进程的系统调用<br>\end{cases}<br>\end{equation}<br>$$</p><p>原语CREAT（）按下述步骤创建一个新进程:</p><ul><li>申请空白PCB。</li><li>为新进程分配资源：为代码、数据、用户栈分配空间。</li><li>初始化PCB：初始化标识信息、处理机状态（PC、SP)、处理机控制信息（进程状态、优先级）。 </li><li>将新进程插入就绪队列 。 </li></ul><h4 id="2-2-2-进程的终止"><a href="#2-2-2-进程的终止" class="headerlink" title="2.2.2 进程的终止"></a>2.2.2 进程的终止</h4><p><img src="/2020/08/14/OS-ch-2/2.2-2.jpg" alt></p><h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><ul><li>从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li><li>若处于执行状态，终止该进程的执行，并置调度标志为真，重新调度。</li><li>若有子孙进程，将所有子孙进程终止。</li><li>将进程全部资源归还其父进程或系统：释放内外存空间、关闭所有打开文件、释放当前</li><li>目录、释放共享内存段和各种锁定lock。</li><li>将其PCB从所在队列（或链表）中移出 </li></ul><h5 id="unix进程终止过程"><a href="#unix进程终止过程" class="headerlink" title="unix进程终止过程"></a>unix进程终止过程</h5><ul><li><p>进程执行完最后一条语句，请求操作系统删除进程(通过执行exit系统调用)。</p><ul><li>将子进程运行数据传递给父进程（通过 wait系统调用)。</li><li>回收的系统资源由操作系统再另行分配</li></ul></li><li><p>父进程也可以终止子进程的执行（通过abort系统调用)。原因：</p><ul><li>子进程超额使用资源.</li><li>分配给子进程执行的任务不再需要执行.</li><li>父进程退出。<ul><li>如果父进程终止，操作系统不再允许子进程继续执行。</li></ul></li></ul></li></ul><h4 id="2-2-3-进程的阻塞与唤醒"><a href="#2-2-3-进程的阻塞与唤醒" class="headerlink" title="2.2.3 进程的阻塞与唤醒"></a>2.2.3 进程的阻塞与唤醒</h4><p>$$<br>\begin{equation}<br>引起阻塞和唤醒的事件\begin{cases}<br>请求系统服务\<br>启动某种操作\<br>新数据尚未到\<br>无新工作可做<br>\end{cases}<br>\end{equation}<br>$$</p><h5 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h5><ul><li>正在执行的进程，发生上述事件时，自身调用有关阻塞原语，进入等待队列。进程的主动性行为。</li><li>进程由运行态变为阻塞态</li><li>引起处理机调度。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-3.jpg" alt></p><h5 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h5><ul><li>唤醒原因：等待的事件到达。</li><li>由阻塞队列转入就绪队列。进程由阻塞态变为就绪态.</li><li>方法：其他有关进程（例如用完并释放了该I/O设备的进程）发送信号到某个或一组进程。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-4.jpg" alt></p><p><strong>BLOCK和WAKEUP是一队作用相反的原语。</strong><br>如果在某进程中调用了<font color="red">阻塞原语</font>，则必须在与之相合作的另一进程中或其他相关的进程中，安排<font color="red">唤醒原语</font>，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。</p><h4 id="2-2-4-进程的挂起与激活"><a href="#2-2-4-进程的挂起与激活" class="headerlink" title="2.2.4 进程的挂起与激活"></a>2.2.4 进程的挂起与激活</h4><h5 id="挂起引入原因："><a href="#挂起引入原因：" class="headerlink" title="挂起引入原因："></a>挂起引入原因：</h5><ul><li><p><font color="red">终端用户请求</font></p><ul><li>终端用户发现自己运行的程序有问题，希望暂停自己程序的执行</li></ul></li><li><p><font color="red">父进程请求</font></p><ul><li>父进程希望挂起自己的某个子进程，以便考察和修改该子进程</li></ul></li><li><p><font color="red">负荷调节需要</font></p><ul><li>高优先级的进程要执行，而内存不空，系统将低优先级进程对换至外存。</li><li>提高处理机效率：就绪进程表为空时，要提交新进程，而此时内存不空，需挂起阻塞态的进程</li><li>为运行进程提供足够内存（对换及调整负荷）：资源紧张时，暂停某些进程，如：实时任务执行，而内存紧张。</li></ul></li><li><p><font color="red">操作系统的需要</font></p><ul><li>操作系统需要挂起某些进程以便检查运行中的资源使用情况或进行记账</li></ul></li></ul><h5 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h5><ul><li>目的：合理且充分地利用系统资源。进程在挂起状态时，进程没有占用内存空间，仅映像在磁盘上。</li><li>执行过程：挂起原语：SUSPEND（）</li><li>挂起原语的执行过程：<ul><li>从内存调到外存，改变进程的状态。</li><li>若处于活动就绪状态，改为静止就绪；</li><li>若处于活动阻塞状态，则改为静止阻塞；</li><li>若正在执行，则转向调度程序重新调度。</li></ul></li></ul><h5 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h5><ul><li>原因：父进程或用户进程请求，或内存已有足够空间</li><li>执行过程：从外存调入内存，改变进程的状态</li><li>可能也会引起处理机调度</li></ul><h5 id="挂起引起的状态转变"><a href="#挂起引起的状态转变" class="headerlink" title="挂起引起的状态转变"></a>挂起引起的状态转变</h5><p><img src="/2020/08/14/OS-ch-2/2.2-5.jpg" alt></p><ul><li>引入的新状态<ul><li>就绪挂起（静止就绪）：进程在外存，但只要进入内存，即可运行；</li><li>阻塞挂起状态（静止阻塞）：进程在外存并等待某事件的出现。</li></ul></li></ul><h5 id="有挂起状态的进程状态图"><a href="#有挂起状态的进程状态图" class="headerlink" title="有挂起状态的进程状态图"></a>有挂起状态的进程状态图</h5><p><img src="/2020/08/14/OS-ch-2/2.2-6.jpg" alt></p><h5 id="创建和终止状态"><a href="#创建和终止状态" class="headerlink" title="创建和终止状态"></a>创建和终止状态</h5><p><img src="/2020/08/14/OS-ch-2/2.2-7.jpg" alt></p><h5 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h5><p>由于多进程在系统中的并发执行，进程之间存在2种制约关系：<br><font color="red">间接制约</font>:进程间由于共享某种系统资源，而形成的相互制约。</p><p><code>进程A-&gt;资源-&gt;进程B</code></p><p><font color="red">直接制约</font>：进程间由于合作而形成的相互制约</p><p><code>进程A------&gt;进程B</code></p><h5 id="进程的两大关系"><a href="#进程的两大关系" class="headerlink" title="进程的两大关系"></a>进程的两大关系</h5><h6 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h6><p><strong>由于共享资源所要求的排他性，进程间要相互竞争，以获得这些资源的使用权。</strong></p><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p><strong>多个进程中发生的事件存在某种时序关系，必须协同工作、相互配合，以共同完成一项任务。</strong></p><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h3><p>进程并发地对共享数据的访问有可能引起数据的不一致性。<br>为了维持数据的一致性，必须有一种机制来保证协作进程之间按某种正确的次序执行。</p><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><ul><li>临界资源：硬件或软件（如外设、共享代码段、共享数据结构），多个进程在对其进行访问时（关键是进行写入或修改），必须互斥地进行。</li><li>有些共享资源可以同时访问，如只读数据。因而不是临界资源。</li></ul><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><ul><li><p><font color="red">临界区(critical section)</font>：在每个进程中，访问临界资源的一段代码。</p><ul><li><strong>临界区问题－－确保一个进程在执行它的临界区代码时，不允许其他进程再进入他们各自的临界区内执行代码</strong>。</li></ul></li><li><p><font color="red">进入区(entry section)</font>：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应“正在访问临界区”标志</p></li><li><p><font color="red">退出区(exit section)</font>：位于临界区的后面，用于将“正在访问临界区”标志清除。</p></li><li><p><font color="red">剩余区(remainder section)</font>：代码中的其余部分。</p></li></ul><h5 id="访问临界区的循环进程描述"><a href="#访问临界区的循环进程描述" class="headerlink" title="访问临界区的循环进程描述"></a>访问临界区的循环进程描述</h5><p><img src="/2020/08/14/OS-ch-2/2.3-1.jpg" alt></p><ul><li><p>当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理及调度的。比如，通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机是，不能处理机调度，那么系统的性能将非常低。</p></li><li><p>不适合处理机调度的情况：</p><ul><li>在处理中断的过程中</li><li>进程在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li></ul><h5 id="同步机制应遵循的准则："><a href="#同步机制应遵循的准则：" class="headerlink" title="同步机制应遵循的准则："></a>同步机制应遵循的准则：</h5><ul><li>空闲则入：其他进程均不处于临界区，应允许请求进入临界区的进程进入；</li><li>忙则等待：已有进程处于其临界区，请求进入临界区的进程应等待；</li><li>有限等待：等待进入临界区的进程不能“死等”；</li><li>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li></ul><h5 id="解决临界区问题的算法"><a href="#解决临界区问题的算法" class="headerlink" title="解决临界区问题的算法"></a>解决临界区问题的算法</h5><p><img src="/2020/08/14/OS-ch-2/2.3-2.jpg" alt></p><h4 id="2-3-3-信号量机制"><a href="#2-3-3-信号量机制" class="headerlink" title="2.3.3 信号量机制"></a>2.3.3 信号量机制</h4><ul><li>信号量是OS提供的管理公有资源的有效手段。</li><li>整型信号量或记录型信号量可以代表可用资源实体的数量。</li></ul><h5 id="1-整型信号量机制"><a href="#1-整型信号量机制" class="headerlink" title="1.整型信号量机制"></a>1.整型信号量机制</h5><ul><li>1965年，荷兰学者Dijkstra提出（所以P、V分别是荷兰语的test(proberen)和increment(verhogen)），是一种卓有成效的进程同步机制。</li><li>最初Dijkstra把信号量定义为整型量s和两个原子操作（除初始化操作）：P和V, 现又称为：wait和signal。</li></ul><h5 id="2-记录型信号量机制"><a href="#2-记录型信号量机制" class="headerlink" title="2.记录型信号量机制"></a>2.记录型信号量机制</h5><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">process</span> *<span class="title">queue</span>;</span> </span><br><span class="line">        &#125; semaphore;</span><br></pre></td></tr></table></figure><p>每个信号量s<br>一个整数值s.count：其初值表示某类资源的数目（又称为“资源信号量”)<br>一个进程等待队列s.queue，是阻塞在该信号量的各个进程的PCB链成的队列。</p><p><img src="/2020/08/14/OS-ch-2/2.3-3.jpg" alt></p><p>信号量只能通过初始化和两个标准的原语（wait、signal）来访问－－作为OS核心代码执行，不受进程调度的打断。</p><p><img src="/2020/08/14/OS-ch-2/2.3-4.jpg" alt></p><h5 id="3-AND型信号量"><a href="#3-AND型信号量" class="headerlink" title="3.AND型信号量"></a>3.AND型信号量</h5><p>基本思想：将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放。</p><p><img src="/2020/08/14/OS-ch-2/2.3-5.jpg" alt></p><h5 id="4-二进制（Binary-）信号量"><a href="#4-二进制（Binary-）信号量" class="headerlink" title="4.二进制（Binary ）信号量"></a>4.二进制（Binary ）信号量</h5><ul><li>其值只能是 0和 1；易于实现。</li><li>利用二进制信号量可以实现整型信号量。</li><li>数据结构：<pre><code>二进制信号量 S1, S2;  int C:  </code></pre></li><li>初值：<pre><code>S1 = 1  S2 = 0  C = 代表共享资源的初始值</code></pre></li></ul><p><img src="/2020/08/14/OS-ch-2/2.3-6.jpg" alt></p><h4 id="2-3-4-信号量的应用"><a href="#2-3-4-信号量的应用" class="headerlink" title="2.3.4 信号量的应用"></a>2.3.4 信号量的应用</h4><ol><li><h5 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h5><ul><li>为临界资源设置一个互斥信号量mutex，其初值为1；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;   </span><br><span class="line"> …</span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">             …</span><br><span class="line">               wait ( mutex );</span><br><span class="line">               critical section</span><br><span class="line">              signal( mutex );</span><br><span class="line">              remaider section</span><br><span class="line">           &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h5></li></ol><ul><li><p>前趋关系：并发执行的进程P1和P2中，分别有代码C1和C2，要求C1在C2开始前完成；</p><ul><li><p>为每个前趋关系设置一个互斥信号量S12，其初值为0</p></li><li><p>P1:                      P2:</p><p>C1;                      wait(s12);<br>signal(s12)          C2；</p></li></ul></li></ul><h3 id="2-4-经典的进程同步问题"><a href="#2-4-经典的进程同步问题" class="headerlink" title="2.4 经典的进程同步问题"></a>2.4 经典的进程同步问题</h3><h4 id="2-4-1-生产者消费者问题"><a href="#2-4-1-生产者消费者问题" class="headerlink" title="2.4.1 生产者消费者问题"></a>2.4.1 生产者消费者问题</h4><h5 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1) 问题描述："></a>1) 问题描述：</h5><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p><h5 id="2）制约关系："><a href="#2）制约关系：" class="headerlink" title="2）制约关系："></a>2）制约关系：</h5><p>生产者与消费者之间不直接发生联系，他们通过缓冲区发生制约关系<br>生产者生产商品，若缓冲区已满生产者等待，直到缓冲区有空为止<br>消费者在缓冲区空时等待，直到生产者的商品放入。否则，取一个商品消费。<br>注意：缓冲区为循环缓冲区</p><h5 id="3）问题分析"><a href="#3）问题分析" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><p>采用信号量机制，定义两个资源信号量<br>full是缓冲池“满”数目，初值为0，empty是缓冲池“空”数目，初值为N。实际上，full和empty是同一个含义：<br>           full + empty == N<br>只要缓冲池未满empty&gt;0，生产者便可将消息送入缓冲池；<br>只要缓冲池未空full&gt;0，消费者便可从缓冲池取走一个消息。 </p><h5 id="4）问题解答"><a href="#4）问题解答" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p><img src="/2020/08/14/OS-ch-2/2.4-1.jpg" alt></p><h5 id="5）问题扩充"><a href="#5）问题扩充" class="headerlink" title="5）问题扩充"></a>5）问题扩充</h5><p>若生产者与消费者变成多对多关系，我们要做什么变动？<br>增加互斥信号量: mutex=1;</p><p><img src="/2020/08/14/OS-ch-2/2.4-2.jpg" alt></p><h5 id="6）注意："><a href="#6）注意：" class="headerlink" title="6）注意："></a>6）注意：</h5><ul><li>每个程序中互斥的wait(mutex)和signal(mutex)必须成对出现。</li><li>对资源信号量empty和full的wait 、signal操作成对出现，但它们分别处于不同的程序中。例如wait在计算进程中，而signal则在打印进程中，计算进程若因执行wait而阻塞，则以后将由打印进程将它唤醒。</li><li>每个程序中的wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。</li></ul><h4 id="2-4-2-读者写者问题"><a href="#2-4-2-读者写者问题" class="headerlink" title="2.4.2 读者写者问题"></a>2.4.2 读者写者问题</h4><h5 id="1）问题描述"><a href="#1）问题描述" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><ul><li>一个数据文件或记录可被多个进程共享。其中，有些进程要求读；而另一些进程要求行写或修改。</li><li>只要求读的进程称为“Reader进程”，其它进程称为“Writer进程”。</li></ul><h5 id="2）制约关系"><a href="#2）制约关系" class="headerlink" title="2）制约关系"></a>2）制约关系</h5><ul><li>任一时刻“写者”最多只允许一个，而“读者”则允许多个――“读－写”互斥，“写－写”互斥，“读－读”允许。</li><li>所谓读者一写者问题是指保证一个Writer进程必须与其它进程互斥地访问共享对象的同步问题。</li></ul><h5 id="3）问题分析-1"><a href="#3）问题分析-1" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><ul><li><p>读者优先的解决方案：</p><ul><li>互斥信号量wrt，初值是1，代表一个共享文件。为解决“读－写”互斥，“写－写”互斥。</li><li>一个记数器，即整型变量readcount，记录读者数，初值是0。<ul><li>来一个读者， readcount加1</li><li>当readcount ＝1表示是第一个读者， 则需要执行p操作抢占文件；否则表示已有读者在安全的读数据。</li><li>走一个读者，readcount减1</li><li>当readcount ＝0表示是最后一个读者，则需要v操作释放资源；否则表示还有读者在读数据。</li></ul></li><li>readcount 为多个读者共享的变量，是临界资源。用互斥信号量mutex控制, mutex初值是1。</li></ul></li><li><p>写者优先：</p><ul><li>当一个写进程声明想写时，不允许新的读进程访问该数据区。</li></ul></li><li><p>解决方案：</p><ul><li>增加信号量r，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。</li><li>一个记数器，即整型变量writecount，记录写者数，初值是0。</li><li>writecount为多个写者共享的变量，是临界资源。用互斥信号量mutex2控制, mutex2初值是1。</li><li>增加mutex3，初值是1：在r上不允许建造长队列，否则写进程将不能跳过这个队列，因此，只允许一个读进程在r上排队，而所有其他读进程在等待r之前，在信号量mutex3上排队。</li></ul></li></ul><h5 id="4）问题解答-1"><a href="#4）问题解答-1" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p>读者优先方式：</p><p><img src="/2020/08/14/OS-ch-2/2.4-3.jpg" alt></p><p>写者优先方式：<br><img src="/2020/08/14/OS-ch-2/2.4-4.jpg" alt></p><h4 id="2-4-3-哲学家进餐问题"><a href="#2-4-3-哲学家进餐问题" class="headerlink" title="2.4.3 哲学家进餐问题"></a>2.4.3 哲学家进餐问题</h4><h5 id="1）问题描述-1"><a href="#1）问题描述-1" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><p>（由Dijkstra首先提出并解决）</p><ul><li>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</li><li>哲学家的动作包括思考和进餐：<ul><li>进餐时需要同时拿起他左边和右边的两支筷子，</li><li>思考时则同时将两支筷子放回原处。</li></ul></li></ul><h5 id="2）问题分析"><a href="#2）问题分析" class="headerlink" title="2）问题分析"></a>2）问题分析</h5><ul><li>哲学家逆时针编号0-4，筷子也相应编号</li><li>定义互斥信号量数组chopstick[5], 对应5支筷子，初值均为1。</li></ul><p>死锁问题的解决方法：</p><p><img src="/2020/08/14/OS-ch-2/2.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-6.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-7.jpg" alt></p><h3 id="2-5-管程"><a href="#2-5-管程" class="headerlink" title="2.5 管程"></a>2.5 管程</h3><h4 id="2-5-1-管程的基本概念"><a href="#2-5-1-管程的基本概念" class="headerlink" title="2.5.1 管程的基本概念"></a>2.5.1 管程的基本概念</h4><ul><li>利用信号量实现进程同步，使大量的同步操作分散在各个进程中。使系统管理麻烦，同步操作使用不当会引起死锁。</li><li>引入新的进程同步工具－－－管程（Monitors)</li><li>目的：分离互斥和条件同步的关注</li></ul><h5 id="管程由四部分组成："><a href="#管程由四部分组成：" class="headerlink" title="管程由四部分组成："></a>管程由四部分组成：</h5><ul><li><p>管程的名称</p></li><li><p>局部于管程的共享变量说明</p></li><li><p>对该数据结构进行操作的一组过程</p></li><li><p>对管程中数据设置初值的语句</p></li></ul><p>任何管程外的过程都不能访问管程内的数据结构。管程相当于围墙，将共享变量和对它进行操作的若干过程围了起来，进程只要访问临界资源就必须通过管程。</p><p>管程每次只允许一个进程进入管程，实现了互斥。</p><p>使用信号量的效率比管程高。</p><p>管程结构在一些程序设计语言中得到实现。如并发Pascal和Java，C#等，它还被作为一个程序库实现。</p><h3 id="2-6-进程之间的通信"><a href="#2-6-进程之间的通信" class="headerlink" title="2.6 进程之间的通信"></a>2.6 进程之间的通信</h3><p>进程通信时指进程之间的信息交换，所交换的信息量，少者是一个状态，多者是成千上万字节。</p><h4 id="进程通信分类："><a href="#进程通信分类：" class="headerlink" title="进程通信分类："></a>进程通信分类：</h4><h5 id="低级通信："><a href="#低级通信：" class="headerlink" title="低级通信："></a>低级通信：</h5><p>只能传递状态和整数值（控制信息）包括进程互斥和同步所采用的信号量和管程机制。</p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>传送信息量小，效率低，每次通信传输的信息量固定，传递较多信息需要多次通信。</p><p>编程复杂：用户直接实现通信的细节，容易出错。</p><h5 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h5><p>利用复杂的特定数据结构进行大信息量的通信。通信效率高。包括：</p><ul><li>共享存储器系统<ul><li>互相通信的进程共享某些数据结构或存储区，进程之间通过这些空间进行通信。分两类。<ul><li>共享数据结构：如缓冲区<ul><li>公用数据结构的设置及进程间同步的处理由程序员负责，OS只提供共享存储器</li><li>通信效率低，只适合少量数据</li></ul></li><li>共享存储区：为传递大量数据在存储器中划出一片共享存储区<ul><li>进程通信前，先向系统申请获得存储区的一个分区，并指定关键字；若系统已经给其他进程分配分区，则把该分区的描述符返回给申请者，申请者将获得的共享存储区连接到本进程上；此后可像读写普通存储器一样读写公用存储区。</li></ul></li></ul></li></ul></li><li>消息传递系统<ul><li>程序员利用OS提供的系统原语进行通信。简化通信程序编制</li></ul></li><li>管道通信系统<ul><li>利用读进程写进程实现通信的共享文件–pipe文件</li><li>写进程用字符流输入大流量数据送入管道，读进程接收数据</li><li>要求：<ul><li>互斥</li><li>同步</li><li>对方存在</li></ul></li></ul></li></ul><h4 id="消息传递实现方式："><a href="#消息传递实现方式：" class="headerlink" title="消息传递实现方式："></a>消息传递实现方式：</h4><h5 id="直接通信："><a href="#直接通信：" class="headerlink" title="直接通信："></a>直接通信：</h5><ul><li><p>利用OS提供的发送命令将消息发送到目标进程</p></li><li><p>发送进程和接收进程都以显示方式提供对方标识符。</p></li></ul><h5 id="间接通信："><a href="#间接通信：" class="headerlink" title="间接通信："></a>间接通信：</h5><p>利用双方之外的共享数据结构作为通信中转。（信箱）</p><p>信箱分为3类：</p><ul><li>私用信箱：用户自己创建，其他用户只能发送信息</li><li>公用信箱：OS创建，符合要求的进程都可以发消息</li><li>共享信箱：进程创建</li></ul><h3 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h3><p>线程：更小的能独立运行的单位。是进程当中执行的一条流程</p><p>引入线程是为了提高系统内程序的并发程度，提高系统效率增大作业吞吐量。</p><p>提出原因：进程开销过大，建立销毁执行效率不高。</p><p>需要满足特性：</p><ul><li>实体之间可以并发执行</li><li>实体之间共享相同的地址空间</li></ul><h4 id="线程的属性："><a href="#线程的属性：" class="headerlink" title="线程的属性："></a>线程的属性：</h4><ul><li><p>共享进程资源：一个进程的所有线程具有相同的地址空间，可以访问进程拥有的资源</p></li><li><p>轻型实体：</p><ul><li>只有少数资源<ul><li>线程标识符</li><li>线程控制块TCB</li><li>核心栈</li><li>私有存储区</li></ul></li></ul></li><li><p>线程是处理机调度的单位</p></li><li><p>可并发执行</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>一个进程中可以同时存在多个线程；</li><li>各个线程之间可以并发地执行；</li><li>线程的创建和终止时间比进程短；</li><li>各个线程之间可以共享内存和文件资源，因此可进行直接通信而不需要通过OS的内核。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li></ul><h4 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h4><p><img src="/2020/08/14/OS-ch-2/2.7-1.jpg" alt></p><h4 id="OS对线程的支持"><a href="#OS对线程的支持" class="headerlink" title="OS对线程的支持"></a>OS对线程的支持</h4><p>1.用户级线程：</p><ul><li>仅存在与用户空间中，内核不了解。</li><li>用线程库函数来控制</li><li>一个线程阻塞，整个进程都要等待</li><li>时间片分配给进程，线程执行时间相对较短</li></ul><p>2.内核线程</p><ul><li>OS支持，创建撤销切换都由内核实现</li><li>创建管理慢于用户级线程</li><li>能在多处理机并行，一个线程阻塞整个进程不阻塞</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>多对一</p><ul><li>多个用户级对一个内核</li><li>线程管理在用户空间进行，效率高</li><li>一个线程阻塞，整个进程阻塞</li></ul><p>一对一</p><ul><li>每个用户级线程都对应一个内核线程。</li><li>如果一个线程执行了阻塞系统调用，能允许另一个线程继续执行</li><li>缺点：创建内核线程的开销会影响应用程序的性能，限制系统所支持的线程数量。</li></ul><p>多对多</p><ul><li>用户线程数&gt;=内核数，与特定程序机器有关</li><li>允许系统根据资源分配创建内核进程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-进程管理&quot;&gt;&lt;a href=&quot;#第二章-进程管理&quot; class=&quot;headerlink&quot; title=&quot;第二章 进程管理&quot;&gt;&lt;/a&gt;第二章 进程管理&lt;/h2&gt;&lt;p&gt;为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进
      
    
    </summary>
    
    
    
      <category term="-操作系统 -OS -ch2" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-ch2/"/>
    
  </entry>
  
  <entry>
    <title>OS_ch_1</title>
    <link href="http://yoursite.com/2020/08/14/OS-ch-1/"/>
    <id>http://yoursite.com/2020/08/14/OS-ch-1/</id>
    <published>2020-08-14T07:00:18.000Z</published>
    <updated>2020-08-14T13:15:39.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统知识点梳理"><a href="#操作系统知识点梳理" class="headerlink" title="操作系统知识点梳理"></a>操作系统知识点梳理</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/2020/08/14/OS-ch-1/1.1-1.jpg" alt="####"></p><h5 id="地位与目标："><a href="#地位与目标：" class="headerlink" title="地位与目标："></a>地位与目标：</h5><h6 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h6><p>紧贴系统硬件之上，所有其他软件之下，（是其他软件的共同环境）</p><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><ul><li><p><strong>有效性</strong>（系统管理人员的观点）：管理和分配硬件、软件资源，合理地组织计算机的工作流程</p></li><li><p><strong>方便性</strong>（用户的观点）：提供良好的、一致的用户接口，弥补硬件系统的类型和数量差别</p></li><li><p><strong>可扩充性</strong>（开放的观点）：硬件的类型和规模、操作系统本身的功能和管理策略、多个系统之间的资源共享和互操作</p></li></ul><h5 id="操作系统的定义：（没有公认的定义）"><a href="#操作系统的定义：（没有公认的定义）" class="headerlink" title="操作系统的定义：（没有公认的定义）"></a>操作系统的定义：（没有公认的定义）</h5><ul><li>是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充</li><li>是一组控制和管理计算机硬件和软件资源，方便用户使用的程序集合<ul><li>控制程序执行以防错误和不当使用</li><li>执行用户程序并提供服务</li><li>管理各种计算机资源：CPU、硬盘、内存、硬件外设等</li><li>有效解决冲突请求并确保资源公平使用</li></ul></li></ul><h5 id="几种观点"><a href="#几种观点" class="headerlink" title="几种观点"></a>几种观点</h5><ol><li>OS是计算机硬件软件的管理者</li><li>OS是用户使用系统的接口</li><li>OS是扩展机/虚拟机<ul><li>在裸机上添加：设备管理，文件管理、存储管理（外存&amp;内存）、处理机管理</li></ul></li></ol><h4 id="1-2操作系统的发展历史"><a href="#1-2操作系统的发展历史" class="headerlink" title="1.2操作系统的发展历史"></a>1.2操作系统的发展历史</h4><h5 id="人工操作系统"><a href="#人工操作系统" class="headerlink" title="人工操作系统"></a>人工操作系统</h5><p><strong>1946-50年代</strong>，（电子管）集中计算（计算中心），计算机资源昂贵</p><p>人工操作特点：</p><ul><li>用户独占全机</li><li>CPU等待人工操作</li><li>串行性</li></ul><p>缺点：</p><ul><li>昂贵组件的低利用效率</li><li>利用率 = 执行时间/（执行时间+读卡时间）</li></ul><h5 id="单道批处理系统："><a href="#单道批处理系统：" class="headerlink" title="单道批处理系统："></a>单道批处理系统：</h5><p><strong>50年代末-60年代中</strong>(晶体管)利用磁带把若干个作业分类编成作业执行序列，每个批作业由一个专门的监督程序（Monitor）自动依次处理。可使用汇编语言开发。</p><p><img src="/2020/08/14/OS-ch-1/1.2-1.jpg" alt></p><p>特征：</p><ul><li>自动性</li><li>顺序性</li><li>单道性</li></ul><p>优点：</p><ul><li>同一批内各作业的自动依次更替，改善了主机CPU和I/O设备的使用效率提高了吞吐量。</li></ul><p>缺点：</p><ul><li><p>内存中仅有一道程序运行，当该程序运行结束或出故障，由监控程序换入另一个程序。不能很好地利用系统资源。</p></li><li><p><strong>CPU</strong>和I/O设备使用忙闲不均（取决于当前作业的特性）。对计算为主的作业，外设空闲；对I/O为主的作业，CPU空闲。</p></li></ul><p><strong>单道批处理系统是最早出现的一种OS,严格来说只能算是OS的前身而不是现在理解的OS，但该系统比起人工操作的系统已经有很大的进步</strong></p><h5 id="多道批处理系统："><a href="#多道批处理系统：" class="headerlink" title="多道批处理系统："></a>多道批处理系统：</h5><p><strong>60年代中~70年代中</strong>（集成电路）利用多到批处理提高资源的利用率。</p><p><img src="/2020/08/14/OS-ch-1/1.2-2.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.2-3.jpg" alt="多道批处理特点以及优缺点"></p><p>多道程序系统的技术问题：</p><ul><li>并行程序的运行需要共享软硬件资源，需要同步和互斥机制。</li><li>多道程序需要提高内存使用效率，需要覆盖技术，交互技术，虚拟存储等技术。</li><li>多道程序在内存中要保证系统存储区和用户存储区安全可靠，需要内存保护。.   </li></ul><h5 id="分时系统："><a href="#分时系统：" class="headerlink" title="分时系统："></a>分时系统：</h5><p><strong>70年代中期至今</strong>    </p><p>多个用户分享使用同一台计算机。每个用户给一定的时间运行，然后切换到另一用户，一个轮转周期在宏观上相当短，用户感觉不到。</p><p><img src="/2020/08/14/OS-ch-1/1.2-4.jpg" alt></p><p>分时系统特征：</p><ul><li>交互性：用户与系统进行人机对话</li><li>多路性：多用户同时在各自终端上使用同一CPU</li><li>独立性：用户可彼此独立操作，互不干扰，互不混淆。</li><li>及时性：用户在短时间内可以得到系统的及时回答。</li></ul><p>影响响应时间的因素：</p><ul><li>终端数目的多少</li><li>时间片的大小</li><li>信息交换量</li><li>信息交换速度</li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理。并控制所有事实任务协调一致的运行。</p></li><li><p>保证实时性和高可靠性，对系统的效率放在第二位。</p></li></ul><p>分类：实施控制系统，实时信息处理系统。</p><h5 id="实时系统与分时系统的比较"><a href="#实时系统与分时系统的比较" class="headerlink" title="实时系统与分时系统的比较"></a>实时系统与分时系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-5.jpg" alt></p><h5 id="多处理操作系统："><a href="#多处理操作系统：" class="headerlink" title="多处理操作系统："></a>多处理操作系统：</h5><p><img src="/2020/08/14/OS-ch-1/1.2-6.jpg" alt></p><h5 id="并行系统的类型："><a href="#并行系统的类型：" class="headerlink" title="并行系统的类型："></a>并行系统的类型：</h5><p>非对称式多重处理</p><p>对称式多重处理</p><h5 id="分布式操作系统与网络操作系统的比较"><a href="#分布式操作系统与网络操作系统的比较" class="headerlink" title="分布式操作系统与网络操作系统的比较"></a>分布式操作系统与网络操作系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-7.jpg" alt></p><h4 id="1-3-操作系统的特征和服务"><a href="#1-3-操作系统的特征和服务" class="headerlink" title="1.3 操作系统的特征和服务"></a>1.3 操作系统的特征和服务</h4><h5 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h5><ul><li><p><strong>并发</strong>：多个事件在同一时间段内发生，（并行是指单处理器下宏观上并发微观上交替执行）</p></li><li><p><strong>共享</strong>：多个进程共享有限的计算机资源，操作系统要对系统资源进行合理的分配和使用，资源在一个时间段内交替被多个进程使用。</p><hr><p>并发和共享是操作系统两个最基本特征，这两者之间是互为存在条件的</p><hr></li><li><p><strong>虚拟</strong>：一个物理实体映射为若干对应逻辑实体–分时或分空间，虚拟是操作系统管理系统资源的重要手段，提高资源利用率。</p></li><li><p><strong>异步</strong>：也称不确定性，指进程的执行顺序和执行时间的不确定性</p><ul><li>进程的运行速度不可预知</li><li>判据：无论快慢，应该结果相通–通过进程互斥和同步手段来保证。</li><li>难以重现系统在某个时刻的状态（包括重现运行中的错误）</li><li>性能保证：实时系统与分时系统类似，但通过资源预留以保证性能。</li></ul></li></ul><h5 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h5><p>1 管理模块：针对不同管理对象的程序模块（操作系统核心）</p><p>2.用户接口：shell,窗口系统</p><h4 id="1-4-操作系统功能"><a href="#1-4-操作系统功能" class="headerlink" title="1.4 操作系统功能"></a>1.4 操作系统功能</h4><h5 id="1-4-1-存储管理"><a href="#1-4-1-存储管理" class="headerlink" title="1.4.1 存储管理"></a>1.4.1 存储管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-1.jpg" alt></p><h5 id="1-4-2-处理机管理"><a href="#1-4-2-处理机管理" class="headerlink" title="1.4.2 处理机管理"></a>1.4.2 处理机管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-2.jpg" alt></p><h5 id="1-4-3-设备管理"><a href="#1-4-3-设备管理" class="headerlink" title="1.4.3 设备管理"></a>1.4.3 设备管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-3.jpg" alt></p><h5 id="1-4-4-文件管理"><a href="#1-4-4-文件管理" class="headerlink" title="1.4.4 文件管理"></a>1.4.4 文件管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-4.jpg" alt></p><h5 id="1-4-5-用户接口"><a href="#1-4-5-用户接口" class="headerlink" title="1.4.5 用户接口"></a>1.4.5 用户接口</h5><p>目标：提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供给用户。</p><p>命令接口：为联机用户提供的，由一组键盘操作命令及命令解释程序所组成，又分联机和脱机用户接口。</p><p>程序接口：为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的路径。它由一组系统调用组成。</p><p>图形接口：用户可用鼠标或菜单和对话框来完成对应应用程序和文件的操作。</p><h5 id="双模式操作"><a href="#双模式操作" class="headerlink" title="双模式操作"></a>双模式操作</h5><h6 id="用户模式（目态）"><a href="#用户模式（目态）" class="headerlink" title="用户模式（目态）"></a>用户模式（目态）</h6><p>执行普通用户的应用程序</p><h6 id="系统模式（管态）"><a href="#系统模式（管态）" class="headerlink" title="系统模式（管态）"></a>系统模式（管态）</h6><p>执行操作系统核心代码</p><h6 id="分辨方式："><a href="#分辨方式：" class="headerlink" title="分辨方式："></a>分辨方式：</h6><p>在程序状态字中添加模式位指示目前所处模式：系统态(0)或用户态(1)</p><p>发生中断或故障（自陷）<font color="red">硬件</font>自动从用户态切换到系统态</p><p>当用户程序需要操作系统的服务（通过系统调用）必须由管态切换到目态。</p><p><img src="/2020/08/14/OS-ch-1/1.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.4-6.jpg" alt></p><h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex1.jpg" alt="1."></p><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex2.jpg" alt="1."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统知识点梳理&quot;&gt;&lt;a href=&quot;#操作系统知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;操作系统知识点梳理&quot;&gt;&lt;/a&gt;操作系统知识点梳理&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是操作系统&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Ch.3</title>
    <link href="http://yoursite.com/2020/07/26/CSAPP-Ch-3/"/>
    <id>http://yoursite.com/2020/07/26/CSAPP-Ch-3/</id>
    <published>2020-07-26T09:07:46.000Z</published>
    <updated>2020-08-14T13:16:51.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP第三章"><a href="#CSAPP第三章" class="headerlink" title="CSAPP第三章"></a>CSAPP第三章</h2><h3 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h3><h4 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h4><p>Intel &amp; AMD</p><h4 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>gcc</strong>： Linux上默认的编译器</p></li><li><p><strong>-Og</strong>:   编译选项，告诉编译器使用会生成符合原始C代码整体结构的机器代码编译优化等级</p></li></ul><h5 id="gcc命令调用过程"><a href="#gcc命令调用过程" class="headerlink" title="gcc命令调用过程"></a>gcc命令调用过程</h5><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgcc%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="gcc命令调用过程"></p><p>用图片的形式描述一下就是这样的：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgccppt.jpg" alt="gccppt"></p><h5 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h5><ul><li><strong>机器级编程的两种抽象</strong><ul><li>指令集体系结构或指令集架构（Instruction Set Architexture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态，指令格式以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看起来像一个非常大的数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li></ul></li></ul><h5 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h5><p>以C代码文件<code>mstore.c</code>为例，在命令行上使用<code>-S</code>选项，可以看到C语言编译产生的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure><p>这时GCC会运行编译器，产生汇编文件<code>mstore.s</code>但是不做进一步操作</p><p>如果用  <code>-c</code>命令行选项GCC会编译并汇编该代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure><p>这样就会产生目标代码文件<code>mstore.o</code>它是二进制格式的，无法直接进行查看,想要查看机器代码的内容，可以通过<code>反汇编器(disassembler)</code>进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d mstore.o</span></span><br></pre></td></tr></table></figure><p>机器代码以及反汇编表示的特性：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E7%89%B9%E6%80%A7.jpg" alt="机器代码以及反汇编表示的特性"></p><h5 id="3-2-3-关于格式的注释"><a href="#3-2-3-关于格式的注释" class="headerlink" title="3.2.3 关于格式的注释"></a>3.2.3 关于格式的注释</h5><p>以书上内容为例</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.jpg" alt="example"></p><p>所有以<font color="red"><code>.</code></font>开头的行都是指导汇编器和连接器工作的伪指令，我们通常可以忽略。</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.2.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h4><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.3.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h4><h5 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h5><p>大多数指令具有一个或者多个操作符，用于指示出执行一个操作中要用的源数据值以及放置结果的目的地址值。不同种操作数可能被分为三类：</p><ul><li>立即数        <ul><li>用来表示常数值</li><li>书写方式是<code>$+标准C表示法表示的整数</code>，例如：<code>$-577，$0x1F</code></li><li>不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码</li></ul></li><li>寄存器        <ul><li>表示某个寄存器中的内容，16个寄存器的低1字节、2字节、4字节和8字节中的一个作为操作数，分别对应8位、16位、32位以及64位。</li><li>用r<sub>a</sub>来表示任意寄存器ａ，用引用R[r<sub>a</sub>]来表示它的值，（将寄存器集看做数组R）</li></ul></li><li>内存引用<ul><li>根据计算出来的地址（有效地址）访问某个内存位置。</li><li>用M<sub>b</sub>[Addr]表示对存储在内存中地址Addr开始的b个字节进行引用,为了方便通常省略下标b</li></ul></li></ul><p>操作数格式标示图如下：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%A4%BA%E5%9B%BE.jpg" alt="机器代码以及反汇编表示的特性"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSAPP第三章&quot;&gt;&lt;a href=&quot;#CSAPP第三章&quot; class=&quot;headerlink&quot; title=&quot;CSAPP第三章&quot;&gt;&lt;/a&gt;CSAPP第三章&lt;/h2&gt;&lt;h3 id=&quot;程序的机器级表示&quot;&gt;&lt;a href=&quot;#程序的机器级表示&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Git个人博客搭建</title>
    <link href="http://yoursite.com/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-26T15:34:47.000Z</published>
    <updated>2020-06-27T06:44:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Git个人博客搭建（一）"><a href="#Hexo-Git个人博客搭建（一）" class="headerlink" title="Hexo+Git个人博客搭建（一）"></a>Hexo+Git个人博客搭建（一）</h1><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​    拥有一个私人博客一直都是每个<del>程序员</del>的理想，恰好赶上最近不想学习，用了一下午的时间搭建<del><strong>采坑</strong></del>了Hexo+Git个人博客搭建（主要是免费啊！！！免费啊！！）遇到的一些问题以及搭建过程进行一个记录，也希望能减少后来人的掉发量（笑）。那我们现在就开始愉快的脱发之旅吧！</p><hr><h3 id="二、Hexo简介"><a href="#二、Hexo简介" class="headerlink" title="二、Hexo简介"></a>二、Hexo简介</h3><p>​    关于Hexo，我觉得没有什么比他简介中的说法能更好的解释这个软件的话语了。</p><blockquote><p>快速、简洁且高效的博客框架</p></blockquote><p>​    速度快、一键部署、支持MarkDown、可扩展插件。。最重要的是<font color="red"><strong>开源免费</strong></font>! 大写加粗的重要啊朋友们！！！开发者是台湾人，所以<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>的官网对中文支持极度友好，对英语有怨念的同学可以在官网选择中文查阅文档以及API。</p><p>​    Hexo是基于<strong>Node.js</strong>的静态博客框架，依赖少安装容易，可以很方便的生成网页托管在GitHub上或者云上，是搭建博客的首要选择。本文采用的是网页托管到GitHub上来进行博客搭建。</p><hr><h3 id="三、安装过程"><a href="#三、安装过程" class="headerlink" title="三、安装过程"></a>三、安装过程</h3><h4 id="1-系统配置"><a href="#1-系统配置" class="headerlink" title="1.系统配置"></a>1.系统配置</h4><p>​    提及安装过程不提系统以及版本的都是流氓！首先放上我自己的系统配置：</p><blockquote><p>win10_64位教育版 A卡全家桶套餐（与安装无关不详细写了）</p><p>git –version 2.27.0.windows.1</p><p>npm –version 6.14.5</p></blockquote><p>​    由于我本身是Windows版本，所以以下的安装过程主要按照windows版本来描述，但是用Linux的小伙伴的安装过程也是大同小异（具体安装方法我也会在下面提及）。特别是安装git后使用的命令行基本和linux一样，所以系统版本就没有那么重要了</p><hr><h4 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2.Node.js安装"></a>2.Node.js安装</h4><p>​    在上文说道，Hexo是基于Node.js的，所以首先就要安装Node.js的依赖。这里我直接给出Node.Js的下载网址以及Git的安装网址以方便查阅。</p><p>​                                                                          <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener"> 点击这里安装Node.js</a></p><p>​    Node.js的安装极度简单，如果直接下载.msi文件的话只要一路next就可以安装成功。这里有问题的小伙伴请自行百度谷歌</p><h4 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3.Git安装"></a>3.Git安装</h4><p>​    下一步是Git的安装，这里一样给出git的下载网址以便下载。</p><p>​                                                                                 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">点击这里下载Git</a></p><p>​    Linux的安装方法则更加简单，以Ubuntu为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line"></span><br><span class="line">sudo apt-get install npm</span><br><span class="line"></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装后打开cmd(terminal)输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果出现了版本号，就证明你安装成功了，我的是这样的：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Git&npm.jpg" alt="我的配置"></p><p>在安装成功后就可以在Git里面敲命令行啦，比Windows本身带的cmd要好用许多。</p><h4 id="4-Hexo安装"><a href="#4-Hexo安装" class="headerlink" title="4.Hexo安装"></a>4.Hexo安装</h4><p>​    到了这里，恭喜你终于开始安装框架了，进入到了安装博客的第一步。</p><p>​    首先要在自己喜欢的位置创建一个文件夹来放你的博客，我选择的位置是D://Blog (路径习惯性的用英文可以减少不少莫名其妙的Bug)</p><p>​    在此处右键打开Git Bash，或者勤快的同学也可以从桌面cd进去</p><p>​    输入命令<code>npm install -g heso-cli</code></p><p>​    安装好后用<code>hexo -v</code>检查版本号</p><p>​    下面继续回到GIt中，初始化一下Hexo输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>​    在你选择的文件夹中应该能看到这样的文件结构（我的文件经过编译提交了，安装完后应该会比这个少几个文件）：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo.jpg" alt="我的文件"></p><p>​    在这个文件列表中，</p><ul><li><p>node_modeules 是用来存放依赖包的文件</p></li><li><p>public 是用来存放生成的页面的文件</p></li><li><p>scaffold 用来生成文章的一些模板</p></li><li><p>source文件夹用来存放你的博客文件</p></li><li><p>themes是博客的主题</p></li><li><p>_config.yml是配置文件，</p><p>在推送到Git上时我们都会用到。但这都是之后的事情啦</p><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>​        这样就可以在<code>localhost:4000</code>看到你的博客啦，但是现在的博客不仅主题不好看，而且还只是在你自己电脑上运行的，并没有部署到Git上托管。</p><p>​    既然提到了博客界面很丑陋，那我们为什么不换一个主题呢？Hexo显然也考虑到了这点，为我们提供了一个很好的下载主题的网站，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>你就可以找到一个你喜欢的博客模板进行下载了。把下载的主题直接解压放在theme文件夹里，命名为你下载的主题，在_config.yml 中修改<code>theme</code>为你下载的名称。</p><p>​    比如我应用的是名称是<code>clean</code>的一个主题。那我修改的方式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: clean</span><br></pre></td></tr></table></figure><h4 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h4><p>​    我默认你在看这篇文章之前已经有一个GItHub账户了，如果没有的话直接去注册一个也很方便。如果你已经配置过Git以及SSH可以直接跳过。</p><p>在网页的右上角选择<code>new respository</code>新建一个仓库</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitNewRes.jpg" alt="New repository"></p><p>​    输入仓库名称为<code>UserName/UserName.git.io</code></p><p>​    可能这么说会有人不理解，那我就放上一个更直白的方式：</p><p>​    我的用户名称为Yokeso ,那我创建的库名称就为<code>Yokeso/Yokeso.git.io</code>顺便附上图片希望对小白有所帮助</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/newres.jpg" alt="Repository"></p><p>​    这个名称是GitHub专门用来给用户的网站接口，每个用户只能创建一个，并且<font color="red">是免费的</font>。</p><p>回到你的GItBash下，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure><p>​    这里的yourname 是你的用户名，youremail是你注册GItHub时用的邮箱，这样GitHub才知道你是他的对应用户。</p><p>​    输入完成之后如果不放心可以用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>​    来进行检查。</p><h4 id="5-Git创建SSH"><a href="#5-Git创建SSH" class="headerlink" title="5.Git创建SSH"></a>5.Git创建SSH</h4><p>​    创建SSH同样只需要GitBash上的一个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></table></figure><p>​    如果想创建秘钥的话可以创建，但只是个人博客的话没有创建秘钥的必要，所以一路回车直接过去。</p><p>​    SSH会默认在你的/User/.ssh下创建秘钥，这里的id_rsa是这台电脑的私人秘钥，Id_rsa.pub是公钥。需要提交到GItHub上。只有秘钥公钥相互匹配是你才能顺利的传输到你的gitHub上。你可以给他直接打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后将这段代码（普遍是以ssh-rsa AAAA开头）直接复制，粘贴到个人仓库上方<code>setting</code>中的SSH目录里。这里涉及到个人隐私，所以不贴图展示了。</p><p>如果不知道是否创建成功的话，你可以直接输入以下命令进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这个代码在成功情况下回返回这样的一个结果</p><p><code>Hi Yokeso(这里是我的用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h4 id="6-将Hexo部署上去"><a href="#6-将Hexo部署上去" class="headerlink" title="6.将Hexo部署上去"></a>6.将Hexo部署上去</h4><p>​    到了这里，你已经完成一大半了，最后一步就是要将你的博客部署到GitHub上。</p><p>​    打开_config.yml，在最后你会看到一个<code>deploy</code>字段，将其修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你的账户名称&#x2F;你的账户名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​    <font color="red">千万要注意repo字段，将git上面仓库的地址直接复制过来，选择https方式，我这里在网络上没找明白，弄了好久。</font></p><p><img src="/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/https.jpg" alt="复制到repo字段"></p><p>​    在最后部署之前,先要安装<code>hexo-deployer</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nom install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li><p><code>hexo clean</code>是用来清除你之前生成的东西</p></li><li><p><code>hexo g</code>用来生成静态文章 g的全称为generate （当然可以在命令行里写hexo generate）</p></li><li><p><code>hexo d</code>用来部署文章（deploy）</p><p>过一会儿就能在http://你的注册名称.github,io上看到你的博客了！</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>​    作为智能专业的学生，很少接触网络的一些东西，这次搭建Hexo也是一时的心血来潮，想要做一些整理工作。描述下来比较简单，但在repo字段的问题上就浪费了我将近一个小时去寻找问题。同时，这也是我第一次接触markdown 以及写博客。应该有些算晚了，但对于一个工具来说，也应该没有什么早晚的区别。我也希望通过我的博客能够与大家多多交流，将自己搭建各种环境包括做各种项目时候的一些心得和大家一起分享</p><p>Code To Make World Better!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Git个人博客搭建（一）&quot;&gt;&lt;a href=&quot;#Hexo-Git个人博客搭建（一）&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Git个人博客搭建（一）&quot;&gt;&lt;/a&gt;Hexo+Git个人博客搭建（一）&lt;/h1&gt;&lt;h2 id=&quot;文章目录&quot;
      
    
    </summary>
    
    
    
      <category term="-Hexo -个人博客" scheme="http://yoursite.com/tags/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
