<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yokeso.top/"/>
  <updated>2021-01-05T13:46:48.634Z</updated>
  <id>http://yokeso.top/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MapReduce</title>
    <link href="http://yokeso.top/2021/01/04/MapReduce/"/>
    <id>http://yokeso.top/2021/01/04/MapReduce/</id>
    <published>2021-01-04T08:36:14.000Z</published>
    <updated>2021-01-05T13:46:48.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce原理及介绍"><a href="#MapReduce原理及介绍" class="headerlink" title="MapReduce原理及介绍"></a>MapReduce原理及介绍</h2><p>MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式运算。抽象了分布式计算系统上运行一个并行程序的数据流，以函数形式提供给用户两个接口：Map（映射）和Reduce（化简）用户可以重载这两个函数以实现交互和操纵其中的程序数据流</p><h4 id="MapReduce形式化定义"><a href="#MapReduce形式化定义" class="headerlink" title="MapReduce形式化定义"></a>MapReduce形式化定义</h4><p>MapReduce软件框架向用户提供了一个据欧数据流和控制流的抽象层，并隐藏了数据流的实现步骤。但抽象层提供了Map和Reduce两个函数，用户可以通过重载这两个主函数达到特定目标</p><p>用户首先重载Map和Reduce函数，然后调用<code>MapReduce（Spec，&amp;Results）</code>来开始数据流，其中<code>Spec</code>先在用户程序中初始化，然后用户编写代码来填入输入和输出文件名以及其他可选调节参数。这个对象还填入了Map和Reduce函数的名字，以识别这些用户定义的函数和MapReduce库里提供的函数</p><p><img src="/2021/01/04/MapReduce/image-20210105164548758.png" alt="image-20210105164548758"></p><h4 id="MapReduce逻辑数据流"><a href="#MapReduce逻辑数据流" class="headerlink" title="MapReduce逻辑数据流"></a>MapReduce逻辑数据流</h4><p>Map的输入数据是以<code>（key,value）</code>对形式出现，输出数据的结构类似于<code>（key,value）</code>对，称为中间<code>（key,value）</code>对，换句话说，用户自定义Map函数处理每个<code>（key,value）</code>对，并产生很多<code>（zero,one,ormore）</code>中间<code>（key,value）</code>对。目的是为了Map函数并行处理所有的<code>（key,value）</code>对</p><p><img src="/2021/01/04/MapReduce/image-20210105170548205.png" alt="image-20210105170548205"></p><p>反过来，Reduce函数以中间值群组的形式接受中间<code>（key,value）</code>对，这些中间值群组和一个中间key<code>（key,[set of values]）</code>相关。实际上，MapReduce框架形成了这些群组，先对中间<code>（key,value）</code>对排序，然后用key来对value分组</p><p><strong>注意，排序是为了简化分组</strong></p><p>reduce 函数处理每个<code>（key,[set of values]）</code>群组，并产生<code>（key,value）</code>对集合作为输出。</p><h4 id="单词计数顺序"><a href="#单词计数顺序" class="headerlink" title="单词计数顺序"></a>单词计数顺序</h4><p><img src="/2021/01/04/MapReduce/image-20210105191718304.png" alt="image-20210105191718304"></p><p><strong>符号化</strong>：（key1,val1）-Map函数-&gt;List(key2,val2)</p><p>​                （key2,List(val2)）-Reduce函数-&gt;List（val2）</p><h4 id="MapReduce真实数据和控制流"><a href="#MapReduce真实数据和控制流" class="headerlink" title="MapReduce真实数据和控制流"></a>MapReduce真实数据和控制流</h4><p>1.数据分区：MapReduce库将已存入GFS的输入数据分割成m份，M也即映射任务的数量。</p><p>2.计算分区：计算模块强迫用户以Map和Reduce函数的形式编写程序，并在框架中隐式处理，所以MapReduce库只生成用户程序的多个复制（fork），包含MAp和Reduce函数，然后在多个可用的计算引擎上分配。</p><p>3.决定主服务器（master）和服务器（worker）：MapReduce基于主服务器-服务器模式，一个用户程序的复制变为主服务器，其余是服务器。主服务器挑选空闲服务器，分配MapReduce任务给他们。</p><p>4.读取输入数据（数据分发）：每一个映射服务器读取其输入数据的相应部分，即输入数据分割，然后输入至其Map函数。虽然一个映射服务器可能运行多个Map函数，这意味着它分到了不止一个输入数据分割；通常每个服务器只分到一个输入分割。</p><p>5.Map函数：用<code>（key,value）</code>对集合的形式收到输入数据分割，来处理并产生中间<code>（key,value）</code>对。</p><p>6.Combiner函数：映射服务器中一个可选的本地函数。适用于中间的<code>（key,value）</code>对。用户可以在用户程序里调用。Combiner运行与Reduce一样的功能。合并每个映射服务器的本地数据然后送到网络传输。</p><p>7.Partitioning函数：分块是由Partitioning（分区）函数完成，并能保证有相同键值的所有<code>（key,value）</code>对都能存储在同一区域内。因此，由于化简服务器i读取所有映射服务器区域i中的数据，有相同key的所有<code>（key,value）</code>对将由相应的化简服务器i收集。 </p><p><img src="/2021/01/04/MapReduce/image-20210105201025104.png" alt="image-20210105201025104"></p><p>8.同步：当所有映射任务完成，他们之间的通信开始</p><p>9.通信：Reduce服务器i已经知道所有映射服务器的区域i的位置，使用远程过程调用来从所有映射服务器的各个区域中读取数据。由于所有化简服务器从所有映射服务器中读取数据，映射和化简服务器之间的多对多通信在网络中进行，会引发网络拥塞。这个问题是提高此类系统性能的一个主要瓶颈。</p><p>10.排序和分组：当化简服务器完成读取输入数据的过程时，数据首先在化简服务器的本地磁盘中缓冲。然后化简服务器根据key将数据排序来对中间(key, value)对进行分组，之后对出现的所有相同key进行分组。注意，缓冲数据已经排序并分组，因为一个映射服务器产生的唯一key的数量可能会多于R个区域，所以在每个映射服务器区域中可能有不止一个key。</p><p>11.Reduce函数：简化服务器在已分组的<code>（key,value）</code>对上的迭代。对于每一个唯一的key，把key对应的value发送给Reduce函数，然后把这个函数出来输入数据，最后的结果存入用户程序指定的文件中。</p><p><img src="/2021/01/04/MapReduce/image-20210105205303260.png" alt="image-20210105205303260"></p><h4 id="来自Apache的Hadoop软件库"><a href="#来自Apache的Hadoop软件库" class="headerlink" title="来自Apache的Hadoop软件库"></a>来自Apache的Hadoop软件库</h4><p>Hadoop是Apache用Java实现的MapReduce开源实现，使用HDFS作为底层，MapReduce引擎是运行在HDFS上的计算引擎，HDFS是他的数据存储管理器。</p><p>HDFS：源于GFS的分布式文件系统，分布式计算系统上管理文件和存储数据</p><p>HDFS体系结构：主从体系结构，包括单个NameNode(master)和多个DataNode(slave)。HDFS将文件分为固定大小的块，并存放在工作机中，块的映射由Namenode决定。master也管理文件系统的元数据和命名空间，在系统中，命名空间是维护元数据的区域，元数据是指一个文件系统存储的所有信息。是所有文件的全面管理所需要的。</p><p>HDFS特性：HDFS不支持安全性，主要讨论两个特性</p><ul><li><p>容错能力：Hadoop设计时默认部署在廉价的硬件上，系统故障很常见。</p><ul><li>块复制：HDFS把文件存储为一个块集，每个块都有备份并且在整个集群上分发。</li><li>备份布置：提供更大的可靠性，但通信成本稍高</li><li>HeartBeat和LockReport消息：这两个消息都由DataNode传输给NameNode，收到Heartbeat意味着DataNode正常运行，而每个Blockreport包括DataNode上所有块的清单</li></ul></li><li><p>高吞吐量访问大规模数据集：因为是为批处理设计而非交互式处理，所以吞吐量比延时更重要。</p></li></ul><p>HDFS操作：控制流能正确突出在管理操作中NameNode和DataNode的角色</p><ul><li>读取文件：用户发送Open请求给NameNode来获取文件块位置信息</li><li>写入文件：用户发送create请求给NameNode来在命名空间里创建文件</li></ul><h4 id="Hadoop里运行作业"><a href="#Hadoop里运行作业" class="headerlink" title="Hadoop里运行作业"></a>Hadoop里运行作业</h4><p><img src="/2021/01/04/MapReduce/image-20210105214423025.png" alt="image-20210105214423025"></p><ul><li><p>作业提交：每个作业由用户提交到master</p><ul><li>用户从master请求新ID，并计算输入文件分块</li><li>用户复制资源l比如用户的JAR文件、配置文件和计算输入分块，至JobTracker文件系统。</li><li>用户节点通过调用submitJob()函数提交任务至JobTracker。</li></ul></li><li><p>任务分配：JobTracker为用户节点的每个计算输入块建立一个映射任务，并分配给TaskTracker的执行槽。当分配映射任务给TaskTracker时，JobTracker会考虑数据的定位。JobTracker也会创建化简任务，并分配给TaskTracker。 </p></li><li><p>任务执行：把作业JAR文件复制到其文件系统之后，在TaskTracker执行一个任务（不管映射还是化简）的控制流就开始了。在启动Java虚拟机（Java Virtual Machine，JVM）来运行它的映射或化简任务后，就开始执行作业JAR文件里的指令。</p></li><li><p>任务运行校验：通过接收从TaskTracker到JobTracker的周期性心跳监听消息来完成任务运行校验。每个心跳监听会告知JobTracker传送中的TaskTracker是可用的，以及传送中的TaskTracker是否准备好运行一个新的任务。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MapReduce原理及介绍&quot;&gt;&lt;a href=&quot;#MapReduce原理及介绍&quot; class=&quot;headerlink&quot; title=&quot;MapReduce原理及介绍&quot;&gt;&lt;/a&gt;MapReduce原理及介绍&lt;/h2&gt;&lt;p&gt;MapReduce是一个软件框架，可以支持大
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Distributed_cloud-computing</title>
    <link href="http://yokeso.top/2021/01/03/Distributed-cloud-computing/"/>
    <id>http://yokeso.top/2021/01/03/Distributed-cloud-computing/</id>
    <published>2021-01-03T02:17:09.000Z</published>
    <updated>2021-01-05T07:46:10.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-分布式系统模型和关键技术"><a href="#第一章-分布式系统模型和关键技术" class="headerlink" title="第一章 分布式系统模型和关键技术"></a>第一章 分布式系统模型和关键技术</h2><h3 id="1-1互联网上的可扩展计算"><a href="#1-1互联网上的可扩展计算" class="headerlink" title="1.1互联网上的可扩展计算"></a>1.1互联网上的可扩展计算</h3><p>一个并行的、分布式的计算系统使用大量的计算机解决互联网上的大规模计算问题。<br>   分布式计算的缺点是数据敏感和网络中心化</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103101834253.png" alt="image-20210103101834253"></p><h3 id="计算范式之间区别"><a href="#计算范式之间区别" class="headerlink" title="计算范式之间区别"></a>计算范式之间区别</h3><p>集中式计算：计算资源存储在一个物理系统内，所有资源共享，紧耦合在一个集成式操作系统中</p><p>并行计算：所有处理器紧耦合于中心共享内存或松耦合于分布式内存</p><p>分布式计算：众多自治的计算机组成，拥有私有内存，通过计算机网络通信。信息交换通过消息传递完成。</p><p>云计算：集中式或分布式，由物理的或虚拟的计算资源构建</p><p>普适计算：任何地点时间通过有线或者无线用普遍设备计算</p><p>物联网：通过互联网云实现普适计算</p><h3 id="分布式和云计算系统模型"><a href="#分布式和云计算系统模型" class="headerlink" title="分布式和云计算系统模型"></a>分布式和云计算系统模型</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103104520742.png" alt="image-20210103104520742"></p><h3 id="协同计算机集群"><a href="#协同计算机集群" class="headerlink" title="协同计算机集群"></a>协同计算机集群</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103104933760.png" alt="image-20210103104933760"></p><h3 id="互联网云计算"><a href="#互联网云计算" class="headerlink" title="互联网云计算"></a>互联网云计算</h3><p>云提供了虚拟机或物理机快速配置和划分，云支持冗余，自恢复，高可扩展编程模型，允许负载从许多不可避免的硬件软件错误中恢复。最终云计算系统可以通过实时监视资源来确保分配在需要时平衡</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103105242598.png" alt="image-20210103105242598"></p><h3 id="性能、安全和节能"><a href="#性能、安全和节能" class="headerlink" title="性能、安全和节能"></a>性能、安全和节能</h3><h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><ul><li>性能度量（MIPS、Tflops）每秒浮点运算次数（M/T）、（TPS）每秒事物数，其他度量包括作业响应时间和网络延迟</li><li>系统开销归因于系统启动时间、编译时间、IO数据速率和运行时支持系统消耗。其他性能包括互联网WEb QoS，系统可用性和可靠性，抵抗网络攻击的安全弹性</li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103105756172.png" alt="image-20210103105756172"></p><h2 id="第三章-虚拟机集群和数据中心虚拟化"><a href="#第三章-虚拟机集群和数据中心虚拟化" class="headerlink" title="第三章 虚拟机集群和数据中心虚拟化"></a>第三章 虚拟机集群和数据中心虚拟化</h2><h3 id="3-1-虚拟化的实现层次"><a href="#3-1-虚拟化的实现层次" class="headerlink" title="3.1 虚拟化的实现层次"></a>3.1 虚拟化的实现层次</h3><p>通过在一个硬件主机上多路复用的虚拟机方式共享昂贵的硬件资源</p><p>基本思想是分离软硬件以产生更好的系统性能</p><h4 id="虚拟化实现层次"><a href="#虚拟化实现层次" class="headerlink" title="虚拟化实现层次"></a>虚拟化实现层次</h4><p>为了让客户操作系统独立于主机操作系统并同时运行在一个硬件上，添加虚拟化层软件完成（hypercisor）/虚拟机监视器（VMM）</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103111007166.png" alt="image-20210103111007166"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103111806694.png" alt="image-20210103111806694"></p><ul><li><p>指令集体系结构级：代码解释和动态二进制翻译</p></li><li><p>硬件抽象级：虚拟化一个计算机硬件资源</p></li><li><p>操作系统级：在单一物理服务器上创建隔离的容器和操作系统实例</p></li><li><p>库支持级：库接口的虚拟化</p></li><li><p>应用程序级：进程级虚拟化、高级语言（High Level Language，HLL）虚拟机</p></li></ul><h4 id="VMM设计需求"><a href="#VMM设计需求" class="headerlink" title="VMM设计需求"></a>VMM设计需求</h4><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><ul><li><p>为程序提供与原始硬件机器一致的环境</p></li><li><p>运行在环境中的程序性能损失较低</p></li><li><p>系统资源处在完全控制中</p></li></ul><h5 id="资源："><a href="#资源：" class="headerlink" title="资源："></a>资源：</h5><ul><li>为应用程序分配硬件</li><li>程序不能访问任何未分配给他的资源</li><li>某些情况下VMM可以获得对已分配资源的控制权</li></ul><h4 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h4><p>操作系统中插入一个虚拟化层，使得操作系统内核中同时运行多个隔离虚拟机，这种虚拟机也称（VE、VPS、容器）</p><p>用户看来VE就是真实服务器，有自己进程，文件系统，用户账号，带IP的网络接口，路由表，防火墙规则和其他个人设置，</p><p>不同用户共享一个系统内核，<strong>操作系统虚拟化也称系统镜像虚拟化</strong></p><h3 id="3-2虚拟化的结构、工具与机制"><a href="#3-2虚拟化的结构、工具与机制" class="headerlink" title="3.2虚拟化的结构、工具与机制"></a>3.2虚拟化的结构、工具与机制</h3><p>hypervisor与Xen体系结构</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103131438789.png" alt="image-20210103131438789"></p><ul><li>Xen属于微内核hypersor</li><li>提供一种客户端直接访问物理设备的机制</li><li>提供处于硬件和操作系统之间的虚拟环境</li><li>核心组件是hypercisor、内核和应用程序</li><li>具有控制特权的客户操作系统称为Doman0，其他称为DomanU</li><li>Doman0首先启动，直接访问硬件和设备，为所有DomanU分配资源</li></ul><h4 id="全虚拟化的二进制翻译"><a href="#全虚拟化的二进制翻译" class="headerlink" title="全虚拟化的二进制翻译"></a>全虚拟化的二进制翻译</h4><p>全虚拟化（依赖二进制翻译，客户端和应用由非临界和临界指令生成）</p><p>基于主机的虚拟化（操作系统和客户机同时存在，虚拟化软件层位于两者之间，客户端跑在虚拟化层上，特定的应用运行在虚拟机中）</p><h4 id="编译器支持的半虚拟化技术"><a href="#编译器支持的半虚拟化技术" class="headerlink" title="编译器支持的半虚拟化技术"></a>编译器支持的半虚拟化技术</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103141520694.png" alt="image-20210103141520694"></p><h3 id="3-3CPU、内存和IO设备的虚拟化"><a href="#3-3CPU、内存和IO设备的虚拟化" class="headerlink" title="3.3CPU、内存和IO设备的虚拟化"></a>3.3CPU、内存和IO设备的虚拟化</h3><h4 id="虚拟化的硬件支持"><a href="#虚拟化的硬件支持" class="headerlink" title="虚拟化的硬件支持"></a>虚拟化的硬件支持</h4><p>为防止系统崩溃，设置用户模式和管理模式，对临界区硬件的受控访问（特权指令和非特权指令）</p><h4 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h4><ul><li><p>非特权指令直接在物理主机运行</p></li><li><p>关键指令</p><ul><li>特权指令在特权模式执行，非特权模式发生<strong>陷入</strong></li><li>控制敏感指令尝试改变资源配置</li><li>行为敏感指令根据资源配置有不同行为，包括虚拟内存的负载和存储</li></ul></li><li><p>VMM在运行管理模式时，CPU支持在用户模式运行虚拟机的特权指令和非特权指令，则CPU体系结构是可虚拟化的</p></li><li><p>RISC的所有控制敏感和行为敏感指令都是特权指令，所以RISC的CPU是天然可虚拟化的</p></li></ul><h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><p>多级页表，虚拟内存</p><h4 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h4><ul><li>全设备模拟：一个设备的所有功能和总线结构都在软件中复制</li><li>半虚拟化：Xen使用的方法，分为前端后端，前端在DomainU中，后端在Domain0中，通过一块共享内存交互</li><li>直接IO虚拟化：虚拟机直接访问设备硬件获得近乎本地性能，CPU开销不高</li></ul><h4 id="多核处理器虚拟化"><a href="#多核处理器虚拟化" class="headerlink" title="多核处理器虚拟化"></a>多核处理器虚拟化</h4><p>困难</p><ul><li>编程者必须完全并行使用所有处理器核</li><li>软件明确的为处理器分配任务</li></ul><p>使用三级的Cache进行层次缓冲</p><h3 id="3-4-虚拟集群与资源管理"><a href="#3-4-虚拟集群与资源管理" class="headerlink" title="3.4 虚拟集群与资源管理"></a>3.4 虚拟集群与资源管理</h3><h4 id="物理集群与虚拟集群"><a href="#物理集群与虚拟集群" class="headerlink" title="物理集群与虚拟集群"></a>物理集群与虚拟集群</h4><p>虚拟集群：多个客户虚拟机，安装在由一个或多个物理集群构成的分布式服务器上，逻辑上跨越物理网络的虚拟网络互联，为虚拟集群提供虚拟机的过程可以动态运行</p><ul><li>虚拟集群节点可以是物理机器或者虚拟机器</li><li>主机操作系统管理物理机器资源，虚拟机运行其上，可以运行与主机相异的操作系统</li><li>虚拟机的目的是合并同一台物理服务器的多个功能</li><li>虚拟机可以在多个物理服务器上备份，提高分布式并行度，容错性，加快灾难恢复速度</li><li>节点数可以动态删减（与P2P类似）</li><li>物理节点失效会使运行在其上的虚拟机失效，但是虚拟机失效不会影响主机系统</li></ul><h4 id="快速-部署和有效调度"><a href="#快速-部署和有效调度" class="headerlink" title="快速 部署和有效调度"></a>快速 部署和有效调度</h4><h5 id="快速部署："><a href="#快速部署：" class="headerlink" title="快速部署："></a>快速部署：</h5><ul><li><p>集群内的物理节点尽快构建发布软件栈，</p></li><li><p>运行时环境可以从一个用户虚拟集群快速切换到另一个用户虚拟集群</p></li></ul><p>虚拟化另一个优点：负载均衡（通过负载指数和用户登录频率等指标完成）</p><h4 id="高性能虚拟存储"><a href="#高性能虚拟存储" class="headerlink" title="高性能虚拟存储"></a>高性能虚拟存储</h4><p>用于减少虚拟集群分布式文件中的复制块</p><h4 id="在线迁移虚拟机的步骤与性能影响"><a href="#在线迁移虚拟机的步骤与性能影响" class="headerlink" title="在线迁移虚拟机的步骤与性能影响"></a>在线迁移虚拟机的步骤与性能影响</h4><p>虚拟集群中的虚拟机客户系统与主机系统并存，当一个虚拟机失效时，其角色可被其他节点上虚拟机替代，只要两个虚拟机运行相同的客户端系统</p><p>一个物理节点故障转移至另一个主机的虚拟机上</p><h4 id="管理虚拟集群的四种方式"><a href="#管理虚拟集群的四种方式" class="headerlink" title="管理虚拟集群的四种方式"></a>管理虚拟集群的四种方式</h4><ul><li>基于客户的管理器 集群管理器在客户系统中，多个虚拟机形成一个虚拟集群</li><li>基于主机的集群管理器，监督客户系统并能在另一物理量机器上重启客户系统</li><li>在主机系统和客户系统中使用相同独立的集群管理器（基础设施复杂）</li><li>主机系统和客户系统中使用集成的集群：管理器能区分虚拟资源和物理资源</li></ul><h4 id="虚拟机迁移"><a href="#虚拟机迁移" class="headerlink" title="虚拟机迁移"></a>虚拟机迁移</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103152653011.png" alt="image-20210103152653011"></p><h4 id="内存、文件与网络资源迁移"><a href="#内存、文件与网络资源迁移" class="headerlink" title="内存、文件与网络资源迁移"></a>内存、文件与网络资源迁移</h4><p>内存迁移：将虚拟机的内存实例从一个物理节点迁到另一个物理节点</p><p>文件系统迁移：为每个虚拟机提供一个一致的位置无关的在所有物理主机上都能访问的文件系统</p><p>网络迁移：迁移时虚拟机应维持所有开放的网络连接，不依赖原始主机转发或者依赖移动性或重定向机制的支持</p><p>在线迁移主要使用预复制方法：先传输所有的内存页，然后迭代传输上次传输中被修改的内存页</p><h3 id="3-5-数据中心的自动化与虚拟化"><a href="#3-5-数据中心的自动化与虚拟化" class="headerlink" title="3.5 数据中心的自动化与虚拟化"></a>3.5 数据中心的自动化与虚拟化</h3><h4 id="数据中心服务器合并"><a href="#数据中心服务器合并" class="headerlink" title="数据中心服务器合并"></a>数据中心服务器合并</h4><p>减少服务器数目，改进硬件资源低利用效率</p><p>数据中心需要优化资源管理，这些服务器合并技术在整机服务器运行，难以使资源管理得到有效优化</p><ul><li>合并增强硬件利用效率</li><li>资源得到更灵活的配置调度</li><li>总体拥有成本降低</li><li>改进可用性和业务连续性</li></ul><h4 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h4><p>虚拟存储包括由VMM和客户操作系统管理的存储</p><p>分为虚拟机镜像和应用程序数据</p><p>最重要的是封装和隔离：一个虚拟机仅运行一个系统，系统中运行许多应用程序，系统虚拟化允许许多虚拟机同时运行在物理机器上并且虚拟机之间完全隔离。</p><h4 id="虚拟化数据中心的可信管理"><a href="#虚拟化数据中心的可信管理" class="headerlink" title="虚拟化数据中心的可信管理"></a>虚拟化数据中心的可信管理</h4><p>VMM是虚拟系统安全基础，虚拟机访问任何硬件都需要VMM的审查</p><h2 id="第四章：构建在虚拟化数据中心上的云平台体系结构"><a href="#第四章：构建在虚拟化数据中心上的云平台体系结构" class="headerlink" title="第四章：构建在虚拟化数据中心上的云平台体系结构"></a>第四章：构建在虚拟化数据中心上的云平台体系结构</h2><h3 id="4-1-云计算和服务模型"><a href="#4-1-云计算和服务模型" class="headerlink" title="4.1 云计算和服务模型"></a>4.1 云计算和服务模型</h3><ul><li>任意位置访问部署（便宜）</li><li>构建在大规模数据中心之上</li><li>致力于自动化的硬件、数据库、用户接口和应用程序环境吧他们结构化为虚拟资源，来驱动下一代的数据中心</li><li>渴望通过自动化资源配置来构建更好的数据中心</li></ul><p>云计算是一种高吞吐量的计算范式，通过大的数据中心或服务器群提供服务。使得用户可以随时随地通过狐狸啊设备访问共享资源</p><h4 id="公有云和私有云"><a href="#公有云和私有云" class="headerlink" title="公有云和私有云"></a>公有云和私有云</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103162023316.png" alt="image-20210103162023316"></p><h4 id="云设计目标"><a href="#云设计目标" class="headerlink" title="云设计目标"></a>云设计目标</h4><ul><li><p>将计算从桌面转向数据中心，计算中心</p></li><li><p>服务配置与云效益</p></li><li><p>性能可扩展</p></li><li><p>数据隐私保护</p></li><li><p>高质量云服务</p></li><li><p>新标准和接口</p></li><li><p>降低小型用户大型企业计算成本</p></li><li><p>减轻创业型公司经济负担</p></li></ul><h4 id="基础设施及服务（IaaS）"><a href="#基础设施及服务（IaaS）" class="headerlink" title="基础设施及服务（IaaS）"></a>基础设施及服务（IaaS）</h4><p>云计算将基础设施，平台和软件作为服务发布，是的用户能够即用即付，使用基于订阅的服务。</p><p>云上服务分为三种：IaaS,Paas(平台即服务),SaaS（软件即服务）</p><p>SaaS由用户使用特殊接口，在应用程序端，PaaS层，云平台进行计费服务，处理作业队列，启动监视服务。底层是IaaS服务，需要配置数据库，计算实例，文件系统和存储以满足用户需求。IaaS包括存储即服务，计算实例即服务和通信即服务</p><h4 id="平台即服务（PaaS）"><a href="#平台即服务（PaaS）" class="headerlink" title="平台即服务（PaaS）"></a>平台即服务（PaaS）</h4><p>平台云是一个由硬件和软件基础设施构成的集成的计算机系统，可以在这个虚拟化云平台使用提供商支持的一些编程语言和软件工具开发用户应用程序</p><p>用户不需要管理底层基础设施，世界不同的用户可以在统一的软件平台协同工作，鼓励第三方组织提供软件管理，集成和服务监视解决方案。</p><h4 id="软件即服务（SaaS）"><a href="#软件即服务（SaaS）" class="headerlink" title="软件即服务（SaaS）"></a>软件即服务（SaaS）</h4><p>软件即服务是指上千的云客户通过浏览器访问的应用程序软件</p><p>PaaS 提供的服务和工具用于构建应用程序和管理他们所部署的由IaaS提供的资源</p><p>SaaS模型将软件应用作为服务进行提供，对客户来讲，无需为服务器或软件预先投资，对提供商来讲，与传统的用户应用程序托管相比成本很低</p><p>为支持PaaS和IaaS，客户数据存储在云中，云或者是专门的提供商，或者公开托管</p><h3 id="4-2-数据中心设计与互联网络"><a href="#4-2-数据中心设计与互联网络" class="headerlink" title="4.2 数据中心设计与互联网络"></a>4.2 数据中心设计与互联网络</h3><p>数据中心是大量服务器通过巨大互联网构建而成</p><p>数据中心越大，运营成本越低</p><p>数据中心关键的核心设计师数据中心集群中所有服务器之间的互联网络，要求低延迟，高带宽，低成本，消息传递接口，通信支持和容错，必须满足服务器节点之间点对点和群对群通信模式</p><ul><li>应用程序的网络通信支持</li><li>网络可扩展性</li><li>容错与降级</li><li>以交换机为中心的数据中心设计</li></ul><h4 id="数据中心管理问题"><a href="#数据中心管理问题" class="headerlink" title="数据中心管理问题"></a>数据中心管理问题</h4><ul><li>使普通用户满意</li><li>可控信息流</li><li>多用户管理</li><li>适应数据库增长可扩展性</li><li>用户和提供商低成本</li><li>安全防范和数据保护</li><li>绿色信息技术</li></ul><h3 id="4-3-计算与存储云体系结构设计"><a href="#4-3-计算与存储云体系结构设计" class="headerlink" title="4.3 计算与存储云体系结构设计"></a>4.3 计算与存储云体系结构设计</h3><h4 id="通用云体系结构设计"><a href="#通用云体系结构设计" class="headerlink" title="通用云体系结构设计"></a>通用云体系结构设计</h4><p>云设计目标：可扩展性，虚拟化，有效性，可靠性</p><p>云管理器软件要同时支持物理机和虚拟机，共享资源的安全性和数据中心的共享访问为设计提出另一个挑战</p><h4 id="云的关键技术"><a href="#云的关键技术" class="headerlink" title="云的关键技术"></a>云的关键技术</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105513118.png" alt="image-20210104105513118"></p><h4 id="通用云体系结构"><a href="#通用云体系结构" class="headerlink" title="通用云体系结构"></a>通用云体系结构</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105602739.png" alt="image-20210104105602739"></p><h4 id="层次化云体系结构开发"><a href="#层次化云体系结构开发" class="headerlink" title="层次化云体系结构开发"></a>层次化云体系结构开发</h4><p>三层：基础设施层，平台层，应用程序层，<strong>使用云中分配的经虚拟化和标准化的硬件与软件资源实现</strong></p><p>首先部署基础设施层来支持IaaS服务。基础设施层是为支持PaaS服务构建云平台层的基础。平台层是为SaaS应用而实现应用层的基础。</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105813088.png" alt="image-20210104105813088"></p><h4 id="虚拟化支持和灾难恢复"><a href="#虚拟化支持和灾难恢复" class="headerlink" title="虚拟化支持和灾难恢复"></a>虚拟化支持和灾难恢复</h4><p>云计算的虚拟化意味着资源和基础设施都是虚拟化的。</p><p>虚拟化软件用来虚拟化硬件。系统虚拟化软件是一种特殊类型的软件，它模拟硬件的执行并在其上运行未经修改的操作系统。云计算系统使用虚拟化软件作为遗产软件（如旧操作系统或罕见应用）的运行环境。虚拟化软件也被用作开发新的云应用的平台</p><p>  系统虚拟化软件可被看做是一种硬件模拟机制，可以在系统虚拟化软件上不经修改地直接运行之前运行在裸机上的操作系统。</p><h4 id="体系结构设计挑战"><a href="#体系结构设计挑战" class="headerlink" title="体系结构设计挑战"></a>体系结构设计挑战</h4><p>挑战1：服务可用性和数据锁定问题</p><p>挑战2：数据隐私和安全性考虑</p><p>挑战3：不可预测的性能和瓶颈</p><p>挑战4：分布式存储和广泛存在的软件故障</p><p>挑战5：云可扩展性、互操作性和标准化</p><p>挑战6：软件许可和信誉共享</p><h2 id="第五章-面向服务的分布式体系结构"><a href="#第五章-面向服务的分布式体系结构" class="headerlink" title="第五章 面向服务的分布式体系结构"></a>第五章 面向服务的分布式体系结构</h2><h4 id="服务和面向服务体系结构"><a href="#服务和面向服务体系结构" class="headerlink" title="服务和面向服务体系结构"></a>服务和面向服务体系结构</h4><p>SOA是一种分布式系统体系结构，旨在如何设计一套使用的服务的软件系统，</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104113827935.png" alt="image-20210104113827935"></p><p>SOA特性：</p><ul><li>逻辑视图：SOA是实际程序，数据库，商业流程的逻辑视图</li><li>基于消息：人不必知道实现服务代理如何构造的</li><li>基于描述：服务由元数据描述，只包括哪些公开可访问并对服务应用很重要的细节<ul><li>粒度：服务倾向使用少量的操作，使用大而复杂的信息</li><li>网络方向：服务往往是在网络上沿着使用的方向，尽管不是必须</li><li>平台中立性：标准化格式通过接口发送，XML</li></ul></li></ul><p>web服务时SOA最常见实例之一</p><h4 id="REST和系统的系统"><a href="#REST和系统的系统" class="headerlink" title="REST和系统的系统"></a>REST和系统的系统</h4><p>REST是应用于分布式系统的软件体系结构风格，基于以下四个基本原则</p><ul><li>通过URI的资源标识：标识与客户端进行交互的目标</li><li>统一的受限接口：通过客户端、服务器可缓存的协议标准进行交互</li><li>自我描述的信息：消息包含足够的信息来描述如何处理</li><li>无状态的交互：不依赖会话状态</li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104132219474.png" alt="image-20210104132219474"></p><h4 id="WEB的核心技术"><a href="#WEB的核心技术" class="headerlink" title="WEB的核心技术"></a>WEB的核心技术</h4><p>简单对象访问协议（SOAP）提供标准封装结构用在不同协议中传输xml</p><p>WEB服务描述语言（WSDL）描述了接口，标准化了操作的输入和输出参数的表示以及服务协议绑定，</p><p>通用描述发现和集成（UDDI）提供通过搜索名称、标识符、类别、或Web服务实现的规范来广告和发现Web服务的全局注册表</p><h4 id="企业多层体系结构"><a href="#企业多层体系结构" class="headerlink" title="企业多层体系结构"></a>企业多层体系结构</h4><p>企业应用程序用多重体系结构封装各种功能。</p><p>多层体系机构基于C/S，最简单的是两层，也就是C/S，传统的服务器集群在维修升级部署时需要服务器下线，并且胖客户端环境下新应用增强部署消耗时间，降低可用性</p><p>三层系统包含：</p><ul><li>表述层：向外部实体描述信息，允许通过提交操作和获得响应和系统交互</li><li>商业、应用逻辑层或中间件：可控制用户认证，访问资源，完成一些客户端查询处理</li><li>资源管理层/数据层：处理实现信息系统的不同数据源</li></ul><h4 id="网络服务和OGSA"><a href="#网络服务和OGSA" class="headerlink" title="网络服务和OGSA"></a>网络服务和OGSA</h4><p>开放网络服务体系结构（OGSA）旨在为基于网格的应用定义一个通用的开放的体系结构，意图在于：</p><ul><li><p>便于在分布式的异构环境上使用和管理资源。</p></li><li><p>提供无缝的服务质量。</p></li><li><p>为了提供不同资源之间的互操作性，定义开放的发布接口。</p></li><li><p>采用工业标准的集成技术。</p></li><li><p>开发实现互操作性的标准。282283</p></li><li><p>在分布式的异构环境中集成、虚拟化和管理各种服务与资源。</p></li><li><p>提供松耦合的可交互服务，并且满足工业可接受的Web服务标准。</p></li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104143018926.png" alt="image-20210104143018926"></p><h3 id="5-2-面向消息的中间件"><a href="#5-2-面向消息的中间件" class="headerlink" title="5.2 面向消息的中间件"></a>5.2 面向消息的中间件</h3><h4 id="企业总线"><a href="#企业总线" class="headerlink" title="企业总线"></a>企业总线</h4><p>企业服务总线（ESB）指总线支持许多组件，采用不同风格能够方便的集成到一起，在源和目的之间开一个通道，把带有足够信息的消息注入总线</p><h4 id="发布订阅模型和通知"><a href="#发布订阅模型和通知" class="headerlink" title="发布订阅模型和通知"></a>发布订阅模型和通知</h4><p>“发布-订阅”概念对于消息总线，描述源和目的连接起来的特殊模型，在发布者上贴上标签，与词汇表里主题名词管理，消息的接受者会接收到他们希望接收的相关消息，或者可以给予内容发布系统（SQL）查询</p><p>使用基于主题或内容的消息选择称为消息过滤</p><h3 id="5-3-门户和科学网关"><a href="#5-3-门户和科学网关" class="headerlink" title="5.3 门户和科学网关"></a>5.3 门户和科学网关</h3><p>网关是更复杂的实体，科学网关也称门户</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104150739351.png" alt="image-20210104150739351"></p><h3 id="5-4-发现、注册表、元数据和数据库"><a href="#5-4-发现、注册表、元数据和数据库" class="headerlink" title="5.4 发现、注册表、元数据和数据库"></a>5.4 发现、注册表、元数据和数据库</h3><p>注册表是复杂的命名和目录服务：为了存储元数据，有一套数据结构规范，为了存储主，包含和归类服务元数据，要一套操作来存储，删除和查找数据。</p><p>注册表包含三类信息：</p><p>白页：实体名字和一般联系信息</p><p>黄页：条目提供服务类型和位置分类信息</p><p>绿页：如何调用所提供服务的详细信息</p><h4 id="UDDI和服务注册表"><a href="#UDDI和服务注册表" class="headerlink" title="UDDI和服务注册表"></a>UDDI和服务注册表</h4><p>UDDI（统一描述发现和集成）创建平台无关的开放框架定义一种描述发布WEb服务信息的方法。提供名字和目录服务爱通过名字或特定属性查找服务描述</p><p>注册表有两类</p><ul><li>公共注册表：逻辑的集中式分布服务，彼此在一个约定的基础上传数据。</li><li>私有注册表：单个组织内部访问，或特定目的的商业伙伴共享</li></ul><h4 id="数据库和订阅-发布"><a href="#数据库和订阅-发布" class="headerlink" title="数据库和订阅-发布"></a>数据库和订阅-发布</h4><p>订阅-发布是分布式应用实现异步交互的设计模式</p><p>防止轮询查询数据库，时间订阅者注册某个事件类型，发布者产生这样的事件时，订阅者从发布者得到通知，订阅者与发布者是多对多的关系。为数据库的静态本质增加了动态性。</p><p>分为基于主题的和基于内容的。</p><p>数据库提供基于消息传递的体系结构，可以使用许多特性，例如可靠的存储，事物和触发器。</p><h4 id="元数据目录"><a href="#元数据目录" class="headerlink" title="元数据目录"></a>元数据目录</h4><p>元数据是关于数据的信息，识别，定位和解释数据，为数据增加上下文。</p><p>网格上的关键元数据包括数据源的名称和位置、在这些数据源中数据的结构，数据项名称和描述以及用户信息或者可用服务的基本列表和简单查找。</p><h4 id="语义Web和网络"><a href="#语义Web和网络" class="headerlink" title="语义Web和网络"></a>语义Web和网络</h4><p>语义Web是关于自动化发现和集成的：给数据增加机器可处理语义，让机器理解并代表终端处理。从而基于为Web页面附加丰富元数据使web搜索链接更智能。</p><p>语义Web旨在提供一个环境，在里面软件代理能够动态的发现，询问和互操作资源并代替人执行复杂任务。</p><h4 id="作业执行环境和监控"><a href="#作业执行环境和监控" class="headerlink" title="作业执行环境和监控"></a>作业执行环境和监控</h4><p>分布式作业执行环境包括：作业执行引擎（处理作业调度，资源分配与容错）和分布式数据管理系统（为作业访问分布式数据提供抽象）。</p><h3 id="5-5-面向服务的体系结构工作流"><a href="#5-5-面向服务的体系结构工作流" class="headerlink" title="5.5 面向服务的体系结构工作流"></a>5.5 面向服务的体系结构工作流</h3><h4 id="工作流基本概念"><a href="#工作流基本概念" class="headerlink" title="工作流基本概念"></a>工作流基本概念</h4><p>对服务之间交互进行编程的方法。意味着分布式两层编程模型，基本服务采用传统语言编程，描述了服务之间彼此交互的粗粒度编程。他们之间的交互用工作流描述。</p><h4 id="工作流标准"><a href="#工作流标准" class="headerlink" title="工作流标准"></a>工作流标准</h4><h4 id="工作流体系和规范"><a href="#工作流体系和规范" class="headerlink" title="工作流体系和规范"></a>工作流体系和规范</h4><p>两个关键组件：工作流规范和工作流运行引擎，通过接口互相连接</p><h4 id="工作流运行引擎"><a href="#工作流运行引擎" class="headerlink" title="工作流运行引擎"></a>工作流运行引擎</h4><p>有向无环图，</p><p>使用传统语言和工具集的脚本是构建工作流的主要技术</p><p>最复杂的工作流支持层次化规范，即工作流节点可以是服务或服务集。</p><h2 id="第六章-云编程和软件环境"><a href="#第六章-云编程和软件环境" class="headerlink" title="第六章 云编程和软件环境"></a>第六章 云编程和软件环境</h2><h3 id="6-1-云和网络平台的特性"><a href="#6-1-云和网络平台的特性" class="headerlink" title="6.1 云和网络平台的特性"></a>6.1 云和网络平台的特性</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165649219.png" alt="image-20210104165649219"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165659938.png" alt="image-20210104165659938"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165707706.png" alt="image-20210104165707706"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165716339.png" alt="image-20210104165716339"></p><h4 id="网络和云的公共传统特征"><a href="#网络和云的公共传统特征" class="headerlink" title="网络和云的公共传统特征"></a>网络和云的公共传统特征</h4><p>工作流：在真实应用中工作流按需连接多个云和非云服务</p><p>数据传输：商业云中的数据传输成本</p><p>云编程环境的安全隐私和可用性需求：</p><ul><li>使用虚拟集群化实现最小开销成本达到资源动态供应</li><li>使用稳定和持续数据传输，带有用于信息检索的快速查询</li><li>特殊API来验证用户</li><li>使用HTTPS或者SSL等安全协议访问云资源</li><li>细粒度保护数据完整性，阻止入侵者或黑客</li><li>保护共享数据集</li><li>实时迁移和灾难恢复</li><li>使用信用系统保护数据中心</li></ul><h4 id="数据特性和数据库"><a href="#数据特性和数据库" class="headerlink" title="数据特性和数据库"></a>数据特性和数据库</h4><p>程序库：允许方便部署配置镜像（即支持IaaS）</p><p>Blob和驱动：类似共享文件系统</p><p>DPFS：这个文件系统是为执行数据密集型应用设计的</p><p>SQL和关系型数据库</p><p>表格和NOSQL非关系型数据库</p><p>队列服务：扩展组件间通信</p><h3 id="6-2-并行和分布式编程范式"><a href="#6-2-并行和分布式编程范式" class="headerlink" title="6.2 并行和分布式编程范式"></a>6.2 并行和分布式编程范式</h3><p>是运行在多个计算引擎或一个分布式计算系统上的并行程序，包含分布式系统和并行计算。分布式系统是一系列网络连接的计算引擎，完成一个共同目标：运行一个作业或者应用。并行计算时同时用多个引擎运行作业或者应用。</p><h4 id="并行计算和编程范式"><a href="#并行计算和编程范式" class="headerlink" title="并行计算和编程范式"></a>并行计算和编程范式</h4><p>多个网络节点或工作机组成用并行或者分布式方式来运行并行的程序，包括以下方面</p><ul><li><p>分区 分为识别分区和计算分区</p><ul><li>计算分区：将指定任务分割为小任务，分区过程很大程度依靠正确识别可以并发执行的作业或程序的每一小部分</li><li>数据分区：将输入或中间数据分割成更小部分。类似地，一旦识别出输入数据的并行性，它也可以被分割成多个部分，能在不同的工作机上运行。数据块可由程序的不同部分或者同一程序的副本来处理。</li></ul></li><li><p>映射：把更小的程序部分或更小的数据分块分给底层的资源，过程目的在于合理分配这些部分或者分块，使它们能同时在不同的工作机上运行。由系统中的资源分配器处理</p></li><li><p>同步：不同工作机可以执行不同任务，工作机之间同步和协同很有必要。可以避免竞争条件，不同工作机之间数据依赖也能恰当的管理。然而，一个工作机需要其他工作机处理的数据时会产生数据依赖</p></li><li><p>通信：中间数据转备好在工作机之间传送时通信就开始了</p></li><li><p>调度：数据块多于可用工作机数量时，调度程序选择一个任务序列分配给工作机。只基于一套称为调度策略的规则，对于多作业或多程序，调度器会选择运行在分布式系统上的一个任务或程序序列。</p></li></ul><h4 id="编程范式动机"><a href="#编程范式动机" class="headerlink" title="编程范式动机"></a>编程范式动机</h4><ul><li><p>提供并行或分布式范式或模型来抽象用户数据流的多个部分</p></li><li><p>编写并行程序的简单性是度量并行和分布式编程范式的重要标准。</p><ul><li>提高程序员效率</li><li>减少程序进入市场时间</li><li>有效利用系统资源</li><li>提高吞吐量</li><li>支持更高层抽象</li></ul></li><li><p>MapReduce、Hadoop和Dryad是最近提出的三种并行和分布式编程模型，为信息检索而开发。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章-分布式系统模型和关键技术&quot;&gt;&lt;a href=&quot;#第一章-分布式系统模型和关键技术&quot; class=&quot;headerlink&quot; title=&quot;第一章 分布式系统模型和关键技术&quot;&gt;&lt;/a&gt;第一章 分布式系统模型和关键技术&lt;/h2&gt;&lt;h3 id=&quot;1-1互联网上的可
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP-summarize</title>
    <link href="http://yokeso.top/2020/12/01/CSAPP-summarize/"/>
    <id>http://yokeso.top/2020/12/01/CSAPP-summarize/</id>
    <published>2020-12-01T08:45:41.000Z</published>
    <updated>2020-12-06T13:50:05.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP重要知识点总结"><a href="#CSAPP重要知识点总结" class="headerlink" title="CSAPP重要知识点总结"></a>CSAPP重要知识点总结</h2><h4 id="第一章-—-计算机系统漫游"><a href="#第一章-—-计算机系统漫游" class="headerlink" title="第一章 — 计算机系统漫游"></a>第一章 — 计算机系统漫游</h4><h5 id="1-Hello-world的生命周期"><a href="#1-Hello-world的生命周期" class="headerlink" title="1.Hello world的生命周期"></a>1.Hello world的生命周期</h5><h6 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h6><ul><li>shell程序输入<code>./hello</code>,shell将其逐一读到寄存器里并放入内存。</li><li>shell利用fork()函数创建进程</li></ul><h6 id="2-程序加载运行"><a href="#2-程序加载运行" class="headerlink" title="2.程序加载运行"></a>2.程序加载运行</h6><ul><li>调用execve()函数映射进程结构</li><li>对程序所需要的共享库进行动态连接</li><li>利用mmap将文件或其他对向映射到内存</li></ul><h6 id="3-执行指令"><a href="#3-执行指令" class="headerlink" title="3.执行指令"></a>3.执行指令</h6><ul><li>执行第一条代码，产生缺页中断<ul><li>处理器将VA给MMU，</li><li>MMU产生TLBA传给页表，</li><li>从页表中加载PTE。</li><li>PTE有效位为0，产生缺页异常。</li><li>缺页处理程序选择物理内存的牺牲页，如果页被修改则换出到磁盘。</li><li>新页调入内存。</li><li>更新PTE,返回原进程重新执行缺页指令</li></ul></li></ul><p><img src="/2020/12/01/CSAPP-summarize/CSAPP-summarize%5Cimage-20201202203601317.png" alt="image-20201202203601317"></p><h6 id="4-访问数据"><a href="#4-访问数据" class="headerlink" title="4.访问数据"></a>4.访问数据</h6><ul><li>访问数据时同样会产生缺页中断。</li></ul><h6 id="5-显示输出"><a href="#5-显示输出" class="headerlink" title="5.显示输出"></a>5.显示输出</h6><ul><li>调用c标准函数printf()，调用运行时会产生堆栈段缺页，调用write()函数进行屏幕显示。</li></ul><h6 id="6-进程终止"><a href="#6-进程终止" class="headerlink" title="6.进程终止"></a>6.进程终止</h6><ul><li>显示完成后进程终止，被父进程回收</li></ul><h5 id="2-一些小知识点"><a href="#2-一些小知识点" class="headerlink" title="2.一些小知识点"></a>2.一些小知识点</h5><p>1.操作系统使用抽象的概念</p><ul><li>防止硬件被失控程序滥用</li><li>提供简单的一致的机制管理复杂不同的低级硬件设备</li></ul><p><img src="/2020/12/01/CSAPP-summarize/CSAPP-summarize%5Cimage-20201202195155158.png" alt="image-20201202195155158"></p><p>2.编译系统包括（预处理器 编译器 汇编器 链接器）</p><h4 id="第二章-—-信息的表示和处理"><a href="#第二章-—-信息的表示和处理" class="headerlink" title="第二章 — 信息的表示和处理"></a>第二章 — 信息的表示和处理</h4><h5 id="1-算数溢出产生的漏洞"><a href="#1-算数溢出产生的漏洞" class="headerlink" title="1.算数溢出产生的漏洞"></a>1.算数溢出产生的漏洞</h5><h5 id="2-浮点数IEEE表示"><a href="#2-浮点数IEEE表示" class="headerlink" title="2.浮点数IEEE表示"></a>2.浮点数IEEE表示</h5><p>规格化数与非规格化数</p><h5 id="3-左移右移"><a href="#3-左移右移" class="headerlink" title="3.左移右移"></a>3.左移右移</h5><h5 id="4-带符号数与无符号数的转换"><a href="#4-带符号数与无符号数的转换" class="headerlink" title="4.带符号数与无符号数的转换"></a>4.带符号数与无符号数的转换</h5><p>sizeof()函数输出的数值是一个无符号数。如果直接拿去进行循环对比的话可能会产生问题</p><h4 id="第三章-—-程序的机器级表示"><a href="#第三章-—-程序的机器级表示" class="headerlink" title="第三章 — 程序的机器级表示"></a>第三章 — 程序的机器级表示</h4><h4 id="第四章-—-处理器体系结构"><a href="#第四章-—-处理器体系结构" class="headerlink" title="第四章 — 处理器体系结构"></a>第四章 — 处理器体系结构</h4><p>Y86-64CPU顺序结构设计与实现中分为6个阶段<code>P264</code></p><p>取指 译码 执行 访存 写回 更新PC</p><h4 id="第五章-—-优化程序性能"><a href="#第五章-—-优化程序性能" class="headerlink" title="第五章 — 优化程序性能"></a>第五章 — 优化程序性能</h4><h4 id="第六章-—-存储器层次结构"><a href="#第六章-—-存储器层次结构" class="headerlink" title="第六章 — 存储器层次结构"></a>第六章 — 存储器层次结构</h4><h4 id="第七章-—-链接"><a href="#第七章-—-链接" class="headerlink" title="第七章 — 链接"></a>第七章 — 链接</h4><h5 id="1-ELF头（可重定位目标文件格式）"><a href="#1-ELF头（可重定位目标文件格式）" class="headerlink" title="1.ELF头（可重定位目标文件格式）"></a>1.ELF头（可重定位目标文件格式）</h5><p><img src="/2020/12/01/CSAPP-summarize/CSAPP-summarize%5Cimage-20201202223638552.png" alt="image-20201202223638552"></p><p>ELF头以16字节序列开始，描述了系统字大小和字节顺序，帮助连接器语法分析和解释目标文件信息（ELF头大小，目标文件类型、机器类型、节头部表的文件偏移、节头部表中条目的大小和数量）不同节的大小是由节头部hi奥描述的。目标文件中每一个节都有固定大小的条目</p><p>关于几个节的解释</p><ul><li>.text： 已编译程序的机器代码</li><li>.rodata：只读数据，printf语句中的格式串和switch的跳转表</li><li>.data：已初始化的全局和静态C变量。局部C变量运行时保存在栈中，既不出现在.data中，也不出现在.bss中</li><li>.bss：未初始化的全局和静态C变量。以及所有被初始化为0的全局或静态变量。<strong>在目标文件中这个节不占用实际的空间</strong>。仅仅是一个占位符。运行时内存分配变量，初始值为0</li><li>.symtab：一个符号表。存放程序中定义和引用的全局变量的信息（不包含全局变量的条目、与编译器中的符号表不同）</li><li>.rel.text：text节中位置的表，目标文件与其他文件组合时需要修改（调用外部函数或者引用全局变量的指令）。调用本地函数时则不需要修改。<strong>通常省略</strong></li><li>.rel.data：被模块引用或定义的所有全局变量的重定位信息。如果一个初始化的全局变量的初始值时一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li>.debug：调试符号表。-g选项才能得到这张表</li><li>.line：C中行号和.text节中机器指令的映射。-g编译时才能得到</li><li>.strtab：一个字符串表，包括.symtab和.debug中的符号表以及节头部中的节名字</li></ul><h5 id="2-常考的几点"><a href="#2-常考的几点" class="headerlink" title="2.常考的几点"></a>2.常考的几点</h5><ul><li><p><strong>.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理</strong></p></li><li><p><strong>C static属性的本地变量不在栈中管理，而是在.data或.bss中为每个定义分配空间，并在符号表中创建一个由唯一名字（eg: x.1、x.2）的本地链接器符号表</strong></p></li><li><p>可重定位目标文件中的伪节</p><ul><li>ABS：不该被重定义的符号</li><li>UNDEF：未定义的符号，本目标模块引用但是在其他地方定义的符号</li><li>COMMON：未分配位置的未初始化数据目标</li></ul></li><li><p>COMMON与.bss区别</p><ul><li>COMMON 未初始化全局变量</li><li>.bss 未初始化静态变量，以及初始化未0的全局或静态变量</li></ul></li></ul><h5 id="3-强符号与弱符号（连接器如何解析多重定义的全局符号）"><a href="#3-强符号与弱符号（连接器如何解析多重定义的全局符号）" class="headerlink" title="3.强符号与弱符号（连接器如何解析多重定义的全局符号）"></a>3.强符号与弱符号（连接器如何解析多重定义的全局符号）</h5><p>在编译时，编译器向汇编器输出每个全局符号（强或者是弱），而汇编器把这个信息隐含的编码在<strong>可重定位目标文件的符号表里</strong>。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号</p><p>Linux连接器使用下面规则来定义强弱符号：</p><ul><li>不允许有多个同名的强符号</li><li>如果有一个强符号和多个弱符号同名，那么选择强符号</li><li>如果有多个弱符号同名，那么从这些弱符号中任选一个</li></ul><h4 id="第八章-—-异常控制流"><a href="#第八章-—-异常控制流" class="headerlink" title="第八章 — 异常控制流"></a>第八章 — 异常控制流</h4><h5 id="信号："><a href="#信号：" class="headerlink" title="信号："></a>信号：</h5><p>信号是通知进程系统中发生某种类型事件的一条小消息</p><h6 id="需要记的几个信号"><a href="#需要记的几个信号" class="headerlink" title="需要记的几个信号"></a>需要记的几个信号</h6><ul><li>（<strong>但除以0可能发生的情况有 显示除法溢出退出 不提示任何错误 用户程序决定处理办法</strong>）</li></ul><table><thead><tr><th>信号量</th><th>默认行为</th><th align="left">事件</th><th>何时考核</th></tr></thead><tbody><tr><td>SIGFPE</td><td>终止并转储内存</td><td align="left">进程试图除以0                                                                                                    但除以0可能发生的情况有 显示除法溢出退出 不提示任何错误 用户程序决定处理办法</td><td>2017A</td></tr><tr><td>SIGCHLD</td><td>忽略</td><td align="left">子进程终止或者停止时发送给父进程</td><td>2017B，2018B</td></tr><tr><td>SIGCONT</td><td>忽略</td><td align="left">继续进程如果该进程停止（预定义默认行为）</td><td>2017A</td></tr><tr><td>SIGINT</td><td>终止</td><td align="left">来自键盘的中断（ctrl+C）</td><td></td></tr></tbody></table><h4 id="第九章-—-虚拟内存"><a href="#第九章-—-虚拟内存" class="headerlink" title="第九章 — 虚拟内存"></a>第九章 — 虚拟内存</h4><p>CPU生成虚拟地址(VA)访问主存，虚拟地址被送到内存之前先转化成合适的物理地址。——地址翻译</p><p>虚拟页面的集合分为三个不相交的子集</p><ul><li>未分配</li><li>缓存的</li><li>未缓存的</li></ul><p><strong>页表条目的大小是n，也就是地址位数。</strong></p><h5 id="1-地址翻译过程："><a href="#1-地址翻译过程：" class="headerlink" title="1.地址翻译过程："></a>1.地址翻译过程：</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205163159359.png" alt="image-20201205163159359"></p><ul><li>第一步：处理器生成VA并发送到MMU</li><li>第二步：MMU生成PTE地址并从高速缓存/主存请求它</li><li>第三步：CACHE/主存向MMU返回PTE</li><li>第4步:PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第5步:缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第6步:缺页处理程序页面调入新的页面，并更新内存中的PTE。</li></ul><h5 id="2-地址翻译带CACHE与内存的过程"><a href="#2-地址翻译带CACHE与内存的过程" class="headerlink" title="2.地址翻译带CACHE与内存的过程"></a>2.地址翻译带CACHE与内存的过程</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205170317747.png" alt="image-20201205170317747"></p><h5 id="3-地址翻译中的地址结构变换"><a href="#3-地址翻译中的地址结构变换" class="headerlink" title="3.地址翻译中的地址结构变换"></a>3.地址翻译中的地址结构变换</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205170418497.png" alt="image-20201205170418497"></p><p>这里默认 <strong>虚拟地址空间48位，物理地址空间52位，CACHE 块大小为64字节，L1、L2 8路组相联。L3 16路组相联。页大小为4KB</strong></p><p><img src="/2020/12/01/CSAPP-summarize/image-20201205172024421.png" alt="image-20201205172024421"></p><p>其中各种地址变化如下</p><p>CPU  产生<code>VA</code> ，形式为 </p><table><thead><tr><th align="center">VPN(虚拟页号)</th><th align="center">VPO（虚拟页偏移）</th></tr></thead><tbody><tr><td align="center">36位（页表号）</td><td align="center">12位（块大小$2^{12}$）</td></tr></tbody></table><p><code>VA</code>发送给MMU，MMU生成<code>PTE</code>发送给块表 产生的块表地址<code>LTBA</code>  形式为</p><table><thead><tr><th align="center">LTBT（LTB标记）</th><th align="center">LTBI（LTB索引）</th></tr></thead><tbody><tr><td align="center">32位（VPN的前32位）</td><td align="center">4位（组数量$2^{4}$）</td></tr></tbody></table><p>中间的不命中过程省略，主要看命中过程。<code>LTBA</code> 命中后返回一个 <code>PPO</code>，MMU将<code>VPO</code>与<code>PPO</code>组合形成<code>PA</code>形式为：</p><table><thead><tr><th align="center">PPN（物理页号）</th><th align="center">PPO（物理页偏移）= VPO</th></tr></thead><tbody><tr><td align="center">40位</td><td align="center">12位</td></tr></tbody></table><p>MMU将<code>PA</code>传送给CACHE，变化为：</p><table><thead><tr><th align="center">CT</th><th align="center">CI</th><th align="center">CO</th></tr></thead><tbody><tr><td align="center">40</td><td align="center">6（$2^6$组）</td><td align="center">6</td></tr></tbody></table><h5 id="4-分配器"><a href="#4-分配器" class="headerlink" title="4.分配器"></a>4.分配器</h5><h6 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206212526290.png" alt="image-20201206212526290"></p><p>块大小为8的倍数，并且头部占据4个字节</p><p>例如 malloc(13) = 4+13=17 -&gt; 24 头部是 0001 1001 也就是0x19（后三位一定是0因为盘块大小是8的整数）</p><p><strong>当分配器合并的时候会在尾部设置一个和头部一样的脚部</strong></p><h6 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206213231762.png" alt="image-20201206213231762"></p><p><strong>简单分离存储：</strong>链表包含大小相同的块</p><p><strong>分离适配：</strong>块用链表连接</p><p><strong>伙伴系统：</strong>每个类大小都是2的幂</p><h6 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206215004182.png" alt="image-20201206215004182"></p><h4 id="第十章-—-系统级IO"><a href="#第十章-—-系统级IO" class="headerlink" title="第十章 — 系统级IO"></a>第十章 — 系统级IO</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSAPP重要知识点总结&quot;&gt;&lt;a href=&quot;#CSAPP重要知识点总结&quot; class=&quot;headerlink&quot; title=&quot;CSAPP重要知识点总结&quot;&gt;&lt;/a&gt;CSAPP重要知识点总结&lt;/h2&gt;&lt;h4 id=&quot;第一章-—-计算机系统漫游&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ComNet2</title>
    <link href="http://yokeso.top/2020/10/05/ComNet2/"/>
    <id>http://yokeso.top/2020/10/05/ComNet2/</id>
    <published>2020-10-05T12:34:36.000Z</published>
    <updated>2020-10-10T12:18:15.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自顶向下计算机网络-2-应用层"><a href="#自顶向下计算机网络-2-应用层" class="headerlink" title="自顶向下计算机网络 2    应用层"></a>自顶向下计算机网络 2    应用层</h2><h3 id="客户-服务器应用模型与P2P应用模型"><a href="#客户-服务器应用模型与P2P应用模型" class="headerlink" title="客户/服务器应用模型与P2P应用模型"></a>客户/服务器应用模型与P2P应用模型</h3><h4 id="客户-服务器应用模型"><a href="#客户-服务器应用模型" class="headerlink" title="客户/服务器应用模型"></a>客户/服务器应用模型</h4><p>一个总是打开的主机被称为服务器，它要服务于许多来自于其他称为客户机的主机请求，其工作流程如下：</p><p>1）服务器处于接收请求的状态</p><p>2）客户机发出服务请求并等待接收结果</p><p>3）服务器接收到请求后分析请求，进行必要的处理，得到结果并发送给客户机</p><p>客户机必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。而服务器要运行专门用来提供某种服务的程序，可以同时处理多个远程或者本地客户的要求。系统启动后自动调用并执行。因此服务器程序不需要知道客户机的地址。</p><p>客户/服务器最主要的特征是：客户是服务的请求方，服务器是服务的提供方</p><p>其他主要特点还有：</p><p>1）网络中各个计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的。使它们不能进行随意的增添删除数据或其他受限的网络活动。整个网络的管理工作由少部分服务器担当，因此整个网络的管理十分方便。</p><p>2）客户机之间不会直接通信</p><p>3）可扩展性不佳。收服务器硬件和网络带宽的限制。服务器支持的客户机数量有限。</p><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p>P2P模型的主要思想是在真个网络中传输的内容不再被保存在中心服务器上。每个节点都同时具有上传和下载的功能。其权力和义务是大体对等的。在P2P模型中，计算机没有固定的客户机与服务器的分别，，任意一对计算机都可以互相通信，每一台电脑既可以作为客户机访问其他节点的资源，也作为服务器提供资源给其他节点访问。</p><p>与客户机/服务器模型相比，P2P模型的优点主要体现如下：<br>1）减轻服务器的计算压力，消除了对于服务器的完全依赖。可以将任务分配到各个节点上。提高了系统效率和资源的利用率；</p><p>2）多个客户机之间直接进行文档共享。</p><p>3）可拓展性好，传统服务器有响应和带宽的限制，因此只能接收一定节点的请求。</p><p>4）网络健壮性强。单个节点的失效不会影响其他节点。</p><p>P2P的缺点也很明显。在获取服务的同时，还要给其他节点提供服务。这样会占据很多内存，影响整机速度。经常进行p2p下载还会对硬盘造成较大损伤。</p><h4 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h4><p>Napster文件传输使用P2P结构,文件的搜索采用C/S模式—集中式</p><hr><h3 id="网络应用通信原理"><a href="#网络应用通信原理" class="headerlink" title="网络应用通信原理"></a>网络应用通信原理</h3><p>进程：主机上运行的程序</p><p>同一主机之间运行的进程如何通信？</p><ul><li>进程间的通信机制</li><li>操作系统提供</li></ul><p>不同主机之间的进程如何通信？</p><ul><li>信息交换</li></ul><p>进程间利用Socket接收/发送消息。</p><ul><li><p>发送方将消息送到门外邮箱</p></li><li><p>发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外</p></li><li><p>接收方从门外获取消息</p></li></ul><p><img src="/2020/10/05/ComNet2/Socket.jpg" alt></p><p>为了在不同主机之间通信，每个进程必须要拥有<font color="red">标识符</font></p><p>如何寻址主机——IP地址</p><p>但是在有了主机IP地址后，由于同一主机上可能有多个进程需要通信，所以要在每个需要通信的进程上分配一个端口号。</p><p>进程的标识符：<font color="red">IP地址+端口号</font></p><p>应用层协议：网络应用应该遵循应用层协议。</p><ul><li><p>分类</p><ul><li>公开协议：RFC协议-&gt;允许互操作：<strong>HTTP SMTP</strong></li><li>私有协议：多数P2P文件共享应用。</li></ul></li><li><p>内容</p><ul><li>消息的类型（type） <ul><li>请求消息</li><li>响应消息</li></ul></li><li>消息的语法（syntax）/格式</li><li>字段的语义（semantics）</li><li>规则（rules）  </li></ul></li></ul><hr><h3 id="DNS系统（层次域名空间，域名服务器，域名解析过程）"><a href="#DNS系统（层次域名空间，域名服务器，域名解析过程）" class="headerlink" title="DNS系统（层次域名空间，域名服务器，域名解析过程）"></a>DNS系统（层次域名空间，域名服务器，域名解析过程）</h3><p>域名系统（Domain Name System，DNS）是因特网使用的域名系统。用来便于把人们记忆的具有特定含义的主机名转换为便于机器处理的IP地址，相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的主机。<strong>DSN系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口</strong>。是一个多层命名服务器构成的分布式数据库。</p><p>应用层协议：完成名字的解析</p><ul><li>Internet核心功能，用应用层协议实现。</li><li>网络边界复杂</li></ul><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><p>因特网采用层次树状结构的命名方法，采用这种命名方法，任何一个具有连接到因特网的主机或路由器都有一个唯一的层次结构名称，即域名。域是名字空间中一个可被管理的划分。域可以分为子域，子域还可以继续划分为子域的子域。这样就形成了顶级域，二级域，三级域等。每个域名都由标号序列组成，个标号之间都用<code>.</code>间隔开。</p><p>需要注意以下几点：</p><ul><li>标号中的英文不区分大小写</li><li>标号中除连词符之外不能用其他的标点符号。</li><li>每个标号不超过63个字符多标号组成的完整域名不能超过255字符。</li><li>级别最低的域名写在最左边，级别最高的域名写在最右边。</li></ul><p>DNS服务</p><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：Web服务器</li></ul><p>DNS服务器不使用集中式的原因：</p><ul><li>单点失败问题</li><li>流量问题</li><li>距离问题</li><li>维护性问题</li></ul><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>分布式层次数据库</p><ul><li><font color="red">根服务器</font> (ROOT DNS Sever)：这是最高层次的域名服务器，所有根域名服务器都知道所有的顶级域名服务器的IP地址，本地域名服务器只要有自己无法解析的域名时都会求助根域名服务器。共有13个根域名服务器。<strong>需要注意，根域名服务器不把直接待查询的地址直接转化为IP，而是告诉本地域名服务器下一步找哪个顶级域名服务器查询</strong></li><li><font color="red">顶级域名服务器（TLD Top-Level Domain）</font>：服务com  .edu等顶级域名以及.uk .cn等国际顶级域名。负责管理该顶级服务器管理下的所有二级域名，并在DNS请求时返回响应的回答（最后结果或下一步应该查找的域名服务器）</li><li><font color="red">授权域名服务器</font>:组织的域名解析服务器，提供组织内部的域名解析。将管辖内的主机名转换为IP地址。</li><li>本地域名服务器：每个因特网服务提供者（ISP）大学或者大学的系都可以拥有本地域名服务器.当主机发出DNS请求时，查询请求报文就发送给本地域名服务器</li></ul><p><strong>本地域名解析服务器不严格属于层级体系</strong></p><p><img src="/2020/10/05/ComNet2/Dns.jpg" alt="DNS的层次结构"></p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>域名解析是指把域名映射成IP地址或者把IP地址映射成域名的过程.前者称为<code>正向解析</code>,后者称为<code>反向解析</code>.当客户端需要域名解析时,通过本机的DNS客户端构造一个DNS请求报文.利用UDP数据报的方式发往本地域名服务器.域名解析有两种方式，<font color="red">递归查询和迭代查询</font>。其效果如下：</p><p><img src="/2020/10/05/ComNet2/DNSFind1.jpg" alt="迭代查询"></p><p><img src="/2020/10/05/ComNet2/DNSFind2.jpg" alt="递归查询"></p><p><strong>由于递归查询对根域名的负担较大，现在大多采用迭代查询的方式</strong>。该方式分为两个部分：</p><p><strong>1）主机向本地域名服务器的查询采用的是递归查询</strong></p><ul><li>如果主机询问的本地域名服务器不知道被查询的IP地址，那么本地域名服务器就以DNS客户的身份向根域名服务器发出查询请求报文（替该主机查询而非让主机自己进行下一步的查询）</li><li>本地域名服务器只需要向根域名服务器查询一个，后面的几次查询都是递归的在其他几个域名服务器之间进行的。</li></ul><p>2）本地服务器向根域名服务器的查询是迭代查询。（参照上图进行对比）</p><ul><li>当根服务器从本地域名服务器收到请求后，要么给出要查询的IP地址，要么告诉本地域名服务器下一步应该到哪个顶级域名服务器查询</li><li>同样顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该像哪个权限域名服务器查询。最后知道所要解析的IP地址后，把这个结果返回给发起查询的主机。</li></ul><p>DNS记录的缓存与更新</p><p>只要域名解析服务器获得域名——IP映射，即缓存这一映射</p><ul><li>一段时间过后，缓存条目失效（删除）</li><li>本地域名服务器一般或缓存顶级域名服务器的映射<ul><li>因此根域名服务器不经常被访问</li></ul></li></ul><p>DNS的记录和报文考纲未做要求，故未整理。</p><hr><h3 id="FTP（FTP协议的工作原理，控制连接与数据连接）"><a href="#FTP（FTP协议的工作原理，控制连接与数据连接）" class="headerlink" title="FTP（FTP协议的工作原理，控制连接与数据连接）"></a>FTP（FTP协议的工作原理，控制连接与数据连接）</h3><p>交互传输协议（FTP）是因特网上使用最广泛的文件传输协议。FTP提供交互式访问。允许客户指明文件的类型与格式。并允许文件拥有存取权限。它屏蔽了计算机的各种细节，适合于在异构的网络中的任意计算机之间传输文件。</p><p>FTP提供一下功能：</p><ul><li>提供不同主机系统之间的文件传输能力。</li><li>以用户权限的方式提供用户对远程FTP服务器上的文件管理能力。</li><li>以匿名FTP提供公用文件共享的能力</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>FTP采用客户机/服务器的模式，利用TCP可靠传输服务。一个FTP服务器进程可以同时为多个客户机提供服务。FTP服务器由两大部分构成：<strong>一个主进程，负责接收新的请求，另外有若干从属进程，负责处理单个请求</strong>。工作步骤如下：</p><ul><li>打开控制端口21，使客户进程能连接上</li><li>等待客户发起请求</li><li>启动从属进程处理客户进程发起的请求，主进程与从属进程并发执行，从属进程对于客户进程的请求处理完毕后即终止。</li><li>回到等待状态，继续处理其他客户请求。</li></ul><p>FTP服务器必须在整个会话过程中保存客户的状态信息。特别使服务器必须把指定的用户账户和控制联系起来，服务器必须追踪用户在远程目录树上的当前位置。</p><h4 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h4><p>FTP在工作时使用两个并行的TCP连接，一个是控制连接（21端口）一个是数据连接（20端口）使用两个不同的端口号可以使协议更加简单和容易实现。</p><h5 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h5><p>服务器监听21端口，等待客户连接，建立在这个端口上的连接称为<code>控制连接</code>，控制连接用来传输控制信息（连接请求，传送请求等）并且控制信息都以7位ASCii码发送。FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程。但控制连接并不用来传送文件，传输文件时还可以使用控制连接（如客户在中途发送终止传输命令），因此控制连接在整个会话期间一直保持打开状态。</p><h5 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h5><p>服务端的控制进程在接收到FTP客户端发送来的文件传输请求后，就创建数据“传输进程”和“数据连接”。数据连接用来连接客户端和服务器端的数据传输进程，数据传送进程实际完成文件的传送。在传送完毕后关闭<code>数据传送连接</code>并结束运行。</p><p>因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息时带外（Out-of-band）传送的。使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器。网络文件系统（NFS）允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><hr><h3 id="电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）"><a href="#电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）" class="headerlink" title="电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）"></a>电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）</h3><h4 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h4><p>电子邮件是一种异步通讯方式，允许通信时的双方不同时在场。电子邮件将邮件放在收件人使用的邮箱服务器中，收件人可以随时上网到自己使用的邮件服务器中进行读取。</p><p>一个邮件系统应该具有三部分组成，用户代理，邮件服务器和电子邮件使用协议（SMTP，POP3，IMAP等）</p><ul><li><font color="red">用户代理（UA）</font>用户与电子邮件的接口，用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应该具备撰写，显示和邮件处理的功能。通常情况下，用户代理就是一个运行再PC上的程序。</li><li><font color="red">邮件服务器</font>：组成邮件系统的核心，邮件服务器的功能是发送和接收邮件。同时还要向发信人报告邮件的传送状况（已交付，被拒绝，被丢失等）邮件服务器采用的客户/服务器模式工作。但其能同时担当客户和服务器。</li><li><font color="red">邮件发送协议和读取协议</font>：邮件发送协议用于用户代理向邮件服务器发送邮件或者再邮件服务器之间发送邮件。通常使用的是SMTP，邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3，注意：SMTP采用的是推的方式，即再用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件推送到SMTP服务器端，而POP3采用的是拉的模式，即用户读取邮件时，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件</li></ul><p>电子邮件的发送接收过程如下：</p><ul><li>发信人调用用户代理来撰写编辑要发送的邮件，用户代理用SMTP把邮件传送给发送方服务器。</li><li>发送方邮件服务器将邮件放入缓存队列中，等待发送</li><li>邮件服务器中的SMTP客户进程发现有邮件待发送，向运行在接收方邮件服务器的SMTP服务器发起建立TCP连接</li><li>建立连接后开始向远方发送邮件，发送完成后关闭TCP连接</li><li>接收方邮件服务器接收到邮件后，将邮件放到收信人的用户邮箱，等待收信人方便的时候读取</li><li>收信人打算收信时，调用用户代理，使用POP3或者IMAP将自己的邮件从接收方邮件服务器的用户邮箱中取回</li></ul><h4 id="邮件格式与MME"><a href="#邮件格式与MME" class="headerlink" title="邮件格式与MME"></a>邮件格式与MME</h4><h5 id="１-电子邮件格式"><a href="#１-电子邮件格式" class="headerlink" title="１.电子邮件格式"></a>１.电子邮件格式</h5><p>一个电子邮件格式分为<code>信封</code>与<code>内容</code>两部分，邮件内容又分为首部和主题两部分。<code>RFC 822</code>规定了邮件首部的格式，主体可以由用户自由撰写。用户写好首部后，邮件系统自动的将信封所需要的信息提取出来填写到信封上，用户不需要亲自填写信封上的信息。</p><p>邮件首部包括的最重要的内容有：To:和Subject:</p><ul><li>To后面加一个或者多个收件人的电子邮件地址（邮箱名@主机域名）</li><li>Subject时可选关键字，反应邮件的主要内容</li><li>From，邮件自动填入</li></ul><h5 id="2-多用途网际邮件扩充（MIME）"><a href="#2-多用途网际邮件扩充（MIME）" class="headerlink" title="2.多用途网际邮件扩充（MIME）"></a>2.多用途网际邮件扩充（MIME）</h5><p>由于用户的语言不一致性，为了传送非英语文字，使用了MIME。MIME未改变SMTP，指示增加了邮件的主体结构，定义了传送非ASCii码的编码规则。</p><p>包括以下三部分内容：</p><ul><li>5个新的邮件首部字段，MIME版本，内容描述，内容标识，内容传送码，内容类型</li><li>定义邮件内容格式，对多媒体电子邮件标识方法做了标准化</li><li>定义传送编码，可对内容格式进行转换并不会被邮件系统改变</li></ul><h4 id="SMTP与POP3"><a href="#SMTP与POP3" class="headerlink" title="SMTP与POP3"></a>SMTP与POP3</h4><h5 id="1-SMTP（Simple-Mail-Transfer-Protocol）"><a href="#1-SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="1.SMTP（Simple Mail Transfer Protocol）"></a>1.SMTP（Simple Mail Transfer Protocol）</h5><p>SMTP运用TCP连接，端口号为25，通信过程为三个阶段</p><ul><li>建立连接：SMTP客户每隔一定时间对邮箱缓存扫描，若发现邮件，则使用25端口与接收方的SMTP建立TCP连接，连接建立后接收方发送220 Service ready。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li><li></li></ul><hr><h3 id="WWW（WWW的概念与组成结构，HTTP协议）"><a href="#WWW（WWW的概念与组成结构，HTTP协议）" class="headerlink" title="WWW（WWW的概念与组成结构，HTTP协议）"></a>WWW（WWW的概念与组成结构，HTTP协议）</h3><hr><h3 id="P2P应用分发原理"><a href="#P2P应用分发原理" class="headerlink" title="P2P应用分发原理"></a>P2P应用分发原理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自顶向下计算机网络-2-应用层&quot;&gt;&lt;a href=&quot;#自顶向下计算机网络-2-应用层&quot; class=&quot;headerlink&quot; title=&quot;自顶向下计算机网络 2    应用层&quot;&gt;&lt;/a&gt;自顶向下计算机网络 2    应用层&lt;/h2&gt;&lt;h3 id=&quot;客户-服务器应
      
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yokeso.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ComNet</title>
    <link href="http://yokeso.top/2020/09/27/ComNet/"/>
    <id>http://yokeso.top/2020/09/27/ComNet/</id>
    <published>2020-09-27T12:07:35.000Z</published>
    <updated>2020-12-04T12:04:13.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络自顶向下方法"><a href="#计算机网络自顶向下方法" class="headerlink" title="计算机网络自顶向下方法"></a>计算机网络自顶向下方法</h1><h2 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h2><h3 id="计算机网络的基本概念，组成，功能与分类"><a href="#计算机网络的基本概念，组成，功能与分类" class="headerlink" title="计算机网络的基本概念，组成，功能与分类"></a>计算机网络的基本概念，组成，功能与分类</h3><h4 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h4><ul><li>利用通信设备和线路将分散在不同地点的具有独立功能的多个计算机系统互相连接起来，并按照网络协议进行数据通信实现资源共享的计算机集合</li><li>计算机网络就是一些互联的，自治的计算机集合。</li></ul><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><h5 id="1-从组成部分上看"><a href="#1-从组成部分上看" class="headerlink" title="1.从组成部分上看"></a>1.从组成部分上看</h5><p>一个完整的计算机网络由硬件 软件以及协议构成。</p><p><strong>硬件主要包括</strong>：主机(端系统)、通信链路(双绞线、光纤)、交换设备(路由器、交换机)、和通信处理机(网卡)构成</p><p><strong>软件主要包括</strong>：各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分主要处于应用层</p><p><strong>协议</strong>：协议是计算机网络的核心，协议总是指某一层的协议。准确的说是对等实体之间的通信定制的有关通信规则约定的集合。</p><h5 id="2-从工作方式上看"><a href="#2-从工作方式上看" class="headerlink" title="2.从工作方式上看"></a>2.从工作方式上看</h5><p>计算机网络分为<code>边缘部分</code>和<code>核心部分</code>。</p><p><strong>边缘部分</strong>：由所有连接到因特网上，供用户直接使用的主机组成。用来进行通信和资源共享</p><p><strong>核心部分</strong>：核心部分由大量的网络和连接这些网络的路由器构成，为边缘部分提供连通性和交换服务。</p><h5 id="3-从功能组成上看"><a href="#3-从功能组成上看" class="headerlink" title="3.从功能组成上看"></a>3.从功能组成上看</h5><p>计算机网络=资源子网+通信子网</p><p>通信子网：由传输介质通信设备和相应的网络协议组成。<br>资源子网：实现资源共享的设备及其软件的集合，为多个计算机为用户提供服务</p><h4 id="什么是因特网："><a href="#什么是因特网：" class="headerlink" title="什么是因特网："></a>什么是因特网：</h4><p>具体构成：遍及全世界数以百万的计算设备，网络的网络</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><h5 id="数据通信："><a href="#数据通信：" class="headerlink" title="数据通信："></a>数据通信：</h5><p>最基本重要的功能，实现联网计算机之间的各种信息传输，将分散在不同地理位置的计算机联系起来。进行统一的调配，控制和管理。</p><h5 id="资源共享："><a href="#资源共享：" class="headerlink" title="资源共享："></a>资源共享：</h5><p>资源共享可以是软件共享，数据共享也可以是硬件共享，使计算机网络中的设备互通有无，分工协作来提高硬件、软件。数据资源的利用率。</p><h5 id="分布式处理："><a href="#分布式处理：" class="headerlink" title="分布式处理："></a>分布式处理：</h5><p>计算机网络中某个计算机系统载荷过重时，可以将复杂的处理任务分配给网络中的其他计算机系统，利用空闲的资源提高整个系统的利用率。</p><h5 id="提高可靠性："><a href="#提高可靠性：" class="headerlink" title="提高可靠性："></a>提高可靠性：</h5><p>计算机网络中的各台计算机可以通过网络互为代替机。</p><h5 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h5><p>将工作任务均衡的分给计算机网络中的各台计算机。</p><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h4 id="1-按分布范围："><a href="#1-按分布范围：" class="headerlink" title="1.按分布范围："></a>1.按分布范围：</h4><p><strong>1）广域网（WAN）：</strong>广域网的任务是提供长距离通信，覆盖范围为 <code>几十千米</code>到<code>几千千米</code>是因特网的核心部分。</p><p><strong>2）城域网（MAN）：</strong>城域网的覆盖范围可以跨越几个街区或者整个城市，覆盖范围约为<code>5~50km</code>。大多采用以太网技术。</p><p><strong>3）局域网（LAN）：</strong>局域网通过微机或者工作站与高速链路相连，覆盖范围为<code>几十米到几千米</code>，在计算机配置数量上没有太多限制。</p><p><strong>4）个人区域网（PAN）：</strong>将个人的电子设备通过无线技术连接起来，范围覆盖直径通常为<code>10m</code>。</p><h4 id="2-按传输技术分："><a href="#2-按传输技术分：" class="headerlink" title="2.按传输技术分："></a>2.按传输技术分：</h4><p><strong>1）广播式网络：</strong>所有联网计算机共享一个公共通信通道，一台计算机发送，其他计算机都能收听到这个分组，接收到分组的计算机通过检查目的地址确定自己是否接受。</p><p><strong>2）点对点网络：</strong>每条物理线路连接一对计算机。如果两台主机中间没有专有线路就啊哟通过中间节点接收、存储和转发达到目的节点。（广域网基本属于点对点网络）。</p><h4 id="3-按拓扑结构分："><a href="#3-按拓扑结构分：" class="headerlink" title="3.按拓扑结构分："></a>3.按拓扑结构分：</h4><p>网络拓扑结构指的是由网中节点与通信线路之间的几何关系来表示的网络结构，主要指通信子网的拓扑结构。分为星型、总线型、环形和网络型等。</p><h4 id="4-按使用者分："><a href="#4-按使用者分：" class="headerlink" title="4.按使用者分："></a>4.按使用者分：</h4><p><strong>1）公用网（Public Network）</strong>指电信公司出资建造的大型网络，所有按规定交费的人都可以用。</p><p><strong>2）专用网（Private Network）</strong>指某个部门为了特殊的事物业务需要而建造的网络。不像本单位以外的人提供服务。</p><h4 id="5-按交换技术分："><a href="#5-按交换技术分：" class="headerlink" title="5.按交换技术分："></a>5.按交换技术分：</h4><h5 id="1）电路交换网络"><a href="#1）电路交换网络" class="headerlink" title="1）电路交换网络"></a>1）电路交换网络</h5><p>​    在源节点和目的节点之间建立一条专门用来传输数据的通路，包括建立连接、传输数据和断开连接三个部分。（电话）</p><p>​    <strong>特点：</strong>报文的比特流连续的从原点直达终点。</p><p>​    <strong>优点：</strong>数据直接传送，延时小，有序传输，适用范围广，控制简单。</p><p>​    <strong>缺点：</strong>建立时间长，线路利用率低，不能充分利用线路容量，不利于进行差错控制</p><h5 id="2）报文交换网络（存储-转发网络）"><a href="#2）报文交换网络（存储-转发网络）" class="headerlink" title="2）报文交换网络（存储-转发网络）"></a>2）报文交换网络（存储-转发网络）</h5><p>​    用户数据加上源地址，目的地址，校验码等辅助信息，封装成报文，存储转发传输到下一个节点，下一个节点全部存储转发之后再传输到下一个直到目的节点为止。每个报文可以单独选择传输的路径。</p><p>存储转发传输：在传输该分组的第一个bit之前必须接收到整个分组。</p><p>​    <strong>特点：</strong>整个报文先传输到相邻节点，相邻节点全部接受存储后查找转发表，再转发给下一节点。</p><p>​    <strong>优点：</strong>无需建立连接，可以较为充分的利用线路容量，可以实现不同链路之间不同速率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。</p><p>​    <strong>缺点：</strong>增大资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文顺序不乱。缓冲区难以管理。</p><h5 id="3）分组交换网络"><a href="#3）分组交换网络" class="headerlink" title="3）分组交换网络"></a>3）分组交换网络</h5><p>也称包交换网络，原理是将数据分为较短的固定大小块，在每个块中加入源地址，目的地址，校验码等辅助信息，封装成分组（包），以存储转发方式传输。</p><p>​    <strong>特点：</strong>单个分组传送到临近节点，存储后查找转发表并传送到下一节点直到传送到目的节点为止</p><p>​    <strong>优点：</strong>报文交换网络优点+ 缓冲易于管理，包平均时延更小。网络占用的平均缓冲区更少。易于标准化易于使用</p><p>​    现在主流网络基本都可视为分组网络。</p><p>​    <strong>缺点：</strong>存在传输时延，需要传输额外的信息量，采用数据报服务时可能出现失序，丢失分组或者重复分组。</p><h4 id="6-按传输介质分"><a href="#6-按传输介质分" class="headerlink" title="6.按传输介质分"></a>6.按传输介质分</h4><p>​    有线：双绞线网络，同轴电缆等。无线：蓝牙、微波、无线电等。</p><hr><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><p><strong>多路复用：</strong>在一条传输链路上同时建立多条连接分别传输数据。</p><p><strong>电路交换</strong>中的多路复用主要分为频分多路复用（Frequency-Division Multiplexing FDM）和时分多路复用。</p><p><strong>频分多路复用（FDM）：</strong> 按频率划分若干个频段，每个频段专用于一个连接</p><p><strong>时分多路复用（TDM）：</strong> 时间划分为固定区间的帧，每帧划为固定数量的时隙每个时隙专用于一个连接用于传输该链接的数据。</p><p><strong>波分多路复用 WDM(Wavelength Division Multiplexing)：</strong>是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器(亦称分波器或称去复用器，Demultiplexer)将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。这种在同一根光纤中同时传输两个或众多不同波长光信号的技术，称为波分复用。</p><p><strong>码分多路复用（code division multiplexing）：</strong>是指利用各路信号码型结构正交性而实现多路复用的通信方式</p><hr><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p><strong>速率</strong>：网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率</p><p><strong>带宽：</strong>频分多路复用中的一个频段的宽度</p><p><strong>时延：</strong>指数据（一个报文或者分组）</p><pre><code>**处理时延：**决定将分组导向何处，检查比特差错，决定输出链路</code></pre><p>​    <strong>排队时延：</strong>分组等待在链路上传输的排队时间。排队时延的长短取决于先期到达的正在排队等待的分组数量。</p><p>​    <strong>传输时延：</strong>将分组的所有比特推向链路所需要的时间：（比特分组长度/传输速率）</p><pre><code>**传播时延：**一个比特从链路的起点到下一节点（路由器）传播所需要的时间。（两台路由器之间额距离/传输速率）</code></pre><p>​    <strong>丢包</strong>：如果到达的分组发现一个满的队列，没有地方存储这个分组，那么路由器将丢弃这个分组，这个分组就会丢失。</p><p>​    <font color="red">注意传输时延和传播时延的区别</font></p><p><strong>流量强度（traffic intensity）：</strong>比特到达队列的平均速率（pkt/s）与比特从队列中推出的速率（bps）之比</p><p><em>设计系统时流量强度不能大于1</em></p><p><strong>时延带宽积：</strong>指发送的第一个比特即将到达终点时发送端发送了多少个比特。因此又称为以比特为单位的链路长度。即<br>$$<br>延带宽积=传播时延\times信道带宽<br>$$<br><strong>吞吐量 （throughput）：</strong> 单位时间通过某个网络（信道或端口）的比特的数量，吞吐量受到网络带宽或者网络定额数据的限制。</p><p>​        （考虑从主机A到主机B发送一个大文件）</p><ul><li><p>平均吞吐量 ：主机B接收到的文件的速率（bps）</p></li><li><p>顺时吞吐量：若该文件为F比特，主机B接受到所有比特用了T秒，平均吞吐量为F/T bps</p></li></ul><hr><h2 id="计算机网络分层体系结构"><a href="#计算机网络分层体系结构" class="headerlink" title="计算机网络分层体系结构"></a>计算机网络分层体系结构</h2><p>我们把计算机网络的各层及其协议的集合称为网络的体系结构。也就是这个计算机网络及其完成功能的精确定义。计算机网络的体系结构通常有可分层性，将大系统分为若干较容易实现的系统层次。</p><p>在计算机的分层活动中，第n层活动的元素称为n层实体。具体来说实体指任何可发送或接收信息的硬件或软件过程。</p><p>计算机网络中的每一层通过在该层中执行某些动作或使用直接下层的服务来提供服务。例如：第n层提供的服务可能包括保温从网络的一边到另一边的可靠传送。这可能是通过使用第n+1层的边缘到到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>因特网的协议栈由五个层次组成：物理层，链路层，网络层，运输层，应用层。</p><p>七层ISO OSI参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。</p><table><thead><tr><th>层名称</th><th>作用</th><th>信息分组</th></tr></thead><tbody><tr><td>应用层</td><td>网络应用程序以及他们的应用层协议存留的地方</td><td>报文</td></tr><tr><td>运输层</td><td>应用成熟端点之间传输应用层报文（TCP/UDP）</td><td>报文段</td></tr><tr><td>网络层</td><td>将数据报的网络层分组从一台主机移动到另一台主机</td><td>数据报</td></tr><tr><td>链路层</td><td>为了将分组从一个节点移动到另一个节点，网络层必须依靠链路层的服务</td><td>帧</td></tr><tr><td>物理层</td><td>将帧一个比特一个比特的移动到下一个节点</td><td></td></tr></tbody></table><hr><h2 id="计算机网络协议、接口、服务等概念"><a href="#计算机网络协议、接口、服务等概念" class="headerlink" title="计算机网络协议、接口、服务等概念"></a>计算机网络协议、接口、服务等概念</h2><h3 id="1-协议"><a href="#1-协议" class="headerlink" title="1.协议"></a>1.协议</h3><p>协议就是规则的集合。在网络中想要有条不紊的交换数据就要遵守事先约定好的规则。这些规则明确规定了所交换的数据的格式，以及有关的同步问题。这些为网络中数据交换而建立的准则标准或约定称为网络协议。<strong>它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的</strong>。不对等实体之间是没有协议的，</p><p>​        协议由语法，语义和同步三部分构成，其中，语法规定了传输数据的格式，语义规定了所要完成的功能。即需要发出何种控制信息，完成何种控制动作以及做出何种应答；同步规定了执行各种操作的条件，时序关系等，即事件实现顺序的详细说明。一个完整的协议通常应具有链路管理（建立，释放连接），差错控制，数据转换等功能。</p><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>接口是统一节点内相邻两层间交换信息的节点。是一个系统的内部规定。接口只能在相邻的层次之间定义，不能跨层定义。在典型的接口上，同一节点相邻的两层的实体通过服务访问点(Service Acceess Point SAP)进行交互。服务通过SAP提供给上层使用。第n层的SAP就是第n+1层可以访问第n层服务的地方。每个SAP都有一个能标识他的地址。SAP是一个抽象的概念。实际上是一个逻辑接口，与硬件接口不同。</p><h4 id="3-服务"><a href="#3-服务" class="headerlink" title="3.服务"></a>3.服务</h4><p>服务是指下层为紧邻的上层提供的功能调用。是垂直的。在对等实体的控制下，使得本层只能为上一层提供服务。但要实现本层协议还需要使用下一层所提供的服务。上层使用下层服务时要与下层交换服务原语。OSI将原语划分为四类：</p><ul><li>请求：由用户发往提供者，请求完成某项工作。</li><li>指示：由服务者发往用户，指示用户做某样事情。</li><li>响应：由用户发往服务提供者，表示对于指示的响应</li><li>证实：由服务提供者发往用户，表示对请求的证实。</li></ul><p>注意协议和服务概念上的区别，只有本层协议实现才能向上一层提供服务。本层的服务用户只能看到服务而不能看到协议。即下面的协议对上面的服务用户是透明的。其次，协议是水平的，面向对等实体，但是服务是垂直的，从下层向上层传播。</p><p>计算机网络提供的服务分为三类：</p><p><strong>（1）面向连接服务和无连接服务：</strong>面向连接需要建立连接，传输数据，链接释放三个步骤。而在无连接服务中，通信双方不需要建立连接，需要发送数据时可以直接进行发送。把目的地址的包发送到链路上，由系统选取路线发送。这种服务被描述为“尽最大努力交付”。并不保证通信的可靠性。</p><p><strong>（2）可靠服务和不可靠服务：</strong>可靠服务要求网络具有纠错，验错，应答机制。可以保证数据正确可靠的传输到目的地。不可靠服务只是尽力而为的传送，但不能保证数据正确可靠的传输到目的地。对于提供不可靠服务的网络，可靠性要通过用户程序来进行保障。用户发现不正确的信息后报告给发送者，由发送者采取措施，从而使不可靠的服务变为可靠的服务。</p><p><strong>（3）有应答服务和无应答服务：</strong>有应答服务需要在接收方接收到数据后向发送方给出响应应答。这个应答应该由传输系统实现而非用户实现。发送的应答既可以是肯定应答，也可以是否定应答。无应答服务是指接收方在接收到数据后不自动给出应答。若要给应答，则由高层实现。</p><hr><h2 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h2><h3 id="1-ISO-OSI模型"><a href="#1-ISO-OSI模型" class="headerlink" title="1.ISO/OSI模型"></a>1.ISO/OSI模型</h3><p>国际标准化组织（ISO）提出的网络体系结构模型，称为<code>开放系统互连参考模型（OSI）</code>OSI有七层，自上而下为应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。其中高三层称为资源子网，相当于计算机系统，完成数据处理的功能。低三层称为通信子网，是为了联网附加的通信设备。传输层在中间承上启下。</p><p>具体各层描述见王道17-19页</p><h3 id="2-TCP-IP模型"><a href="#2-TCP-IP模型" class="headerlink" title="2.TCP/IP模型"></a>2.TCP/IP模型</h3><p>模型从低到高依次为网络接口层（对应OSI的物理层和数据链路层），网际层，传输层和应用层（对应OSI的表示层和应用层）王道20-21页。。懒得打了，之后整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络自顶向下方法&quot;&gt;&lt;a href=&quot;#计算机网络自顶向下方法&quot; class=&quot;headerlink&quot; title=&quot;计算机网络自顶向下方法&quot;&gt;&lt;/a&gt;计算机网络自顶向下方法&lt;/h1&gt;&lt;h2 id=&quot;一、计算机网络概述&quot;&gt;&lt;a href=&quot;#一、计算机网络概
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CCFtab</title>
    <link href="http://yokeso.top/2020/08/28/CCFtab/"/>
    <id>http://yokeso.top/2020/08/28/CCFtab/</id>
    <published>2020-08-28T07:11:22.000Z</published>
    <updated>2020-09-12T12:41:05.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.常用注意要点</p><p>2.常用stl详解以及使用方式简述</p><ul><li>2.1 map</li><li>2.2 unordered_map</li><li>2.3 vector</li><li>2.4 queue</li><li>2.5 stack</li><li>2.6 set</li></ul><p>3.常用函数原型以及解释（随时添加）</p><p>​    <code>#includ&lt;ctype.h&gt;</code></p><p>​    <code>#include&lt;algorithm&gt;</code></p><p>​    <code>#include&lt;string&gt;</code></p><p>4.运用文件读写加快测试速度的代码</p><hr><h3 id="常用注意要点"><a href="#常用注意要点" class="headerlink" title="常用注意要点"></a>常用注意要点</h3><h4 id="1-include-lt-bits-stdc-h-gt"><a href="#1-include-lt-bits-stdc-h-gt" class="headerlink" title="1.#include&lt;bits/stdc++.h&gt;"></a>1.#include&lt;bits/stdc++.h&gt;</h4><p>万能头文件，包含了所有的已知常用库</p><h4 id="2-ios-sync-with-stdio-false"><a href="#2-ios-sync-with-stdio-false" class="headerlink" title="2.ios::sync_with_stdio(false);"></a>2.ios::sync_with_stdio(false);</h4><p>为了防止因为cin以及cout产生超时，将cin以及cout的缓冲区置为false</p><h4 id="3-cin-tie-0"><a href="#3-cin-tie-0" class="headerlink" title="3.cin.tie(0);"></a>3.cin.tie(0);</h4><p>接触cin与cout的绑定，加快执行效率</p><h3 id="常用stl详解以及使用方式"><a href="#常用stl详解以及使用方式" class="headerlink" title="常用stl详解以及使用方式"></a>常用stl详解以及使用方式</h3><p>stl中很常用的一个东西就是迭代器iterator，但是注意，iterator相当于是指向节点的指针，所以在整个stl发生改变或者删除时会出现迭代器产生空指针的情况，所以要牢记一点：不要用过期的iterator!!!</p><p>如果希望将一个结构体作为几种stl的键值时需要将struct中的某一个值作为键值对<code>&lt;</code>进行重载，具体方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">float</span> score;  </span><br><span class="line">    <span class="comment">//重载“&lt;”操作符，自定义排序规则  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Info &amp;a) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//按score从大到小排列  </span></span><br><span class="line">        <span class="keyword">return</span> a.score&lt;score;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt; s;  </span><br><span class="line">......  </span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt;::iterator it;</span><br></pre></td></tr></table></figure><h4 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h4><p>map是键-值对的组合，有以下的一些定义的方法：</p><ul><li><code>map&lt;k, v&gt; m;</code></li><li><code>map&lt;k, v&gt; m(m2);</code></li><li><code>map&lt;k, v&gt; m(b, e);</code></li></ul><p>上述第一种方法定义了一个名为m的空的map对象；第二种方法创建了m2的副本m；第三种方法创建了map对象m，并且存储迭代器b和e范围内的所有元素的副本。</p><p>map的value_type是存储元素的键以及值的pair类型，键为const。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>insert函数的插入方法主要有如下：</p><ul><li><code>m.insert(e)</code></li><li><code>m.insert(beg, end)</code></li><li><code>m.insert(iter, e)</code></li></ul><p>上述的e一个value_type类型的值。beg和end标记的是迭代器的开始和结束。</p><p>两种插入方法如下面的例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">                mp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">                mp.insert(make_pair(i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d--&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map中可以利用结构体作为key值，但是要对小于号进行符号重载</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll x;</span><br><span class="line">ll y;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp; a) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>上述采用下标的方法读取map中元素时，若map中不存在该元素，则会在map容器中插入一个新的元素。</p><p>因此，若只是查找该元素是否存在，可以使用函数<code>count(k)</code>，该函数返回的是k出现的次数；若是想取得key对应的值，可以使用函数<code>find(k)</code>，该函数返回的是指向该元素的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it_find;</span><br><span class="line">it_find = mp.<span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (it_find != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">      it_find-&gt;second = <span class="number">20</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"no!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find一定会使用迭代器，所以要学会对迭代器进行初始化</p><p><code>map&lt;int, int&gt;::iterator it_find;</code></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>从map中删除元素的函数是<code>erase()</code>，该函数有如下的三种形式：</p><ul><li><code>m.erase(k)</code></li><li><code>m.erase(p)</code></li><li><code>m.erase(b, e)</code></li></ul><p>第一种方法删除的是m中键为k的元素，返回的是删除的元素的个数；第二种方法删除的是迭代器p指向的元素，返回的是void；第三种方法删除的是迭代器b和迭代器e范围内的元素，返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">        mp.insert(make_pair(i, i));</span><br><span class="line">   &#125;</span><br><span class="line">   mp.erase(<span class="number">0</span>);</span><br><span class="line">   mp.erase(mp.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><h5 id="map常用函数"><a href="#map常用函数" class="headerlink" title="map常用函数"></a>map常用函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">mymap.insert(make_pair(<span class="string">'a'</span>, <span class="number">100</span>));</span><br><span class="line">mymap[<span class="string">'b'</span>] = <span class="number">100</span>;</span><br><span class="line">mymap.insert(pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">'c'</span>,<span class="number">300</span>));</span><br><span class="line"><span class="comment">//返回迭代器到开始(公共成员函数)</span></span><br><span class="line">mymap.<span class="built_in">begin</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回迭代器到末尾(公共成员函数)</span></span><br><span class="line">mymap.<span class="built_in">end</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回反向迭代器到反向开始(公共成员函数)</span></span><br><span class="line">mymap.rbegin() </span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回反向迭代器到反向端(公共成员函数)</span></span><br><span class="line">mymap.rend()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将const_iterator返回到开始(公共成员函数)    </span></span><br><span class="line">mymap.cbegin()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回const_iterator末尾(公共成员函数)</span></span><br><span class="line">mymap.cend()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const_reverse_iterator到反向开始(公共成员函数)    </span></span><br><span class="line">mymap.crbegin()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const_reverse_iterator到reverse end(公共成员函数)</span></span><br><span class="line">mymap.crend()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回映射中是否为空    </span></span><br><span class="line">mymap.empty()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回映射容器可以容纳的元素的最大数量    </span></span><br><span class="line">mymap.max_size()</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问元素(公共成员函数)    </span></span><br><span class="line">mymap[<span class="string">'a'</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">//修改Key值的引用值    </span></span><br><span class="line">mymap.at(<span class="string">'a'</span>)=<span class="number">10</span>;        </span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入元素(公共成员函数)   </span></span><br><span class="line">mymap.insert()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除元素(公共成员函数)    </span></span><br><span class="line">mymap.erase()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//交换内容(公共成员函数)，将两个map中的内容完全交换   </span></span><br><span class="line">mymap.swap(mymap2)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//从map容器中删除所有元素，使容器的大小为0   </span></span><br><span class="line">mymap.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><h4 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2.unordered_map"></a>2.unordered_map</h4><p>map内部实现的是一个黑红树，具有自动排序功能，因此map所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p><p>unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p><p>在有对于顺序要求的问题中，map会更高效，但是map的每个节点占用空间更大。</p><p>而对于查找问题来说，unordered_map会更加高效，因为哈希表查找速度非常快，但是哈希表建立比较消耗时间。</p><p>其操作与map相同。</p><h4 id="3-vector"><a href="#3-vector" class="headerlink" title="3.vector"></a>3.vector</h4><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器，</p><h5 id="vector初始化："><a href="#vector初始化：" class="headerlink" title="vector初始化："></a>vector初始化：</h5><p><strong>方式1.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式2.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量，且给出的每个元素初值为1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式3.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用向量b给向量a赋值，a的值完全等价于b的值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式4</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>+<span class="number">3</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式5.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从数组中获得初值</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure><h5 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.assign(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.assign(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.erase(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.capacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.resize(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.swap(b);</span><br><span class="line">下标访问是之恶能访问</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>通过下标访问时只能访问存在的元素，</p><h5 id="几个常用的算法"><a href="#几个常用的算法" class="headerlink" title="几个常用的算法"></a>几个常用的算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"> sort(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"> reverse(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line"> copy(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br><span class="line">  <span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="4-queue"><a href="#4-queue" class="headerlink" title="4.queue"></a>4.queue</h4><p>只能访问queue<T>容器适配器的第一个和最后一个元素，只能在容器的末尾添加新元素，只能从头部移除元素。</T></p><p>queue的基本操作如下图：</p><p><img src="/2020/08/28/CCFtab/queue.jpg" alt></p><p>queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line"><span class="comment">//返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span></span><br><span class="line">q.front()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span></span><br><span class="line">q.back()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。    </span></span><br><span class="line">q.push(<span class="keyword">const</span> T&amp; obj)：</span><br><span class="line"></span><br><span class="line"><span class="comment">//以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。    </span></span><br><span class="line">q.push(T&amp;&amp; obj)：</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 queue 中的第一个元素。</span></span><br><span class="line">q.pop()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 queue 中元素的个数。</span></span><br><span class="line">q.<span class="built_in">size</span>()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 queue 中没有元素的话，返回 true。</span></span><br><span class="line">q.empty()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</span></span><br><span class="line">emplace()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</span></span><br><span class="line">swap(<span class="built_in">queue</span>&lt;T&gt; &amp;other_q)：</span><br></pre></td></tr></table></figure><h4 id="5-stack"><a href="#5-stack" class="headerlink" title="5.stack"></a>5.stack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//堆栈为空则返回真</span></span><br><span class="line">s1.empty() </span><br><span class="line"></span><br><span class="line"><span class="comment">//移除栈顶元素</span></span><br><span class="line">s1.pop() </span><br><span class="line"></span><br><span class="line"><span class="comment">//在栈顶增加元素a</span></span><br><span class="line">s1.push(a) </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈中元素数目</span></span><br><span class="line">s1.<span class="built_in">size</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line">s1.top()</span><br></pre></td></tr></table></figure><h4 id="6-set"><a href="#6-set" class="headerlink" title="6.set"></a>6.set</h4><p>set容器是用来存储同一数据类型的数据类型，并能从一个数据集合取出数据，在set中每个元素的值都唯一，系统能根据元素的值自动排序，应注意set中的每个值都不能直接被改变。与map相同，set的内部同样实现的是黑红树。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key_value插入到set中 ，返回值是pair&lt;set&lt;int&gt;::iterator,bool&gt;，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置。</span></span><br><span class="line">insert(key_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将定位器first到second之间的元素插入到set中，返回值是void.</span></span><br><span class="line">inset(first,second);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器的第一个元素</span></span><br><span class="line"><span class="built_in">begin</span>()     　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器的最后一个元素</span></span><br><span class="line"><span class="built_in">end</span>() 　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除set容器中的所有的元素</span></span><br><span class="line"><span class="built_in">clear</span>()   　　     </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断set容器是否为空</span></span><br><span class="line">empty() 　　　</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器可能包含的元素最大个数</span></span><br><span class="line">max_size() 　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前set容器中的元素个数</span></span><br><span class="line"><span class="built_in">size</span>() 　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的值和end()相同</span></span><br><span class="line">rbegin　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的值和rbegin()相同</span></span><br><span class="line">rend()　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一对定位器，分别表示第一个大于或等于给定关键值的元素和 第一个大于给定关键值的元素，这个返回值是一个pair类型    </span></span><br><span class="line">equal_range() </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定位器iterator指向的值</span></span><br><span class="line">erase(iterator)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定位器first和second之间的值</span></span><br><span class="line">erase(first,second)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除键值key_value的值</span></span><br><span class="line">erase(key_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给定值值得定位器，如果没找到则返回end()。</span></span><br><span class="line"><span class="built_in">find</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个大于等于key_value的定位器</span></span><br><span class="line">lower_bound(key_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个大于key_value的定位器</span></span><br><span class="line">upper_bound(key_value)</span><br></pre></td></tr></table></figure><h3 id="常用函数原型以及解释"><a href="#常用函数原型以及解释" class="headerlink" title="常用函数原型以及解释"></a>常用函数原型以及解释</h3><p>以下函数以及头文件均包含在bits/stdc++.h中，无需特殊声明。</p><h4 id="include-lt-ctype-h-gt"><a href="#include-lt-ctype-h-gt" class="headerlink" title="#include&lt;ctype.h&gt;"></a><code>#include&lt;ctype.h&gt;</code></h4><p>这几个都是返回非0表示正确，返回0表示错误</p><p>1.<code>isalnum(int c);</code></p><p>​    用来判断一个字符是否是字母或者十进制数字。其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>2.<code>islower(int c);</code></p><p>​    用来检测一个字符是不是小写字母，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>3.<code>isalpha(int c);</code></p><p>​    用来检测一个字符是不是字母，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>4.<code>isdigit(int c);</code></p><p>​    用来检测一个字符是不是数字，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>5.<code>isblank(int c);</code></p><p>​    用来检测一个字符是不是空白符，其中c表示要检测的字符，这个函数仅检测<code>空格‘’</code>,<code>水平制表符‘/t’</code>，如果想检测更多的话需要用函数<code>isspace()</code>;</p><p>6.<code>iscntrl(int c);</code></p><p>​    iscntrl() 函数用来检测一个字符是否是控制字符（Control Character）。控制字符的范围是<code>0x00 (NUL) ~ 0x1f (US)</code>，再加上一个<code>0x7f (DEL)</code>字符。</p><p>7.<code>isgraph(int c);</code></p><p>​    isgraph() 函数用来检测一个字符是否是图形字符。</p><p>8.<code>ispunct(int c);</code></p><p>​    ispunct() 函数用来检测一个字符是否是标点符号。</p><p>9.<code>isupper ( int c );</code></p><p>​    isupper() 函数用来检测一个字符是否是大写字母。</p><p>10.<code>isxdigit ( int c );</code></p><p>​    isxdigit() 用来检测一个字符是否是十六进制数字。</p><p>11.<code>tolower ( int c );</code></p><p>​    tolower() 函数用来将大写字母转换为小写字母。</p><p>12.toupper ( int c );</p><p>​    toupper() 函数用来将小写字母转换为大写字母。</p><h4 id="include-lt-algorithm-gt"><a href="#include-lt-algorithm-gt" class="headerlink" title="#include&lt;algorithm&gt;"></a><code>#include&lt;algorithm&gt;</code></h4><p>1.<code>reverse(it,it2)</code></p><p>​    <strong>将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转。string也可以。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]= &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;; </span><br><span class="line">reverse(a, a+<span class="number">4</span>);<span class="comment">//a[0]~a[3]反转</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line">reverse(str.<span class="built_in">begin</span>()+<span class="number">2</span>, str.<span class="built_in">begin</span>()+<span class="number">6</span>);<span class="comment">//对a[2]~a[5]逆转*左闭右开*</span></span><br></pre></td></tr></table></figure><p>2.<code>sort(a,a+k,cmp)</code></p><p>​    <strong>sort(首元素地址(必填), 尾元素地址的下一个地址(必填), 比较函数(非必填));不填写时默认为递增序列。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//将a[0]~a[3]从小到大排序</span></span><br><span class="line">sort(a, a+<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cmp函数用法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;  <span class="comment">//可以理解为当a&gt;b时把a放在b前面 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="#include&lt;string&gt;"></a><code>#include&lt;string&gt;</code></h4><p>1.<code>void *memchr(const void *str, int c, size_t n)</code></p><p>在参数str指向的字符串的前n个字节中搜索第一次出现字符c（无符号字符）的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"http://www.runoob.com"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> ch = <span class="string">'.'</span>;</span><br><span class="line">   <span class="keyword">char</span> *ret;</span><br><span class="line"> </span><br><span class="line">   ret = (<span class="keyword">char</span>*)<span class="built_in">memchr</span>(str, ch, <span class="built_in">strlen</span>(str));</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"|%c| 之后的字符串是 - |%s|\n"</span>, ch, ret);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>int memcmp(const void*str1,const void*str2,size_t n);</code></p><p>将str1和str2的前n个字节进行比较</p><p>字符串相等返回0，字符串前大于后返回1否则返回0</p><p>3.<code>void *memcpy(void *dest, const void *src, size_t n)</code><br>从 src 复制 n 个字符到 dest。</p><p>4.<code>void *memmove(void *dest, const void *src, size_t n)</code><br>另一个用于从 src 复制 n 个字符到 dest 的函数。</p><p>5.<code>void *memset(void *str, int c, size_t n)</code><br>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p><p>6.<code>char *strcat(char *dest, const char *src)</code><br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</p><p>该函数返回一个指向最终的目标字符串 dest 的指针。</p><p>7.<code>char *strncat(char *dest, const char *src, size_t n)</code><br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</p><p>8.<code>char *strchr(const char *str, int c)</code><br>在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</p><p>9.<code>int strcmp(const char *str1, const char *str2)</code><br>把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</p><p>该函数返回值如下：</p><ul><li>如果返回值小于 0，则表示 str1 小于 str2。</li><li>如果返回值大于 0，则表示 str1 大于 str2。</li><li>如果返回值等于 0，则表示 str1 等于 str2。</li></ul><p>10.<code>int strncmp(const char *str1, const char *str2, size_t n)</code><br>把 str1 和 str2 进行比较，最多比较前 n 个字节。</p><p>11.<code>int strcoll(const char *str1, const char *str2)</code><br>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</p><p>12.<code>char *strcpy(char *dest, const char *src)</code></p><p>把 src 所指向的字符串复制到 dest。</p><p>13.<code>char *strncpy(char *dest, const char *src, size_t n)</code><br>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</p><p>14.<code>size_t strcspn(const char *str1, const char *str2)</code><br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</p><p>该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。</p><p>以匹配到第一个字符为准。</p><p>15.<code>char *strerror(int errnum)</code><br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror生成的错误字符串取决于开发平台和编译器。</p><p>16.<code>size_t strlen(const char *str)</code><br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p><p>17.<code>char *strpbrk(const char *str1, const char *str2)</code><br>检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。</p><p>该函数返回 str1 中第一个匹配字符串 str2 中字符的字符数，如果未找到字符则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str1[] = <span class="string">"abcde2fghi3jk4l"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> str2[] = <span class="string">"34"</span>;</span><br><span class="line">   <span class="keyword">char</span> *ret;</span><br><span class="line"> </span><br><span class="line">   ret = <span class="built_in">strpbrk</span>(str1, str2);</span><br><span class="line">   <span class="keyword">if</span>(ret) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"第一个匹配的字符是： %c\n"</span>, *ret);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"未找到字符"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//返回3</span></span><br></pre></td></tr></table></figure><p>18.<code>char *strrchr(const char *str, int c)</code><br>在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</p><p>19.<code>size_t strspn(const char *str1, const char *str2)</code><br>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</p><p>20.<code>char *strstr(const char *haystack, const char *needle)</code><br>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</p><p>21.<code>char *strtok(char *str, const char *delim)</code><br>分解字符串 str 为一组字符串，delim 为分隔符。</p><p>22.<code>size_t strxfrm(char *dest, const char *src, size_t n)</code><br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</p><h3 id="运用文件读写加快测试速度的代码"><a href="#运用文件读写加快测试速度的代码" class="headerlink" title="运用文件读写加快测试速度的代码"></a>运用文件读写加快测试速度的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(freopen("in.txt","r",stdin)==NULL)</span></span><br><span class="line"><span class="comment">    fprintf(stderr,"errorredirecting stdout\n")</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    freopen(<span class="string">"out.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建.cpp文件的地方创建in.txt文件和out.txt文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;1.常用注意要点&lt;/p&gt;
&lt;p&gt;2.常用stl详解以及使用方式简述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.1 map&lt;/li&gt;
&lt;li&gt;2.2 un
      
    
    </summary>
    
    
    
      <category term="-CCF" scheme="http://yokeso.top/tags/CCF/"/>
    
  </entry>
  
  <entry>
    <title>DSPtopic</title>
    <link href="http://yokeso.top/2020/08/25/DSPtopic/"/>
    <id>http://yokeso.top/2020/08/25/DSPtopic/</id>
    <published>2020-08-25T06:52:08.000Z</published>
    <updated>2020-08-25T07:17:20.452Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/25/DSPtopic/3.3.1.png" alt></p><img src="/2020/08/25/DSPtopic/3.3.1-3.png" style="zoom:108%;"><p><img src="/2020/08/25/DSPtopic/3.3.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/4.1.1.png" alt></p><img src="/2020/08/25/DSPtopic/4.1.1-2.png" style="zoom:80%;"><p><img src="/2020/08/25/DSPtopic/5.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.4.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2-3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1.png&quot; alt&gt;&lt;/p&gt;
&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1-3.png&quot; style=&quot;zoom:108%;&quot;&gt;

&lt;p&gt;&lt;img src=&quot;/2020/08
      
    
    </summary>
    
    
    
      <category term="-DSP -2020 -lunboli" scheme="http://yokeso.top/tags/DSP-2020-lunboli/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-4</title>
    <link href="http://yokeso.top/2020/08/18/OS-ch-4/"/>
    <id>http://yokeso.top/2020/08/18/OS-ch-4/</id>
    <published>2020-08-18T00:13:09.000Z</published>
    <updated>2020-08-18T14:22:23.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p>用户程序的主要处理阶段</p><p>连续分配方式</p><p>离散分配方式</p><p>虚拟存储器的基本特征</p><h3 id="存储器的管理功能"><a href="#存储器的管理功能" class="headerlink" title="存储器的管理功能"></a>存储器的管理功能</h3><ol><li>存储分配和回收（主要内容，讨论算法和相应的数据结构）</li><li>地址变换（文件生成的连接技术，加载的重定位技术，运行时的地址变换）</li><li>存储共享和保护（代码数据的共享，对地址空间的访问权限）</li><li>存储器扩充（存储器的逻辑组织和物理知识）<ol><li>由应用程序控制：覆盖</li><li>由OS控制：交换（整个进程）请求调入和预调入（部分进程）</li></ol></li></ol><h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><ul><li><p>逻辑地址，也称虚地址，相对地址</p><ul><li>由CPU执行指令时生成的地址（本条指令所需数据的地址或下一条指令地址）</li></ul></li><li><p>物理地址，也称绝对地址，实地址</p><ul><li>实际的内存单元地址</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-1.jpg" alt></p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p><img src="/2020/08/18/OS-ch-4/4.1-2.jpg" alt></p><h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><ul><li><p>将逻辑地址和物理地址分离，是内存管理的核心</p></li><li><p>逻辑地址与物理地址相同</p><ul><li>地址映像工作在编译阶段或加载阶段完成</li></ul></li><li><p>重定位</p><ul><li>进程的逻辑地址空间不同于物理地址空间，所以存储管理模块要解决逻辑地址到物理地址的映射问题。</li><li>也称地址映射，地址映像</li><li>在执行阶段完成</li></ul></li></ul><h3 id="4-1程序的装入和链接"><a href="#4-1程序的装入和链接" class="headerlink" title="4.1程序的装入和链接"></a>4.1程序的装入和链接</h3><p>编程可得到执行文件的步骤：编译（obj文件），链接（EXE文件或动态链接库dll），装入</p><p><img src="/2020/08/18/OS-ch-4/4.1-3.jpg" alt></p><h4 id="4-1-1-程序的装入"><a href="#4-1-1-程序的装入" class="headerlink" title="4.1-1 程序的装入"></a>4.1-1 程序的装入</h4><ol><li><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5></li></ol><ul><li>编译程序知道程序在内存中的地址，并产生绝对地址的目标代码</li><li>绝对装入模块装入时直接定位在上述内存地址，不修改程序和地址的数据</li><li>优点：装入过程简单，</li><li>缺点：过于依赖硬件结构，不适用于多道程序系统</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-4.jpg" alt></p><h5 id="2-可重定位装入"><a href="#2-可重定位装入" class="headerlink" title="2.可重定位装入"></a>2.可重定位装入</h5><ul><li>在多道程序下，目标的起始地址通常从0开始，程序其他地址也相对于起始地址计算，装入时可采用可重定位装入</li><li>在可执行文件中，列出需要重定位的地址单元和相对地址值（表）最后根据定位的内存地址修改重定位地址项，添加偏移量。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-5.jpg" alt></p><p>优点</p><ul><li>不需要硬件支持，可以装入有限多道程序</li></ul><p>缺点：</p><ul><li>一个程序需要连续的地址空间，程序装入后不能移动，不易共享</li></ul><p>地址变换是由装入程序在装入目标模块时一次完成，装入后内存不能移动，故称为静态重定位。</p><h5 id="3-动态运行时装入"><a href="#3-动态运行时装入" class="headerlink" title="3.动态运行时装入"></a>3.动态运行时装入</h5><ul><li>程序开始执行时未全部装入内存，而是部分装入，运行时需要什么模块再装什么模块</li><li>程序装入内存后不直接将相对地址转换为直接地址，等到真正执行是再转换，即动态重定位</li><li><font color="red">装入内存的所有地址都是相对的</font></li></ul><p>优点：</p><ul><li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利于实现共享。</li><li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）</li></ul><p>缺点：</p><ul><li>需要硬件支持（通常是CPU），OS实现较复杂－－是虚拟存储的基础</li></ul><h4 id="4-1-2-程序的链接"><a href="#4-1-2-程序的链接" class="headerlink" title="4.1.2 程序的链接"></a>4.1.2 程序的链接</h4><p>根据链接时间不同，分为三种</p><p>静态链接</p><ul><li>在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。要解决两个问题：<ul><li>修改相对地址</li><li>变换外部调用符号</li></ul></li><li>对多用户、多任务系统显然有冗余，比如多个用户调用了sin(x)，则每个目标代码中都有这部分代码，装入到内存则也都有这部分代码。</li></ul><p>装入时动态链接</p><ul><li>源程序编译得到的目标模块是在装入内存时，边装入边链接的，即在装入一个目标模块时，若发现一个外部模块调用事件，装入程序去找出相应的外部目标模块，并将它装入内存，同时修改相对地址。</li><li>优点<ul><li>共享：多个进程可以共用一个目标模块，节省内存，减少文件交换。</li><li>便于修改和更新。各目标模块是分开存放的，便于修改。</li></ul></li></ul><p>运行时动态链接</p><ul><li>应用程序运行时，每次运行的模块可能不同。但事先又无法知道，运行时动态链接是将某些模块的链接推迟到执行时。即，执行时发现调用的模块未被装入，由OS找到该模块并装入，并将其链接到调用者模块上。</li><li>优点：<ul><li>部分装入：一个进程只将与当前操作相对应的DLL装入内存。</li><li>便于局部代码修改：即便于代码升级和代码重用；只要函数的接口参数（输入和输出）不变，则修改函数及其DLL，无需对可执行文件重新编译或链接。</li><li>便于适应运行环境：调用不同的DLL，就可以适应多种使用环境和提供不同功能。如：不同的显示卡只需厂商为其提供特定的DLL，而OS和应用程序不必修改。</li></ul></li><li>缺点：<ul><li>链接开销：增加了程序执行时的链接开销；</li><li>管理开销：程序由多个文件组成，增加管理复杂度。 </li></ul></li></ul><h5 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h5><p><img src="/2020/08/18/OS-ch-4/4.1-6.jpg" alt></p><h5 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h5><p>在<font color="red">用户模式</font>中验证产生的地址，如果发现不好的地址，中断进入内核</p><h3 id="4-2-连续分配存储管理方式"><a href="#4-2-连续分配存储管理方式" class="headerlink" title="4.2 连续分配存储管理方式"></a>4.2 连续分配存储管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul><li>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。未采取存储保护措施。</li><li>最简单，适用于单用户、单任务的OS。CP/M和MS-DOS </li><li>优点：<ul><li>易于管理。</li></ul></li><li>缺点：<ul><li>对要求内存空间少的程序，造成内存浪费；</li><li>程序全部装入，很少使用的程序部分也占用内存固定分区分配</li></ul></li></ul><h5 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h5><p>为了支持多道程序系统和分时系统，支持多个程序并发执行</p><p>吧内存分为大小相等或不等的区，操作系统占用一个，其余给应用程序，应用程序占用一个或几个</p><h5 id="内碎片和外碎片"><a href="#内碎片和外碎片" class="headerlink" title="内碎片和外碎片"></a>内碎片和外碎片</h5><p>内：占用分区内未被利用的空间</p><p>外：占用分区之间难以利用的小空闲分区</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul><li>最简单的一种运行多道程序的存储管理方式</li><li>把内存划分为若干个固定大小的连续分区，每个分区只装入一个作业。</li><li>划分分区的方法<ul><li>分区大小相等：只适合于多个相同进程的并发执行（处理多个类型相同的对象）。</li><li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-1.jpg" alt></p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><img src="/2020/08/18/OS-ch-4/4.2-2.jpg" alt></p><ul><li><p>动态分区分配是指OS根据进程的实际需要为各进程分配连续的物理内存。</p><ul><li>分区分配中的数据结构</li><li>为了管理内存空闲分区建立了空闲分区表或空闲分区链表。</li><li>表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。  </li><li>分区表中，表项数目随着内存的分配和释放而动态改变，可以规定最大表项数目。</li><li>分区表可以划分为两个表格：空闲分区表和占用分区表。从而减小每个表格长度。空闲分区表中按不同分配算法对表项排序。</li></ul></li><li><p>分区分配算法：</p><ul><li>某个新作业装入内存，需寻找一个空闲分区，其大小需大于或等于进程的要求。</li><li>若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。</li></ul></li></ul><h5 id="首次适应算法："><a href="#首次适应算法：" class="headerlink" title="首次适应算法："></a>首次适应算法：</h5><ul><li>按分区的先后次序，从头查找，找到符合要求的第一个分区。</li><li>该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。</li><li>但随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。</li></ul><h5 id="循环适应算法："><a href="#循环适应算法：" class="headerlink" title="循环适应算法："></a>循环适应算法：</h5><ul><li>按分区的先后次序，从上次分配的分区的下一个位置开始查找（到最后一个分区时再回到开头），找到符合要求的第一个分区。</li><li>实现算法，要设置起始查询指针。</li><li>该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。</li></ul><h5 id="最佳适应法-best-fit"><a href="#最佳适应法-best-fit" class="headerlink" title="最佳适应法(best-fit)"></a>最佳适应法(best-fit)</h5><ul><li>找到其大小与要求相差最小的空闲分区。</li><li>为了加速寻找，该算法要求空闲分区表将空闲分区按容量由小到大排序。</li><li>从个别来看，外碎片较小，但从整体来看，会形成较多外碎片。较大的空闲分区可以被保留。 </li></ul><h5 id="最坏适应法-worst-fit"><a href="#最坏适应法-worst-fit" class="headerlink" title="最坏适应法(worst-fit)"></a>最坏适应法(worst-fit)</h5><ul><li>找到最大的空闲分区。</li><li>算法要求空闲分区表将空闲分区按容量由大到小排序。</li><li>基本不留下小空闲分区，但较大的空闲分区不被保留。 </li></ul><h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><ul><li>又称分类搜索法。</li><li>将空闲分区根据容量大小分类，每类分区容量相同。为每类分区</li><li>设立一个空闲分区链表。系统中设立一张管理索引表，每个表项</li><li>记录的是每类空闲分区链表的表头。</li><li>优点：<ul><li>查找空闲分区效率高。</li><li>能保留大分区。</li></ul></li><li>缺点：<ul><li>回收分区时，系统开销大。</li><li>空闲分区划分越细，浪费则越严重。</li></ul></li></ul><h4 id="动态重定位分区分配"><a href="#动态重定位分区分配" class="headerlink" title="动态重定位分区分配"></a>动态重定位分区分配</h4><h4 id="4-2-3-动态分区分配"><a href="#4-2-3-动态分区分配" class="headerlink" title="4.2.3 动态分区分配"></a>4.2.3 动态分区分配</h4><p>分区分配操作 </p><ul><li>分配内存<ul><li>利用某种分配算法，从空闲分区表（链）中找到所需大小的分区</li></ul></li><li>回收内存，有以下四种情况：<ul><li>与前一个空闲分区相邻</li><li>与后一个空闲分区相邻</li><li>与前、后空闲分区都相邻</li><li>不与任何空闲分区相邻</li></ul></li></ul><h4 id="4-2-4-伙伴系统"><a href="#4-2-4-伙伴系统" class="headerlink" title="4.2.4 伙伴系统"></a>4.2.4 伙伴系统</h4><p>伙伴系统方式是动态分区分配和固定分区分配的一种折中方案。</p><p>伙伴系统规定，分区分配大小都是$2^k$ k为整数，1&lt;=k&lt;=m 2^m可以是整个内存的大小。系统中也要建立一个索引管理表，指明每个链表表头。</p><h5 id="分区分配方法："><a href="#分区分配方法：" class="headerlink" title="分区分配方法："></a>分区分配方法：</h5><ul><li>开始时，整个分区是2m，在系统运行过程中，由于不断划分，可能会形成若干不连续的空闲分区，将它们分类，每一类具有相同大小，且每类建立一个空闲分区双向链表，系统中有若干个双向链表。</li><li>当需要为进程分配大小为n的区块时，首先计算一个i，使2i-1≤n ≤2i，然后在大小为2i的空闲分区链表中查找。</li></ul><h5 id="分区回收："><a href="#分区回收：" class="headerlink" title="分区回收："></a>分区回收：</h5><ul><li>若回收大小为2i的分区，若有伙伴分区，则合并为2i+1的分区，进而可能需要合并为2i+2的分区……</li><li>算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-3.jpg" alt></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>快速搜索合并</li><li>低外部碎片</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>内部碎片。</li><li>因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。 </li></ul><h4 id="4-2-5-可重定位分区分配"><a href="#4-2-5-可重定位分区分配" class="headerlink" title="4.2.5 可重定位分区分配"></a>4.2.5 可重定位分区分配</h4><p>当内存驻留多个进程时，分配一个区后大部分情况下都是有剩余零头的，因此在一个新作业到达时，就有可能零头分区的总和超过新作业要求的分区，但每一个空闲分区的容量都不够。</p><p>1.紧凑</p><ul><li><p>将各个占用分区向内存一段移动，使各个空闲分区聚集在另一端，合并为一个较大的空闲分区。</p></li><li><p>对占用分区进行内存数据搬移占用CPU时间，如果对占用分区中的程序进行浮动，则其重定位需要硬件支持。</p></li><li><p><font color="red">何时执行</font>：每个分区释放后或内存找不到满足条件的空闲分区。</p></li></ul><h5 id="动态重定位分区分配算法"><a href="#动态重定位分区分配算法" class="headerlink" title="动态重定位分区分配算法"></a>动态重定位分区分配算法</h5><p><img src="/2020/08/18/OS-ch-4/4.2-4.jpg" alt></p><h4 id="4-2-6-覆盖"><a href="#4-2-6-覆盖" class="headerlink" title="4.2.6 覆盖"></a>4.2.6 覆盖</h4><p>为了在较小的可用内存中运行较大的程序</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>程序必要部分常驻内存</li><li>不常用功能用其余模块实现，不使用时放外存，使用时放内存</li><li>不存在调用关系的模块不封装到内存，从而实现互相覆盖。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>程序员需要给程序分块并确定覆盖关系，增加复杂度</li><li>进程在执行过程中要从外存装入，速度慢，用时间换空间</li></ul><h4 id="4-2-7-对换"><a href="#4-2-7-对换" class="headerlink" title="4.2.7 对换"></a>4.2.7 对换</h4><ul><li><p>内存中有进程处于堵塞态，另一方面有就绪进程在外存等待</p></li><li><p>对换将暂时不能执行的程序或数据送到外存中，获得空闲内存来装入具备运行条件的进程或所需要的程序和数据</p></li><li><p>进程暂时不能执行原因</p><ul><li>阻塞态</li><li>低优先级</li></ul></li><li><p>交换单位为整个进程的地址空间</p></li><li><p>小型系统中与可重定位分区分配存储管理配合使用，称作roll in/roll out</p></li><li><p>加快进程换入，换出速度，因此采用连续分配，较少考虑碎片问题</p></li><li><p>建立磁盘的对换区，内存有空时找出就绪且换出时间最久的进程换入内存</p></li><li><p>优点</p><ul><li>增加并行进程数目，给用户适当响应时间，提高吞吐率</li></ul></li><li><p>缺点</p><ul><li>对换入换出的控制增加处理机开销，没有考虑执行过程中地址访问的统计特性</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-5.jpg" alt></p><h3 id="4-3-基本分页存储管理方式"><a href="#4-3-基本分页存储管理方式" class="headerlink" title="4.3 基本分页存储管理方式"></a>4.3 基本分页存储管理方式</h3><h4 id="连续分配问题"><a href="#连续分配问题" class="headerlink" title="连续分配问题"></a>连续分配问题</h4><ul><li>形成外碎片和内碎片</li><li>近凑带来开销</li></ul><h4 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h4><ul><li>基本单位是页：分页存储管理</li><li>是段：分段存储管理</li><li>分页存储管理不支持虚存技术，要求吧整个作业装入内存才能运行。</li></ul><h4 id="在页式管理中："><a href="#在页式管理中：" class="headerlink" title="在页式管理中："></a>在页式管理中：</h4><ul><li>内存化为固定大小的页框，也叫页帧，物理页框</li><li>进程的逻辑地址页分为同样大小的页，程序加载时需要分配所需全部页，这些页不必连续</li><li>固定：计算机系统的内存容量固定，一个页容量也是固定的</li></ul><h4 id="进程装载："><a href="#进程装载：" class="headerlink" title="进程装载："></a>进程装载：</h4><ul><li><p>装入进程时，找空闲页框，OS将页框分配给装入过程，每个页占用一个页框，进程占用的所有页框不要求连续</p></li><li><p>要解决逻辑地址到物理地址的映像需要硬件支持。</p></li></ul><h4 id="基本分页管理中的数据结构"><a href="#基本分页管理中的数据结构" class="headerlink" title="基本分页管理中的数据结构"></a>基本分页管理中的数据结构</h4><ul><li>进程页表：每个进程有一个页表，描述该进程的每个逻辑页占用的物理页框号。</li><li>物理页面表：整个系统有一个物理页面表，描述所有物理页框的分配使用状况。数据结构：位示图，空闲页面链表；</li><li>请求表：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换；</li><li>请求表也可以结合到各进程的PCB里，此时在PCB中记录本进程页表所在的物理页框号。上下文切换时，由OS将其加载到页表寄存器中。</li></ul><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p><img src="/2020/08/18/OS-ch-4/4.3-1.jpg" alt></p><h4 id="页面大小的选择"><a href="#页面大小的选择" class="headerlink" title="页面大小的选择"></a>页面大小的选择</h4><ul><li>和目前计算机的物理内存大小有关：2n。</li><li>较小的页面，减小内碎片，但加大页表的长度，从而形成新的开销并增加换入、换出的开销；</li><li>较大的页面，减小页表的长度，加大内碎片；管理开销小，交换时对外存I/O效率高。</li><li>两者的折中。</li></ul><h4 id="页式管理的优缺点"><a href="#页式管理的优缺点" class="headerlink" title="页式管理的优缺点"></a>页式管理的优缺点</h4><p>优点：</p><ul><li>没有外碎片，每个内碎片不超过页大小。</li><li>一个程序不必连续存放。便于改变程序占用空间的大小（主要指随着程序运行而动态生成的数据增多，要求地址空间相应增大，通常由系统调用完成而不是操作系统自动完成）。</li></ul><p>缺点：</p><ul><li>程序全部装入内存。</li></ul><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>逻辑上连续的目标程序在物理内存中已经不能保证连续存放，支持页式管理的机器硬件上都有一套地址变换机构完成逻辑地址到物理地址的变换。<br>逻辑地址分为两部分：逻辑页号，页内偏移地址；<br>通过查进程页表，得物理页号，从而形成物理地址。</p><h4 id="4-3-2快表"><a href="#4-3-2快表" class="headerlink" title="4.3.2快表"></a>4.3.2快表</h4><h4 id="4-3-3-两级和多级页表"><a href="#4-3-3-两级和多级页表" class="headerlink" title="4.3.3 两级和多级页表"></a>4.3.3 两级和多级页表</h4><h3 id="4-4-基本分段存储管理"><a href="#4-4-基本分段存储管理" class="headerlink" title="4.4 基本分段存储管理"></a>4.4 基本分段存储管理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理&lt;/h2&gt;&lt;p&gt;用户程序的主要处理阶段&lt;/p&gt;
&lt;p&gt;连续分配方式&lt;/p&gt;
&lt;p&gt;离散分配方式&lt;/p&gt;
&lt;p&gt;虚拟存储器的基本特征&lt;
      
    
    </summary>
    
    
    
      <category term="-OS -操作系统 -ch3" scheme="http://yokeso.top/tags/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-ch3/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-3</title>
    <link href="http://yokeso.top/2020/08/17/OS-ch-3/"/>
    <id>http://yokeso.top/2020/08/17/OS-ch-3/</id>
    <published>2020-08-17T08:25:30.000Z</published>
    <updated>2020-08-17T17:06:58.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><p>多道程序下，进程数目往往多于处理机数目。需要系统按某种算法动态将处理机分配给就绪队列中的进程，使之执行。</p><h3 id="3-1-处理机调度层次"><a href="#3-1-处理机调度层次" class="headerlink" title="3.1 处理机调度层次"></a>3.1 处理机调度层次</h3><h5 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h5><ul><li>又称作业调度或长期调度，根据某种算法决定将处于外存上后备队列的哪些作业调入内存</li><li>作业：利用计算机进行一次运行所需工作的集合，要完成一个工作要先提交一次作业。一个作业可能由多个程序构成。</li><li>PC机或者普通工作站和服务器上几乎没有作业的概念。</li></ul><h5 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h5><ul><li>也称进程调度或短期调度，用于决定就绪队列中哪个进程获得处理机，之后派发程序将处理机分配给进程。</li></ul><h5 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h5><p>1）非抢占式调度</p><ul><li>一旦把处理机分配给某进程后，便让进程一直执行，直到进程阻塞，再把处理机分配给其他进程</li></ul><p>2）抢占式调度</p><ul><li>允许暂停一个正在执行的进程，将处理机分配给另一进程。<ul><li>时间片轮转分给进程的时间片用完</li><li>按照优先级调度，更高级优先权就绪</li><li>短作业优先原则</li></ul></li></ul><h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><ul><li>条件允许的情况下，在外存挂起的进程集合中选择哪些进程激活并调回内存。</li><li>提高效率，加快运行，调节复合，提高吞吐量。</li><li>有时需要选择内存或者就绪的进程放在外存中，叫做挂起</li><li>这些进程具备运行条件，内存稍有空闲时，中级调度把这些放入就绪队列，叫做对换。</li></ul><h5 id="三种调度之间的关系"><a href="#三种调度之间的关系" class="headerlink" title="三种调度之间的关系"></a>三种调度之间的关系</h5><p><img src="/2020/08/17/OS-ch-3/3.1-1.jpg" alt></p><h4 id="3-1-2-调度队列模型"><a href="#3-1-2-调度队列模型" class="headerlink" title="3.1.2 调度队列模型"></a>3.1.2 调度队列模型</h4><h5 id="1-仅有进程调度"><a href="#1-仅有进程调度" class="headerlink" title="1.仅有进程调度"></a>1.仅有进程调度</h5><p><img src="/2020/08/17/OS-ch-3/3.1-2.jpg" alt></p><h5 id="2-具有高级和低级的调度队列模型"><a href="#2-具有高级和低级的调度队列模型" class="headerlink" title="2.具有高级和低级的调度队列模型"></a>2.具有高级和低级的调度队列模型</h5><p><img src="/2020/08/17/OS-ch-3/3.1-3.jpg" alt></p><h5 id="3-同时具有三级调度的模型"><a href="#3-同时具有三级调度的模型" class="headerlink" title="3.同时具有三级调度的模型"></a>3.同时具有三级调度的模型</h5><p><img src="/2020/08/17/OS-ch-3/3.1-4.jpg" alt></p><h4 id="3-1-3-选择调度方式和算法的若干法则"><a href="#3-1-3-选择调度方式和算法的若干法则" class="headerlink" title="3.1.3 选择调度方式和算法的若干法则"></a>3.1.3 选择调度方式和算法的若干法则</h4><p>处理机调度算法的性能可以从不同角度去看，所以是一个综合的判断结果。</p><h5 id="面向用户"><a href="#面向用户" class="headerlink" title="面向用户"></a>面向用户</h5><ul><li>周转时间短</li><li>响应时间快</li><li>截至时间保证</li><li>优先权准则</li></ul><h5 id="面向系统"><a href="#面向系统" class="headerlink" title="面向系统"></a>面向系统</h5><ul><li>吞吐量高</li><li>处理机利用率好</li><li>资源平衡利用</li></ul><h5 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h5><p>作业从提交到完成所经历的时间（后备队列等待，CPU执行，就绪队列，阻塞队列等待，结果输出）</p><p>平均周转时间：<br>$$<br>T=\frac{1}{n}\sum_{i=1}^{n}T_i<br>$$<br>带权周转时间<br>$$<br>W=\frac{1}{n}\sum_{i=1}^{n}\frac{T_i}{T_{si}}<br>$$<br>例：下面三道作业的平均周转时间和平均带权周转时间</p><table><thead><tr><th align="center">作业</th><th align="center">提交时间/时</th><th align="center">运行时间/h</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">10.00</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">10.10</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">10.25</td><td align="center">0.25</td></tr></tbody></table><p><img src="/2020/08/17/OS-ch-3/3.1-5.jpg" alt></p><p>平均周转时间：<br>$$<br>T=\frac{2+2.9+3}{3}=2.63h<br>$$<br>平均带权周转时间：<br>$$<br>W=\frac{2+2.9+12}{3}=5.3h<br>$$</p><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><ul><li>分时系统的重要指标</li><li>用户输入一个请求到系统首次响应的时间</li></ul><h5 id="截至时间"><a href="#截至时间" class="headerlink" title="截至时间"></a>截至时间</h5><ul><li>实时系统重要指标</li><li>分为开始截至时间和完成截至时间</li><li>某任务必须<font color="red">开始执行的最迟时间</font>或者<font color="red">必须完成的最迟时间</font></li></ul><h5 id="优先权原则"><a href="#优先权原则" class="headerlink" title="优先权原则"></a>优先权原则</h5><ul><li>批处理，分时，实时系统都可遵循</li><li>可以使关键人物达到最好目标</li><li>公平性：不会因为进程本身的特性使上述指标过分恶化</li></ul><h5 id="面向系统准则"><a href="#面向系统准则" class="headerlink" title="面向系统准则"></a>面向系统准则</h5><ul><li><p>吞吐量</p><ul><li>批处理系统的重要指标</li><li>吞吐量指时间内完成的作业数，和作业本身特性或者调度算法都有关系</li></ul></li><li><p>处理及利用率高</p><ul><li>大中型主机多用户系统指标，PC一般不考虑</li></ul></li><li><p>各种资源平衡利用</p><ul><li>大中型多用户系统性能指标。如CPU繁忙的作业和I/O繁忙</li></ul></li></ul><h5 id="调度算法本身的调度性能准则"><a href="#调度算法本身的调度性能准则" class="headerlink" title="调度算法本身的调度性能准则"></a>调度算法本身的调度性能准则</h5><ul><li>易于实现</li><li>执行开销比</li></ul><h3 id="3-2-调度算法"><a href="#3-2-调度算法" class="headerlink" title="3.2 调度算法"></a>3.2 调度算法</h3><p>OS中的调度实质时一种资源分配</p><p>有的调度算法使用于作业调度，有的算法适用与作业调度，有的两者都适应。</p><h4 id="3-2-1-先来先服务和短作业优先算法"><a href="#3-2-1-先来先服务和短作业优先算法" class="headerlink" title="3.2.1 先来先服务和短作业优先算法"></a>3.2.1 先来先服务和短作业优先算法</h4><h5 id="FCFS算法"><a href="#FCFS算法" class="headerlink" title="FCFS算法"></a>FCFS算法</h5><ul><li><p>算法描述</p><ul><li>按照作业或者进程变为就绪态的先后顺序，分派CPU，当前作业或进程占用CPU，直到执行完或阻塞才让出（非抢占）</li><li>在作业或进程唤醒后，不立即恢复执行，而是排队，</li><li>是最简单的算法</li></ul></li><li><p>FCFS的特点</p><ul><li>有利长作业，不利短作业</li><li>有利于CPU繁忙，不利于IO繁忙</li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.2-1.jpg" alt></p><h5 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h5><ul><li><p>算法描述</p><ul><li>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业</li><li>是对FCFS算法的改进，目标是减少平均周转时间</li></ul></li><li><p>SJF的特点</p><ul><li>优点<ul><li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业等待时间</li><li>提高系统吞吐量</li></ul></li><li>缺点<ul><li>对长作业不利，可能长时间得不到执行</li><li>未能依据作业的紧迫程度来划分优先级</li><li>难以准确估计作业（进程）的执行时间，从而影响调度性能</li></ul></li></ul></li></ul><p>SJF的变形：<br>最短剩余时间优先 SRT（允许比当前进程剩余时间更短的进程来抢占）</p><p>最高相应比优先 HRRN （相应比R=（等待时间+要求执行时间）/要求执行时间，FCFS和SJF的折中）</p><h4 id="3-2-2优先权调度算法"><a href="#3-2-2优先权调度算法" class="headerlink" title="3.2.2优先权调度算法"></a>3.2.2优先权调度算法</h4><p>本算法适用于祖业调度和进程调度</p><p>算法用于作业调度时，系统从后备队列中选择优先权最高的作业装入内存</p><p>用于进程调度，系统吧处理机派发给就绪队列中优先权的最高进程</p><ul><li><p>抢占式：当前进程时间片未用完时就可被优先级更高的进程抢占CPU</p></li><li><p>非抢占式：除非自愿或时间片到，当前进程不可被优先级更高的进程抢用CPU</p></li><li><p>可抢占程度越高，对实时系统满足越好</p></li></ul><p><img src="/2020/08/17/OS-ch-3/3.2-2.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.2-3.jpg" alt></p><p>优先权的类型</p><p>静态优先级</p><ul><li><p>创建进程时就确定，直到进程终止前都不改变。通常是一个整数。</p></li><li><p>依据：</p><ul><li>进程类型（系统进程优先级较高）</li><li>对资源的需求（对CPU和内存需求较少的进程，优先级较高）</li><li>用户要求（紧迫程度和付费多少） </li></ul></li><li><p>特点：</p><ul><li>简单，系统开销小</li><li>不精确，仅在要求不高的系统中使用</li></ul></li><li><p>动态优先级</p></li><li><p>在创建进程时赋予的优先级，在进程运行过程中可以自动改变，以便获得更好的调度性能。</p></li><li><p>如：</p><ul><li>在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；</li><li>进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU。 </li></ul></li></ul><h5 id="高响应比优先调度算法-HRRN-HRN"><a href="#高响应比优先调度算法-HRRN-HRN" class="headerlink" title="高响应比优先调度算法(HRRN,HRN)"></a>高响应比优先调度算法(HRRN,HRN)</h5><ul><li><p>响应比R<br>   = (等待时间 + 要求执行时间) / 要求执行时间<br>   ＝1＋等待时间/要求执行时间</p></li><li><p>是FCFS和SJF的折衷：</p><ul><li>作业等待时间相同，服务时间越短，优先权越高–SJF；</li><li>要求服务时间相同，等待时间越长，优先权越高–FCFS；长作业随着等待时间的增加，优先权增加。 </li></ul></li><li><p>缺点：</p><ul><li>响应比的计算增加系统开销</li></ul></li></ul><h4 id="3-2-3基于时间片的轮转调度算法"><a href="#3-2-3基于时间片的轮转调度算法" class="headerlink" title="3.2.3基于时间片的轮转调度算法"></a>3.2.3基于时间片的轮转调度算法</h4><p>时间片轮转法（Round Robin, RR)</p><ul><li>本算法主要用于微观调度（进程调度）</li><li>设计目标是提高资源利用率</li><li>基本思路是通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率 </li></ul><p>算法描述</p><ul><li>将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li><li>每次调度时将CPU分派给队首进程，让其执行一个时间片。在一个时间片结束时，发生时钟中断。调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</li><li>时间片的长度从几个ms到几百ms。</li><li>进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li></ul><p>时间片长度的确定</p><ul><li>时间片长度变化的影响<ul><li>过长－&gt;退化为FCFS算法</li><li>过短－&gt;用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长。</li></ul></li><li>就绪进程的数目：数目越多，时间片越小</li><li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li></ul><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p><p>1) 算法描述</p><ul><li>设置多个就绪队列，分别赋予不同的优先级，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长。</li><li>假设有三个就绪队列：<ul><li>Q1－－时间片为8</li><li>Q2－－时间片为16</li><li>Q3－－FCFS</li></ul></li><li>新进程进入内存后，先投入队列1的末尾，若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，若仍未完成，降低到最后的队列，按FCFS算法调度直到完成。</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。</li></ul><p>2）算法性能</p><ul><li>终端型进程：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，可处理完一次I/O请求的数据，然后转入到阻塞队列。</li><li>计算型进程（长批处理作业）：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。<br>短批处理作业：  先放入第1级，一般经过1，2级即可完成。</li></ul><p>3）优点：</p><ul><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li><li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li><li>不必估计进程的执行时间，动态调节</li></ul><h3 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h3><h4 id="3-4-1实现实时调度的基本条件"><a href="#3-4-1实现实时调度的基本条件" class="headerlink" title="3.4.1实现实时调度的基本条件"></a>3.4.1实现实时调度的基本条件</h4><ul><li>提供必要信息（就绪时间，开始截至时间，资源要求，优先级）</li><li>系统处理能力强:    单处理机： $\sum_{i=1}^{m}\frac{C_i}{P_i}&lt;=1$，多处理机： $\sum_{i=1}^{m}\frac{C_i}{P_i}&lt;=N$</li><li>采用抢占式调度机制</li><li>具有快速切换机制 （快速响应中断，快速任务分派）</li></ul><h4 id="3-4-2-实时调度算法分类"><a href="#3-4-2-实时调度算法分类" class="headerlink" title="3.4.2 实时调度算法分类"></a>3.4.2 实时调度算法分类</h4><h5 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h5><p>1） 基于时钟中断的抢占式优先权调度算法</p><ul><li>在某实时任务到达后，若其优先级高于占有处理机的进程优先级，并不抢占，等到时钟中断到达时再抢占。<br>调度延迟可降为几十至几毫秒。</li></ul><p>2）立即抢占</p><ul><li>操作系统具有快速响应外部中断的能力。一旦出现外部中断，只要当前进程未处于临界区，立即抢占CPU。</li></ul><h5 id="非抢占式优先调度算法"><a href="#非抢占式优先调度算法" class="headerlink" title="非抢占式优先调度算法"></a>非抢占式优先调度算法</h5><ul><li>要求严格的任务赋予高优先级，执行后其他任务才能调度执行</li></ul><h4 id="3-4-3-常用的几种实时调度算法"><a href="#3-4-3-常用的几种实时调度算法" class="headerlink" title="3.4.3 常用的几种实时调度算法"></a>3.4.3 常用的几种实时调度算法</h4><ol><li>最早截止时间优先 EDF（Earliest Deadline First）</li></ol><ul><li>根据任务的开始截止时间确定任务的优先级。具有最早截止时间的任务排在队列的最前面。</li><li>即可用于抢占式调度，又可用于非抢占式调度。</li></ul><ol start="2"><li>最低松弛度优先LLF（Least Laxity First）算法</li></ol><ul><li>任务的紧急程度愈高，该任务的优先级愈高。</li><li>松弛度 = 必须完成时间-本身运行时间-当前时间</li><li>如，t=0时，某任务在200ms时必须完成，他本身执行的时间是100ms，则其松弛度为100ms。</li><li>LLF算法按松弛度排就绪队列，松弛度最低的排在队列最前面，优先被调度执行。</li><li>LLF主要用于可抢占调度方式中。</li></ul><h3 id="3-5-死锁产生的原因和必要条件"><a href="#3-5-死锁产生的原因和必要条件" class="headerlink" title="3.5 死锁产生的原因和必要条件"></a>3.5 死锁产生的原因和必要条件</h3><p>死锁：多个进程争夺共享资源出现的僵局。</p><p>产生原因：</p><ul><li>竞争资源(不可剥夺资源)<ul><li>资源数目不能满足进程需要</li><li>双方都有部分资源，同时请求对方已占有的资源</li><li>硬件中的中断，信号，消息，缓冲区数据</li></ul></li><li>顺序不当<ul><li>进程运行过程中，请求和释放资源顺序不当</li><li>多个进程并发执行，相互的推进顺序不确定，可能会导致两种结果：不出现死锁和出现死锁。</li></ul></li></ul><h4 id="3-5-2-产生死锁的必要条件"><a href="#3-5-2-产生死锁的必要条件" class="headerlink" title="3.5.2 产生死锁的必要条件"></a>3.5.2 产生死锁的必要条件</h4><p>只有4个条件都满足时，才会出现死锁。</p><ul><li>互斥：任一时刻只允许一个进程使用资源</li><li>请求和保持：进程保持了至少一个资源，但又提出了新的资源请求，该资源又被其他进程占用。</li><li>不剥夺：进程已经占用的资源，未使用完，不能被剥夺。</li><li>环路等待：存在进程－资源环形链，即有进程集合{P0, P1, P2,….Pn},P0等待P1占用的资源，P1等待P2占用的资源…..Pn等待P0占用的资源。    </li></ul><h4 id="3-5-3-处理死锁办法"><a href="#3-5-3-处理死锁办法" class="headerlink" title="3.5.3 处理死锁办法"></a>3.5.3 处理死锁办法</h4><ul><li>预防死锁<ul><li>采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不同时满足死锁的四个必要条件</li></ul></li><li>避免死锁<ul><li>在资源的动态分配过程中，防止系统进入不安全状态。</li></ul></li><li>检测死锁<ul><li>允许系统进入死锁，但系统及时检测，并采取措施。</li></ul></li><li>解除死锁<ul><li>当检测到系统进入了死锁，采取措施解除。</li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.6-1.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.6-2.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.6-3.jpg" alt></p><h4 id="3-6-2-系统的安全状态"><a href="#3-6-2-系统的安全状态" class="headerlink" title="3.6.2 系统的安全状态"></a>3.6.2 系统的安全状态</h4><p>系统按某种进程顺序为进程分配资源，直至达到进程的最大需求，使每个进程都可以顺利完成。</p><p>无法找到安全序列则称系统处于不安全状态</p><h4 id="3-6-3-避免死锁-银行家算法"><a href="#3-6-3-避免死锁-银行家算法" class="headerlink" title="3.6.3 避免死锁-银行家算法"></a>3.6.3 避免死锁-银行家算法</h4><p>银行家算法（Dijkstra, 1965）问题</p><ul><li>在银行中，客户申请贷款的数量是有限的。银行家应尽量满足所有客户的贷款需求。</li><li>银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</li></ul><p>为保证资金的安全，银行家规定：</p><ul><li>当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客(试探性分配) </li><li>顾客可以分期贷款，但贷款的总数不能超过最大需求量(可能一次并不能满足所需要的全部资源) </li><li>当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款(不存在死锁) </li><li>当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金(运行后释放) </li></ul><h5 id="1-银行家算法中的数据结构"><a href="#1-银行家算法中的数据结构" class="headerlink" title="1.银行家算法中的数据结构"></a>1.银行家算法中的数据结构</h5><p>设系统中共有n个进程，m类资源<br>(1) 可利用资源向量Available[m]。<br>       若Available[i]＝k，表示系统中Ri类资源有k个。<br>(2) 最大需求矩阵Max[n,m]<br>       若Max[i,j]=k，表示进程 i 需要Rj类资源k个。<br>(3) 分配矩阵Allocation[n,m]<br>       若Allocation[i,j] = k，表示进程 Pi 现在拥有 Rj 类型的资源k个。<br>(4)需求矩阵Need[n,m]<br>       若 Need[i,j] = k，表示进程 Pi 最多还需要Rj类型的资源k个，它才能完成任务<br>       Need[i,j]=Max[i,j]– Allocation[i,j]</p><ol start="2"><li><h5 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h5></li></ol><p>Requesti为进程 Pi 的请求向量。如果 Requesti [j] = k ，表示进程 Pi 需要Rj类型资源k个。</p><ol><li><p>如果 Requesti  Needi ，转去执行第2步。否则产生错误，因为进程对资源的请求已经超过它事先声明的最大数量。</p></li><li><p>如果 Requesti  Available，转去执行第3步。 否则进程Pi必须等待，因为现有资源不够分配。</p></li><li><p>假设将进程 Pi 请求的资源分配给它，并按如下方式修改状态<br>Available = Available – Requesti<br>Allocationi = Allocationi + Requesti<br>Needi = Needi – Requesti<br>则系统进入新状态，用安全算法验证新状态是安全的。<br>如果安全 -&gt;  将资源分配给进程 Pi，系统进入新状态。<br>如果不安全 -&gt;  进程 Pi必须等待，系统保持原状态。</p></li><li><h5 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h5><p>(1)Work 和 Finish 分别是长度为m 和 n 的向量， 分别初始化为：</p><pre><code>Work = AvailableFinish[i]=false (i = 1,3, …, n)</code></pre><p>(2)查找这样的 i 使其满足：</p><pre><code>(a) Finish [i] = false(b) Needi  Work如果没有这样的 i 存在就转去执行第4步</code></pre><p>(3)Work = Work + Allocationi</p><p>​    Finish[i] = true  </p><p>​    转去执行第2步<br>(4)如果对所有的i，Finish[i]==true ，那么系统是安全的。否则，系统处于不安全状态。</p></li></ol><p><strong>例子详见PPT</strong></p><ol start="4"><li><h5 id="银行家算法特点"><a href="#银行家算法特点" class="headerlink" title="银行家算法特点"></a>银行家算法特点</h5></li></ol><ul><li>允许互斥、部分分配和不可抢占，可提高资源利用率；</li><li>要求事先说明最大资源要求，在现实中很困难。</li></ul><h3 id="3-7-死锁的检测和解除"><a href="#3-7-死锁的检测和解除" class="headerlink" title="3.7 死锁的检测和解除"></a>3.7 死锁的检测和解除</h3><p>系统为进程分配资源时，若未采取避免和预防死锁的措施，系统必须提供检测和解除死锁的手段。即：</p><ul><li>保存资源的请求和分配信息</li><li>利用某种算法对这些信息加以检查，以判断是否存在死锁。</li></ul><h5 id="1-资源分配图"><a href="#1-资源分配图" class="headerlink" title="1. 资源分配图"></a>1. 资源分配图</h5><p><img src="/2020/08/17/OS-ch-3/3.7-1.jpg" alt></p><h5 id="2-死锁定理"><a href="#2-死锁定理" class="headerlink" title="2. 死锁定理"></a>2. 死锁定理</h5><p>资源分配图的化简方法：</p><ul><li>删除既不处于等待状态又不独立的进程的所有弧（包括请求边和分配边），该点变为孤立点。</li><li>重复上述过程，若最后所有进程结点是孤立点，则称该资源图是完全可简化的，否则是不可完全简化的</li></ul><p>死锁定理：S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化。其中的有边进程为死锁进程。</p><h5 id="3-死锁检测算法"><a href="#3-死锁检测算法" class="headerlink" title="3. 死锁检测算法"></a>3. 死锁检测算法</h5><p>1）检测算法中的数据结构<br>    设系统中有n个进程，m类资源<br>    Available:长度为 m 的向量，表示各种类型资源的可用实例数<br>    Allocation:为 n  m 矩阵，表示目前已分配给各个进程的各种资源的数量<br>    Request:为 n  m 矩阵，表示目前各个进程请求资源的情况。若Request[i,j] = k, 表示进程 Pi 正在请求 k 个类型为Rj的资源。</p><p>2）算法描述<br>    (1)设Work 和 Finish 分别是长度为m 和 n 的向量，各自初始化为：<br>        (a) Work = Available<br>        (b) 对于i = 1,2, …, n，如果 Allocationi  0, 那么Finish[i] = false；否则 Finish[i] = true.<br>    (2) 查找这样的下标 i ，使其满足：<br>        (a) Finish[i] == false</p><p>(3) Work = Work + AllocationiFinish[i] = true转去执行第2步 。<br>(4) 如果对某个i （ 1 &lt;= i &lt;=  n ），若Finish[i] == false，那么系统死锁。 而且，如果 Finish[i] == false，那么进程 Pi 正处于死锁状态。</p><p>该算法需要O(m x n2) 操作来检查系统是否处于死锁状态</p><h5 id="4-死锁检测算法的应用"><a href="#4-死锁检测算法的应用" class="headerlink" title="4.死锁检测算法的应用"></a>4.死锁检测算法的应用</h5><ul><li>何时、以什么样的频率调用检测算法，取决于以下两个因素：<ul><li>可能发生死锁的频率是多少?</li><li>将影响多少进程（重新执行全部或部分代码）?</li></ul></li><li>一旦资源请求不能立刻响应，调用检测算法（开销大）</li><li>固定间隔调用检测算法，例如每小时1次或CPU利用率&lt;40%。</li></ul><h5 id="解除死锁的方法："><a href="#解除死锁的方法：" class="headerlink" title="解除死锁的方法："></a>解除死锁的方法：</h5><ul><li>终止进程<ul><li>代价大，易实现</li><li>一次仅终止一个进程，直到消除环路为止（观察资源执行时间，使用资源数目，以及剩余时间，需求资源数目评断）</li></ul></li><li>剥夺资源<ul><li>选择一个牺牲者<ul><li>代价最小</li></ul></li><li>回退（后退）<ul><li>退回安全状态，在此重新启动进程</li><li>完全回滚：进程终止后重新开始</li></ul></li><li>饿死<ul><li>如果仅仅是基于代价来选择进程的话，某些进程可能会饿死。因此“代价”还应增加一个因素：做牺牲品的次数。</li></ul></li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.7-3.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章-处理机调度与死锁&quot;&gt;&lt;a href=&quot;#第三章-处理机调度与死锁&quot; class=&quot;headerlink&quot; title=&quot;第三章 处理机调度与死锁&quot;&gt;&lt;/a&gt;第三章 处理机调度与死锁&lt;/h2&gt;&lt;p&gt;多道程序下，进程数目往往多于处理机数目。需要系统按某种算法动
      
    
    </summary>
    
    
    
      <category term="-操作系统 -OS -ch3" scheme="http://yokeso.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-ch3/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-2</title>
    <link href="http://yokeso.top/2020/08/14/OS-ch-2/"/>
    <id>http://yokeso.top/2020/08/14/OS-ch-2/</id>
    <published>2020-08-14T13:47:57.000Z</published>
    <updated>2020-08-17T08:18:25.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h2><p>为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进程或线程。</p><h3 id="2-1-进程的基本概念"><a href="#2-1-进程的基本概念" class="headerlink" title="2.1 进程的基本概念"></a>2.1 进程的基本概念</h3><h4 id="2-1-1-程序的基本特征"><a href="#2-1-1-程序的基本特征" class="headerlink" title="2.1.1 程序的基本特征"></a>2.1.1 程序的基本特征</h4><p>程序执行的两种方式：<font color="red">顺序执行</font>和<font color="red">并发执行</font></p><p>(1)顺序执行：单道批处理系统的执行方式：<br><strong>特征</strong>：</p><ul><li><strong>顺序性</strong>：按照程序结构所指定的次序执行。</li><li><strong>封闭性</strong>：独占全部资源，计算机的状态只由于该程序的控制逻辑所决定，结果不受外界因素的影响。</li><li><strong>可再现性</strong>：初始条件相同则结果相同</li></ul><p>(2)为了提高资源利用率并发执行</p><p>特征：</p><ul><li>间断性：程序中途停下来失去原有时序的联系。</li><li>失去封闭性：共享资源受到其他程序控制影响</li><li>失去可再现性：外界环境在程序两次执行期间发生变化</li></ul><p>并发执行条件：达到封闭性和可再现性。</p><h4 id="2-1-2-进程的定义与特征"><a href="#2-1-2-进程的定义与特征" class="headerlink" title="2.1.2 进程的定义与特征"></a>2.1.2 进程的定义与特征</h4><p>进程：一个具有一定独立功能的程序在一个数据集合上一次动态执行的一个过程。</p><p>​            处理机、存储器和外设等资源的分配和回收的基本单位</p><p>一个进程应该包括：</p><ul><li>程序代码</li><li>程序处理的数据，堆栈</li><li>程序计数器中的值，指示下一条将运行的指令</li><li>一组通用的寄存器当前值</li><li>一组系统资源</li></ul><p>进程包括了正在运行的一个程序的所有状态信息。</p><h5 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h5><ul><li><p><strong>程序是产生进程的基础；进程是程序功能的体现。</strong></p></li><li><p><strong>程序是</strong><font color="red">静态</font>实体；进程是<font color="red">动态</font>过程。</p></li><li><p><strong>程序是指令、数据及其组织形式的描述；进程是程序（那些指令和数据）的真正运行实例。</strong></p></li><li><p><strong>进程是暂时的</strong>，是一个状态变化的过程；程序是永久的，可长久保存。</p></li><li><p><strong>通过多次执行，</strong>一个程序可产生多个进程；<strong>通过调用关系</strong>，一个进程可包括多个程序。</p></li><li><p><strong>进程需要一些资源才能完成工作，如</strong>CPU使用时间、存储器、文件以及I/O设备。</p></li></ul><h5 id="进程特征："><a href="#进程特征：" class="headerlink" title="进程特征："></a>进程特征：</h5><ul><li><p>动态性：创建产生，调度执行，受制于资源，撤销消亡。</p></li><li><p>进程具有动态的地址空间（数量和内容），地址空间上包括：代码、数据、进程控制块（PCB）</p></li><li><p>并发性：多个进程同时存在于内存，宏观上同时运行。</p></li><li><p>独立性：资源分配的单位。</p></li><li><p>各进程的地址空间相互独立，除非采用进程间通信手段</p></li><li><p>异步性：进程按各自独立的、不可预知的速度向前推进。</p></li><li><p>结构化：进程实体由代码段，数据段和进程控制块(PCB) 组成。</p><ul><li><p>进程控制块包含在核心区。内存核心段通常存放OS核心部分，由各个进程共享，包括各进程的PCB。</p></li><li><p>程序文件中通常划分为代码段和数据段</p></li></ul></li></ul><h4 id="2-1-3-进程控制块"><a href="#2-1-3-进程控制块" class="headerlink" title="2.1.3 进程控制块"></a>2.1.3 进程控制块</h4><p>描述进程的数据结构：进程控制块（PCB）</p><p>操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p><p><img src="/2020/08/14/OS-ch-2/2.1-1.jpg" alt></p><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB:"></a><strong>PCB</strong>:</h5><ul><li>OS中最重要的结构类型，记录描述进程执行情况以及控制进程运行的全部信息</li><li>进程存在的唯一标志，每个进程在OS中登记的表项，OS通过对PCB的组织管理来对进程进行控制管理。</li><li>进程创建时生成PCB，终止时回收PCB</li><li>PCB常驻于由OS维护的内存核心区，不能由应用程序自身的代码来直接访问，而要通过系统调用间接访问。</li><li>OS专门开辟PCB区将所有的PCB组织成若干个链表或队列。</li></ul><h5 id="PCB中信息："><a href="#PCB中信息：" class="headerlink" title="PCB中信息："></a><strong>PCB中信息</strong>：</h5><ul><li><p>程序描述信息：进程标识符，唯一内部标识符；进程名，外部标识符；本进程的产生者标识(父进程标识)； 用户标识符，以指示拥有该进程的用户。<br>处理机状态信息，保存进程运行现场信息。</p></li><li><p>通用寄存器  8-32个，用户程序可使用的数据、地址等寄存器</p></li><li><p>指令计数器  要访问的下一条指令地址</p></li><li><p>程序状态字PSW  条件码、执行方式、中断屏蔽标志 </p></li><li><p>用户栈指针  用户进程拥有的系统栈，存放过程和系统调用参数及调用地址</p></li><li><p>进程调度信息, 用于操作系统调度进程并占用处理机： </p><ul><li>进程的当前状态； </li><li>优先级(priority)； </li><li>运行统计信息（执行时间、页面调度）； </li><li>事件：阻塞原因等。</li></ul></li><li><p>进程控制信息： </p><ul><li>程序段和数据段的地址；  </li><li>进程间同步和通信； </li><li>资源占用信息：除CPU外的进程所需的全部资源及已分配资源清单</li><li>链接指针：本进程所在队列的下一个进程的PCB首地址。</li></ul></li></ul><h5 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h5><p><img src="/2020/08/14/OS-ch-2/2.1-2.jpg" alt></p><h5 id="进程调度队列："><a href="#进程调度队列：" class="headerlink" title="进程调度队列："></a>进程调度队列：</h5><ul><li><p>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态。</p></li><li><p>不同的状态分别用不同的队列来表示（就绪队列，各种类型的堵塞队列）</p><ul><li>作业队列：系统中所有进程的集合</li><li>就绪队列：驻留主存的所有就绪态进程集合</li><li>设备队列：等待I/O设备的进程集合</li></ul></li><li><p>队列在各种队列中的迁移：</p><ul><li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</li></ul></li></ul><p><img src="/2020/08/14/OS-ch-2/2.1-3.jpg" alt="就绪队列和各种IO队列"></p><h5 id="PCB组织方式（两种）"><a href="#PCB组织方式（两种）" class="headerlink" title="PCB组织方式（两种）"></a>PCB组织方式（两种）</h5><p>链表：同一状态的进程其PCB构成一个链表，多个状态对应多个不同的链表</p><p><img src="/2020/08/14/OS-ch-2/2.1-4.jpg" alt="链表方式"></p><p>索引表：同一状态的进程归入一个Index表，（由index指向PCB）多个状态对应多个不同的PCB表</p><p><img src="/2020/08/14/OS-ch-2/2.1-5.jpg" alt="链表方式"></p><h5 id="利用PCB完成进程切换"><a href="#利用PCB完成进程切换" class="headerlink" title="利用PCB完成进程切换"></a>利用PCB完成进程切换</h5><p><img src="/2020/08/14/OS-ch-2/2.1-6.jpg" alt></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>进程管理中最基本的功能是<font color="red">进程控制</font></p><p>进程的生命周期：</p><ul><li>进程创建</li><li>进程运行</li><li>进程等待</li><li>进程唤醒</li><li>进程终止</li></ul><p>进程控制任务</p><ul><li>进程的创建，终止，进程状态的转变等</li></ul><p>进程控制一般由OS内核的原语来实现</p><ul><li>原语：由若干指令构成的原子操作</li><li>许多系统调用是原语，但不是所有的系统调用都是原语</li></ul><h4 id="2-2-1-进程的创建"><a href="#2-2-1-进程的创建" class="headerlink" title="2.2.1 进程的创建"></a>2.2.1 进程的创建</h4><h5 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h5><ul><li>树状结构，父子进程关系</li><li>子进程可以继承父进程的所有资源，如打开文件，缓冲区等。当子进程被撤销，应将继承的资源还给父进程。撤销父进程也必须同时撤销所有的子进程。</li><li>PCB中设置了家族关系表项。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-1.jpg" alt="进程图"></p><p>$$<br>引起进程创建的事件\<br>\begin{equation}<br>由操作系统内核创建\begin{cases}<br>1.操作系统初始化\<br>-分时系统中用户登录\<br>-批处理中作业调度\<br>2.提供服务\<br>-用户请求创建进程\<br>\end{cases}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>由应用程序自身创建\begin{cases}<br>3.应用请求\<br>-正在运行的进程执行了\创建进程的系统调用<br>\end{cases}<br>\end{equation}<br>$$</p><p>原语CREAT（）按下述步骤创建一个新进程:</p><ul><li>申请空白PCB。</li><li>为新进程分配资源：为代码、数据、用户栈分配空间。</li><li>初始化PCB：初始化标识信息、处理机状态（PC、SP)、处理机控制信息（进程状态、优先级）。 </li><li>将新进程插入就绪队列 。 </li></ul><h4 id="2-2-2-进程的终止"><a href="#2-2-2-进程的终止" class="headerlink" title="2.2.2 进程的终止"></a>2.2.2 进程的终止</h4><p><img src="/2020/08/14/OS-ch-2/2.2-2.jpg" alt></p><h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><ul><li>从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li><li>若处于执行状态，终止该进程的执行，并置调度标志为真，重新调度。</li><li>若有子孙进程，将所有子孙进程终止。</li><li>将进程全部资源归还其父进程或系统：释放内外存空间、关闭所有打开文件、释放当前</li><li>目录、释放共享内存段和各种锁定lock。</li><li>将其PCB从所在队列（或链表）中移出 </li></ul><h5 id="unix进程终止过程"><a href="#unix进程终止过程" class="headerlink" title="unix进程终止过程"></a>unix进程终止过程</h5><ul><li><p>进程执行完最后一条语句，请求操作系统删除进程(通过执行exit系统调用)。</p><ul><li>将子进程运行数据传递给父进程（通过 wait系统调用)。</li><li>回收的系统资源由操作系统再另行分配</li></ul></li><li><p>父进程也可以终止子进程的执行（通过abort系统调用)。原因：</p><ul><li>子进程超额使用资源.</li><li>分配给子进程执行的任务不再需要执行.</li><li>父进程退出。<ul><li>如果父进程终止，操作系统不再允许子进程继续执行。</li></ul></li></ul></li></ul><h4 id="2-2-3-进程的阻塞与唤醒"><a href="#2-2-3-进程的阻塞与唤醒" class="headerlink" title="2.2.3 进程的阻塞与唤醒"></a>2.2.3 进程的阻塞与唤醒</h4><p>$$<br>\begin{equation}<br>引起阻塞和唤醒的事件\begin{cases}<br>请求系统服务\<br>启动某种操作\<br>新数据尚未到\<br>无新工作可做<br>\end{cases}<br>\end{equation}<br>$$</p><h5 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h5><ul><li>正在执行的进程，发生上述事件时，自身调用有关阻塞原语，进入等待队列。进程的主动性行为。</li><li>进程由运行态变为阻塞态</li><li>引起处理机调度。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-3.jpg" alt></p><h5 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h5><ul><li>唤醒原因：等待的事件到达。</li><li>由阻塞队列转入就绪队列。进程由阻塞态变为就绪态.</li><li>方法：其他有关进程（例如用完并释放了该I/O设备的进程）发送信号到某个或一组进程。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-4.jpg" alt></p><p><strong>BLOCK和WAKEUP是一队作用相反的原语。</strong><br>如果在某进程中调用了<font color="red">阻塞原语</font>，则必须在与之相合作的另一进程中或其他相关的进程中，安排<font color="red">唤醒原语</font>，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。</p><h4 id="2-2-4-进程的挂起与激活"><a href="#2-2-4-进程的挂起与激活" class="headerlink" title="2.2.4 进程的挂起与激活"></a>2.2.4 进程的挂起与激活</h4><h5 id="挂起引入原因："><a href="#挂起引入原因：" class="headerlink" title="挂起引入原因："></a>挂起引入原因：</h5><ul><li><p><font color="red">终端用户请求</font></p><ul><li>终端用户发现自己运行的程序有问题，希望暂停自己程序的执行</li></ul></li><li><p><font color="red">父进程请求</font></p><ul><li>父进程希望挂起自己的某个子进程，以便考察和修改该子进程</li></ul></li><li><p><font color="red">负荷调节需要</font></p><ul><li>高优先级的进程要执行，而内存不空，系统将低优先级进程对换至外存。</li><li>提高处理机效率：就绪进程表为空时，要提交新进程，而此时内存不空，需挂起阻塞态的进程</li><li>为运行进程提供足够内存（对换及调整负荷）：资源紧张时，暂停某些进程，如：实时任务执行，而内存紧张。</li></ul></li><li><p><font color="red">操作系统的需要</font></p><ul><li>操作系统需要挂起某些进程以便检查运行中的资源使用情况或进行记账</li></ul></li></ul><h5 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h5><ul><li>目的：合理且充分地利用系统资源。进程在挂起状态时，进程没有占用内存空间，仅映像在磁盘上。</li><li>执行过程：挂起原语：SUSPEND（）</li><li>挂起原语的执行过程：<ul><li>从内存调到外存，改变进程的状态。</li><li>若处于活动就绪状态，改为静止就绪；</li><li>若处于活动阻塞状态，则改为静止阻塞；</li><li>若正在执行，则转向调度程序重新调度。</li></ul></li></ul><h5 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h5><ul><li>原因：父进程或用户进程请求，或内存已有足够空间</li><li>执行过程：从外存调入内存，改变进程的状态</li><li>可能也会引起处理机调度</li></ul><h5 id="挂起引起的状态转变"><a href="#挂起引起的状态转变" class="headerlink" title="挂起引起的状态转变"></a>挂起引起的状态转变</h5><p><img src="/2020/08/14/OS-ch-2/2.2-5.jpg" alt></p><ul><li>引入的新状态<ul><li>就绪挂起（静止就绪）：进程在外存，但只要进入内存，即可运行；</li><li>阻塞挂起状态（静止阻塞）：进程在外存并等待某事件的出现。</li></ul></li></ul><h5 id="有挂起状态的进程状态图"><a href="#有挂起状态的进程状态图" class="headerlink" title="有挂起状态的进程状态图"></a>有挂起状态的进程状态图</h5><p><img src="/2020/08/14/OS-ch-2/2.2-6.jpg" alt></p><h5 id="创建和终止状态"><a href="#创建和终止状态" class="headerlink" title="创建和终止状态"></a>创建和终止状态</h5><p><img src="/2020/08/14/OS-ch-2/2.2-7.jpg" alt></p><h5 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h5><p>由于多进程在系统中的并发执行，进程之间存在2种制约关系：<br><font color="red">间接制约</font>:进程间由于共享某种系统资源，而形成的相互制约。</p><p><code>进程A-&gt;资源-&gt;进程B</code></p><p><font color="red">直接制约</font>：进程间由于合作而形成的相互制约</p><p><code>进程A------&gt;进程B</code></p><h5 id="进程的两大关系"><a href="#进程的两大关系" class="headerlink" title="进程的两大关系"></a>进程的两大关系</h5><h6 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h6><p><strong>由于共享资源所要求的排他性，进程间要相互竞争，以获得这些资源的使用权。</strong></p><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p><strong>多个进程中发生的事件存在某种时序关系，必须协同工作、相互配合，以共同完成一项任务。</strong></p><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h3><p>进程并发地对共享数据的访问有可能引起数据的不一致性。<br>为了维持数据的一致性，必须有一种机制来保证协作进程之间按某种正确的次序执行。</p><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><ul><li>临界资源：硬件或软件（如外设、共享代码段、共享数据结构），多个进程在对其进行访问时（关键是进行写入或修改），必须互斥地进行。</li><li>有些共享资源可以同时访问，如只读数据。因而不是临界资源。</li></ul><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><ul><li><p><font color="red">临界区(critical section)</font>：在每个进程中，访问临界资源的一段代码。</p><ul><li><strong>临界区问题－－确保一个进程在执行它的临界区代码时，不允许其他进程再进入他们各自的临界区内执行代码</strong>。</li></ul></li><li><p><font color="red">进入区(entry section)</font>：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应“正在访问临界区”标志</p></li><li><p><font color="red">退出区(exit section)</font>：位于临界区的后面，用于将“正在访问临界区”标志清除。</p></li><li><p><font color="red">剩余区(remainder section)</font>：代码中的其余部分。</p></li></ul><h5 id="访问临界区的循环进程描述"><a href="#访问临界区的循环进程描述" class="headerlink" title="访问临界区的循环进程描述"></a>访问临界区的循环进程描述</h5><p><img src="/2020/08/14/OS-ch-2/2.3-1.jpg" alt></p><ul><li><p>当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理及调度的。比如，通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机是，不能处理机调度，那么系统的性能将非常低。</p></li><li><p>不适合处理机调度的情况：</p><ul><li>在处理中断的过程中</li><li>进程在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li></ul><h5 id="同步机制应遵循的准则："><a href="#同步机制应遵循的准则：" class="headerlink" title="同步机制应遵循的准则："></a>同步机制应遵循的准则：</h5><ul><li>空闲则入：其他进程均不处于临界区，应允许请求进入临界区的进程进入；</li><li>忙则等待：已有进程处于其临界区，请求进入临界区的进程应等待；</li><li>有限等待：等待进入临界区的进程不能“死等”；</li><li>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li></ul><h5 id="解决临界区问题的算法"><a href="#解决临界区问题的算法" class="headerlink" title="解决临界区问题的算法"></a>解决临界区问题的算法</h5><p><img src="/2020/08/14/OS-ch-2/2.3-2.jpg" alt></p><h4 id="2-3-3-信号量机制"><a href="#2-3-3-信号量机制" class="headerlink" title="2.3.3 信号量机制"></a>2.3.3 信号量机制</h4><ul><li>信号量是OS提供的管理公有资源的有效手段。</li><li>整型信号量或记录型信号量可以代表可用资源实体的数量。</li></ul><h5 id="1-整型信号量机制"><a href="#1-整型信号量机制" class="headerlink" title="1.整型信号量机制"></a>1.整型信号量机制</h5><ul><li>1965年，荷兰学者Dijkstra提出（所以P、V分别是荷兰语的test(proberen)和increment(verhogen)），是一种卓有成效的进程同步机制。</li><li>最初Dijkstra把信号量定义为整型量s和两个原子操作（除初始化操作）：P和V, 现又称为：wait和signal。</li></ul><h5 id="2-记录型信号量机制"><a href="#2-记录型信号量机制" class="headerlink" title="2.记录型信号量机制"></a>2.记录型信号量机制</h5><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">process</span> *<span class="title">queue</span>;</span> </span><br><span class="line">        &#125; semaphore;</span><br></pre></td></tr></table></figure><p>每个信号量s<br>一个整数值s.count：其初值表示某类资源的数目（又称为“资源信号量”)<br>一个进程等待队列s.queue，是阻塞在该信号量的各个进程的PCB链成的队列。</p><p><img src="/2020/08/14/OS-ch-2/2.3-3.jpg" alt></p><p>信号量只能通过初始化和两个标准的原语（wait、signal）来访问－－作为OS核心代码执行，不受进程调度的打断。</p><p><img src="/2020/08/14/OS-ch-2/2.3-4.jpg" alt></p><h5 id="3-AND型信号量"><a href="#3-AND型信号量" class="headerlink" title="3.AND型信号量"></a>3.AND型信号量</h5><p>基本思想：将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放。</p><p><img src="/2020/08/14/OS-ch-2/2.3-5.jpg" alt></p><h5 id="4-二进制（Binary-）信号量"><a href="#4-二进制（Binary-）信号量" class="headerlink" title="4.二进制（Binary ）信号量"></a>4.二进制（Binary ）信号量</h5><ul><li>其值只能是 0和 1；易于实现。</li><li>利用二进制信号量可以实现整型信号量。</li><li>数据结构：<pre><code>二进制信号量 S1, S2;  int C:  </code></pre></li><li>初值：<pre><code>S1 = 1  S2 = 0  C = 代表共享资源的初始值</code></pre></li></ul><p><img src="/2020/08/14/OS-ch-2/2.3-6.jpg" alt></p><h4 id="2-3-4-信号量的应用"><a href="#2-3-4-信号量的应用" class="headerlink" title="2.3.4 信号量的应用"></a>2.3.4 信号量的应用</h4><ol><li><h5 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h5><ul><li>为临界资源设置一个互斥信号量mutex，其初值为1；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;   </span><br><span class="line"> …</span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">             …</span><br><span class="line">               wait ( mutex );</span><br><span class="line">               critical section</span><br><span class="line">              signal( mutex );</span><br><span class="line">              remaider section</span><br><span class="line">           &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h5></li></ol><ul><li><p>前趋关系：并发执行的进程P1和P2中，分别有代码C1和C2，要求C1在C2开始前完成；</p><ul><li><p>为每个前趋关系设置一个互斥信号量S12，其初值为0</p></li><li><p>P1:                      P2:</p><p>C1;                      wait(s12);<br>signal(s12)          C2；</p></li></ul></li></ul><h3 id="2-4-经典的进程同步问题"><a href="#2-4-经典的进程同步问题" class="headerlink" title="2.4 经典的进程同步问题"></a>2.4 经典的进程同步问题</h3><h4 id="2-4-1-生产者消费者问题"><a href="#2-4-1-生产者消费者问题" class="headerlink" title="2.4.1 生产者消费者问题"></a>2.4.1 生产者消费者问题</h4><h5 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1) 问题描述："></a>1) 问题描述：</h5><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p><h5 id="2）制约关系："><a href="#2）制约关系：" class="headerlink" title="2）制约关系："></a>2）制约关系：</h5><p>生产者与消费者之间不直接发生联系，他们通过缓冲区发生制约关系<br>生产者生产商品，若缓冲区已满生产者等待，直到缓冲区有空为止<br>消费者在缓冲区空时等待，直到生产者的商品放入。否则，取一个商品消费。<br>注意：缓冲区为循环缓冲区</p><h5 id="3）问题分析"><a href="#3）问题分析" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><p>采用信号量机制，定义两个资源信号量<br>full是缓冲池“满”数目，初值为0，empty是缓冲池“空”数目，初值为N。实际上，full和empty是同一个含义：<br>           full + empty == N<br>只要缓冲池未满empty&gt;0，生产者便可将消息送入缓冲池；<br>只要缓冲池未空full&gt;0，消费者便可从缓冲池取走一个消息。 </p><h5 id="4）问题解答"><a href="#4）问题解答" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p><img src="/2020/08/14/OS-ch-2/2.4-1.jpg" alt></p><h5 id="5）问题扩充"><a href="#5）问题扩充" class="headerlink" title="5）问题扩充"></a>5）问题扩充</h5><p>若生产者与消费者变成多对多关系，我们要做什么变动？<br>增加互斥信号量: mutex=1;</p><p><img src="/2020/08/14/OS-ch-2/2.4-2.jpg" alt></p><h5 id="6）注意："><a href="#6）注意：" class="headerlink" title="6）注意："></a>6）注意：</h5><ul><li>每个程序中互斥的wait(mutex)和signal(mutex)必须成对出现。</li><li>对资源信号量empty和full的wait 、signal操作成对出现，但它们分别处于不同的程序中。例如wait在计算进程中，而signal则在打印进程中，计算进程若因执行wait而阻塞，则以后将由打印进程将它唤醒。</li><li>每个程序中的wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。</li></ul><h4 id="2-4-2-读者写者问题"><a href="#2-4-2-读者写者问题" class="headerlink" title="2.4.2 读者写者问题"></a>2.4.2 读者写者问题</h4><h5 id="1）问题描述"><a href="#1）问题描述" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><ul><li>一个数据文件或记录可被多个进程共享。其中，有些进程要求读；而另一些进程要求行写或修改。</li><li>只要求读的进程称为“Reader进程”，其它进程称为“Writer进程”。</li></ul><h5 id="2）制约关系"><a href="#2）制约关系" class="headerlink" title="2）制约关系"></a>2）制约关系</h5><ul><li>任一时刻“写者”最多只允许一个，而“读者”则允许多个――“读－写”互斥，“写－写”互斥，“读－读”允许。</li><li>所谓读者一写者问题是指保证一个Writer进程必须与其它进程互斥地访问共享对象的同步问题。</li></ul><h5 id="3）问题分析-1"><a href="#3）问题分析-1" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><ul><li><p>读者优先的解决方案：</p><ul><li>互斥信号量wrt，初值是1，代表一个共享文件。为解决“读－写”互斥，“写－写”互斥。</li><li>一个记数器，即整型变量readcount，记录读者数，初值是0。<ul><li>来一个读者， readcount加1</li><li>当readcount ＝1表示是第一个读者， 则需要执行p操作抢占文件；否则表示已有读者在安全的读数据。</li><li>走一个读者，readcount减1</li><li>当readcount ＝0表示是最后一个读者，则需要v操作释放资源；否则表示还有读者在读数据。</li></ul></li><li>readcount 为多个读者共享的变量，是临界资源。用互斥信号量mutex控制, mutex初值是1。</li></ul></li><li><p>写者优先：</p><ul><li>当一个写进程声明想写时，不允许新的读进程访问该数据区。</li></ul></li><li><p>解决方案：</p><ul><li>增加信号量r，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。</li><li>一个记数器，即整型变量writecount，记录写者数，初值是0。</li><li>writecount为多个写者共享的变量，是临界资源。用互斥信号量mutex2控制, mutex2初值是1。</li><li>增加mutex3，初值是1：在r上不允许建造长队列，否则写进程将不能跳过这个队列，因此，只允许一个读进程在r上排队，而所有其他读进程在等待r之前，在信号量mutex3上排队。</li></ul></li></ul><h5 id="4）问题解答-1"><a href="#4）问题解答-1" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p>读者优先方式：</p><p><img src="/2020/08/14/OS-ch-2/2.4-3.jpg" alt></p><p>写者优先方式：<br><img src="/2020/08/14/OS-ch-2/2.4-4.jpg" alt></p><h4 id="2-4-3-哲学家进餐问题"><a href="#2-4-3-哲学家进餐问题" class="headerlink" title="2.4.3 哲学家进餐问题"></a>2.4.3 哲学家进餐问题</h4><h5 id="1）问题描述-1"><a href="#1）问题描述-1" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><p>（由Dijkstra首先提出并解决）</p><ul><li>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</li><li>哲学家的动作包括思考和进餐：<ul><li>进餐时需要同时拿起他左边和右边的两支筷子，</li><li>思考时则同时将两支筷子放回原处。</li></ul></li></ul><h5 id="2）问题分析"><a href="#2）问题分析" class="headerlink" title="2）问题分析"></a>2）问题分析</h5><ul><li>哲学家逆时针编号0-4，筷子也相应编号</li><li>定义互斥信号量数组chopstick[5], 对应5支筷子，初值均为1。</li></ul><p>死锁问题的解决方法：</p><p><img src="/2020/08/14/OS-ch-2/2.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-6.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-7.jpg" alt></p><h3 id="2-5-管程"><a href="#2-5-管程" class="headerlink" title="2.5 管程"></a>2.5 管程</h3><h4 id="2-5-1-管程的基本概念"><a href="#2-5-1-管程的基本概念" class="headerlink" title="2.5.1 管程的基本概念"></a>2.5.1 管程的基本概念</h4><ul><li>利用信号量实现进程同步，使大量的同步操作分散在各个进程中。使系统管理麻烦，同步操作使用不当会引起死锁。</li><li>引入新的进程同步工具－－－管程（Monitors)</li><li>目的：分离互斥和条件同步的关注</li></ul><h5 id="管程由四部分组成："><a href="#管程由四部分组成：" class="headerlink" title="管程由四部分组成："></a>管程由四部分组成：</h5><ul><li><p>管程的名称</p></li><li><p>局部于管程的共享变量说明</p></li><li><p>对该数据结构进行操作的一组过程</p></li><li><p>对管程中数据设置初值的语句</p></li></ul><p>任何管程外的过程都不能访问管程内的数据结构。管程相当于围墙，将共享变量和对它进行操作的若干过程围了起来，进程只要访问临界资源就必须通过管程。</p><p>管程每次只允许一个进程进入管程，实现了互斥。</p><p>使用信号量的效率比管程高。</p><p>管程结构在一些程序设计语言中得到实现。如并发Pascal和Java，C#等，它还被作为一个程序库实现。</p><h3 id="2-6-进程之间的通信"><a href="#2-6-进程之间的通信" class="headerlink" title="2.6 进程之间的通信"></a>2.6 进程之间的通信</h3><p>进程通信时指进程之间的信息交换，所交换的信息量，少者是一个状态，多者是成千上万字节。</p><h4 id="进程通信分类："><a href="#进程通信分类：" class="headerlink" title="进程通信分类："></a>进程通信分类：</h4><h5 id="低级通信："><a href="#低级通信：" class="headerlink" title="低级通信："></a>低级通信：</h5><p>只能传递状态和整数值（控制信息）包括进程互斥和同步所采用的信号量和管程机制。</p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>传送信息量小，效率低，每次通信传输的信息量固定，传递较多信息需要多次通信。</p><p>编程复杂：用户直接实现通信的细节，容易出错。</p><h5 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h5><p>利用复杂的特定数据结构进行大信息量的通信。通信效率高。包括：</p><ul><li>共享存储器系统<ul><li>互相通信的进程共享某些数据结构或存储区，进程之间通过这些空间进行通信。分两类。<ul><li>共享数据结构：如缓冲区<ul><li>公用数据结构的设置及进程间同步的处理由程序员负责，OS只提供共享存储器</li><li>通信效率低，只适合少量数据</li></ul></li><li>共享存储区：为传递大量数据在存储器中划出一片共享存储区<ul><li>进程通信前，先向系统申请获得存储区的一个分区，并指定关键字；若系统已经给其他进程分配分区，则把该分区的描述符返回给申请者，申请者将获得的共享存储区连接到本进程上；此后可像读写普通存储器一样读写公用存储区。</li></ul></li></ul></li></ul></li><li>消息传递系统<ul><li>程序员利用OS提供的系统原语进行通信。简化通信程序编制</li></ul></li><li>管道通信系统<ul><li>利用读进程写进程实现通信的共享文件–pipe文件</li><li>写进程用字符流输入大流量数据送入管道，读进程接收数据</li><li>要求：<ul><li>互斥</li><li>同步</li><li>对方存在</li></ul></li></ul></li></ul><h4 id="消息传递实现方式："><a href="#消息传递实现方式：" class="headerlink" title="消息传递实现方式："></a>消息传递实现方式：</h4><h5 id="直接通信："><a href="#直接通信：" class="headerlink" title="直接通信："></a>直接通信：</h5><ul><li><p>利用OS提供的发送命令将消息发送到目标进程</p></li><li><p>发送进程和接收进程都以显示方式提供对方标识符。</p></li></ul><h5 id="间接通信："><a href="#间接通信：" class="headerlink" title="间接通信："></a>间接通信：</h5><p>利用双方之外的共享数据结构作为通信中转。（信箱）</p><p>信箱分为3类：</p><ul><li>私用信箱：用户自己创建，其他用户只能发送信息</li><li>公用信箱：OS创建，符合要求的进程都可以发消息</li><li>共享信箱：进程创建</li></ul><h3 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h3><p>线程：更小的能独立运行的单位。是进程当中执行的一条流程</p><p>引入线程是为了提高系统内程序的并发程度，提高系统效率增大作业吞吐量。</p><p>提出原因：进程开销过大，建立销毁执行效率不高。</p><p>需要满足特性：</p><ul><li>实体之间可以并发执行</li><li>实体之间共享相同的地址空间</li></ul><h4 id="线程的属性："><a href="#线程的属性：" class="headerlink" title="线程的属性："></a>线程的属性：</h4><ul><li><p>共享进程资源：一个进程的所有线程具有相同的地址空间，可以访问进程拥有的资源</p></li><li><p>轻型实体：</p><ul><li>只有少数资源<ul><li>线程标识符</li><li>线程控制块TCB</li><li>核心栈</li><li>私有存储区</li></ul></li></ul></li><li><p>线程是处理机调度的单位</p></li><li><p>可并发执行</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>一个进程中可以同时存在多个线程；</li><li>各个线程之间可以并发地执行；</li><li>线程的创建和终止时间比进程短；</li><li>各个线程之间可以共享内存和文件资源，因此可进行直接通信而不需要通过OS的内核。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li></ul><h4 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h4><p><img src="/2020/08/14/OS-ch-2/2.7-1.jpg" alt></p><h4 id="OS对线程的支持"><a href="#OS对线程的支持" class="headerlink" title="OS对线程的支持"></a>OS对线程的支持</h4><p>1.用户级线程：</p><ul><li>仅存在与用户空间中，内核不了解。</li><li>用线程库函数来控制</li><li>一个线程阻塞，整个进程都要等待</li><li>时间片分配给进程，线程执行时间相对较短</li></ul><p>2.内核线程</p><ul><li>OS支持，创建撤销切换都由内核实现</li><li>创建管理慢于用户级线程</li><li>能在多处理机并行，一个线程阻塞整个进程不阻塞</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>多对一</p><ul><li>多个用户级对一个内核</li><li>线程管理在用户空间进行，效率高</li><li>一个线程阻塞，整个进程阻塞</li></ul><p>一对一</p><ul><li>每个用户级线程都对应一个内核线程。</li><li>如果一个线程执行了阻塞系统调用，能允许另一个线程继续执行</li><li>缺点：创建内核线程的开销会影响应用程序的性能，限制系统所支持的线程数量。</li></ul><p>多对多</p><ul><li>用户线程数&gt;=内核数，与特定程序机器有关</li><li>允许系统根据资源分配创建内核进程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-进程管理&quot;&gt;&lt;a href=&quot;#第二章-进程管理&quot; class=&quot;headerlink&quot; title=&quot;第二章 进程管理&quot;&gt;&lt;/a&gt;第二章 进程管理&lt;/h2&gt;&lt;p&gt;为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进
      
    
    </summary>
    
    
    
      <category term="-操作系统 -OS -ch2" scheme="http://yokeso.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-ch2/"/>
    
  </entry>
  
  <entry>
    <title>OS_ch_1</title>
    <link href="http://yokeso.top/2020/08/14/OS-ch-1/"/>
    <id>http://yokeso.top/2020/08/14/OS-ch-1/</id>
    <published>2020-08-14T07:00:18.000Z</published>
    <updated>2020-08-14T13:15:39.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统知识点梳理"><a href="#操作系统知识点梳理" class="headerlink" title="操作系统知识点梳理"></a>操作系统知识点梳理</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/2020/08/14/OS-ch-1/1.1-1.jpg" alt="####"></p><h5 id="地位与目标："><a href="#地位与目标：" class="headerlink" title="地位与目标："></a>地位与目标：</h5><h6 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h6><p>紧贴系统硬件之上，所有其他软件之下，（是其他软件的共同环境）</p><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><ul><li><p><strong>有效性</strong>（系统管理人员的观点）：管理和分配硬件、软件资源，合理地组织计算机的工作流程</p></li><li><p><strong>方便性</strong>（用户的观点）：提供良好的、一致的用户接口，弥补硬件系统的类型和数量差别</p></li><li><p><strong>可扩充性</strong>（开放的观点）：硬件的类型和规模、操作系统本身的功能和管理策略、多个系统之间的资源共享和互操作</p></li></ul><h5 id="操作系统的定义：（没有公认的定义）"><a href="#操作系统的定义：（没有公认的定义）" class="headerlink" title="操作系统的定义：（没有公认的定义）"></a>操作系统的定义：（没有公认的定义）</h5><ul><li>是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充</li><li>是一组控制和管理计算机硬件和软件资源，方便用户使用的程序集合<ul><li>控制程序执行以防错误和不当使用</li><li>执行用户程序并提供服务</li><li>管理各种计算机资源：CPU、硬盘、内存、硬件外设等</li><li>有效解决冲突请求并确保资源公平使用</li></ul></li></ul><h5 id="几种观点"><a href="#几种观点" class="headerlink" title="几种观点"></a>几种观点</h5><ol><li>OS是计算机硬件软件的管理者</li><li>OS是用户使用系统的接口</li><li>OS是扩展机/虚拟机<ul><li>在裸机上添加：设备管理，文件管理、存储管理（外存&amp;内存）、处理机管理</li></ul></li></ol><h4 id="1-2操作系统的发展历史"><a href="#1-2操作系统的发展历史" class="headerlink" title="1.2操作系统的发展历史"></a>1.2操作系统的发展历史</h4><h5 id="人工操作系统"><a href="#人工操作系统" class="headerlink" title="人工操作系统"></a>人工操作系统</h5><p><strong>1946-50年代</strong>，（电子管）集中计算（计算中心），计算机资源昂贵</p><p>人工操作特点：</p><ul><li>用户独占全机</li><li>CPU等待人工操作</li><li>串行性</li></ul><p>缺点：</p><ul><li>昂贵组件的低利用效率</li><li>利用率 = 执行时间/（执行时间+读卡时间）</li></ul><h5 id="单道批处理系统："><a href="#单道批处理系统：" class="headerlink" title="单道批处理系统："></a>单道批处理系统：</h5><p><strong>50年代末-60年代中</strong>(晶体管)利用磁带把若干个作业分类编成作业执行序列，每个批作业由一个专门的监督程序（Monitor）自动依次处理。可使用汇编语言开发。</p><p><img src="/2020/08/14/OS-ch-1/1.2-1.jpg" alt></p><p>特征：</p><ul><li>自动性</li><li>顺序性</li><li>单道性</li></ul><p>优点：</p><ul><li>同一批内各作业的自动依次更替，改善了主机CPU和I/O设备的使用效率提高了吞吐量。</li></ul><p>缺点：</p><ul><li><p>内存中仅有一道程序运行，当该程序运行结束或出故障，由监控程序换入另一个程序。不能很好地利用系统资源。</p></li><li><p><strong>CPU</strong>和I/O设备使用忙闲不均（取决于当前作业的特性）。对计算为主的作业，外设空闲；对I/O为主的作业，CPU空闲。</p></li></ul><p><strong>单道批处理系统是最早出现的一种OS,严格来说只能算是OS的前身而不是现在理解的OS，但该系统比起人工操作的系统已经有很大的进步</strong></p><h5 id="多道批处理系统："><a href="#多道批处理系统：" class="headerlink" title="多道批处理系统："></a>多道批处理系统：</h5><p><strong>60年代中~70年代中</strong>（集成电路）利用多到批处理提高资源的利用率。</p><p><img src="/2020/08/14/OS-ch-1/1.2-2.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.2-3.jpg" alt="多道批处理特点以及优缺点"></p><p>多道程序系统的技术问题：</p><ul><li>并行程序的运行需要共享软硬件资源，需要同步和互斥机制。</li><li>多道程序需要提高内存使用效率，需要覆盖技术，交互技术，虚拟存储等技术。</li><li>多道程序在内存中要保证系统存储区和用户存储区安全可靠，需要内存保护。.   </li></ul><h5 id="分时系统："><a href="#分时系统：" class="headerlink" title="分时系统："></a>分时系统：</h5><p><strong>70年代中期至今</strong>    </p><p>多个用户分享使用同一台计算机。每个用户给一定的时间运行，然后切换到另一用户，一个轮转周期在宏观上相当短，用户感觉不到。</p><p><img src="/2020/08/14/OS-ch-1/1.2-4.jpg" alt></p><p>分时系统特征：</p><ul><li>交互性：用户与系统进行人机对话</li><li>多路性：多用户同时在各自终端上使用同一CPU</li><li>独立性：用户可彼此独立操作，互不干扰，互不混淆。</li><li>及时性：用户在短时间内可以得到系统的及时回答。</li></ul><p>影响响应时间的因素：</p><ul><li>终端数目的多少</li><li>时间片的大小</li><li>信息交换量</li><li>信息交换速度</li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理。并控制所有事实任务协调一致的运行。</p></li><li><p>保证实时性和高可靠性，对系统的效率放在第二位。</p></li></ul><p>分类：实施控制系统，实时信息处理系统。</p><h5 id="实时系统与分时系统的比较"><a href="#实时系统与分时系统的比较" class="headerlink" title="实时系统与分时系统的比较"></a>实时系统与分时系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-5.jpg" alt></p><h5 id="多处理操作系统："><a href="#多处理操作系统：" class="headerlink" title="多处理操作系统："></a>多处理操作系统：</h5><p><img src="/2020/08/14/OS-ch-1/1.2-6.jpg" alt></p><h5 id="并行系统的类型："><a href="#并行系统的类型：" class="headerlink" title="并行系统的类型："></a>并行系统的类型：</h5><p>非对称式多重处理</p><p>对称式多重处理</p><h5 id="分布式操作系统与网络操作系统的比较"><a href="#分布式操作系统与网络操作系统的比较" class="headerlink" title="分布式操作系统与网络操作系统的比较"></a>分布式操作系统与网络操作系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-7.jpg" alt></p><h4 id="1-3-操作系统的特征和服务"><a href="#1-3-操作系统的特征和服务" class="headerlink" title="1.3 操作系统的特征和服务"></a>1.3 操作系统的特征和服务</h4><h5 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h5><ul><li><p><strong>并发</strong>：多个事件在同一时间段内发生，（并行是指单处理器下宏观上并发微观上交替执行）</p></li><li><p><strong>共享</strong>：多个进程共享有限的计算机资源，操作系统要对系统资源进行合理的分配和使用，资源在一个时间段内交替被多个进程使用。</p><hr><p>并发和共享是操作系统两个最基本特征，这两者之间是互为存在条件的</p><hr></li><li><p><strong>虚拟</strong>：一个物理实体映射为若干对应逻辑实体–分时或分空间，虚拟是操作系统管理系统资源的重要手段，提高资源利用率。</p></li><li><p><strong>异步</strong>：也称不确定性，指进程的执行顺序和执行时间的不确定性</p><ul><li>进程的运行速度不可预知</li><li>判据：无论快慢，应该结果相通–通过进程互斥和同步手段来保证。</li><li>难以重现系统在某个时刻的状态（包括重现运行中的错误）</li><li>性能保证：实时系统与分时系统类似，但通过资源预留以保证性能。</li></ul></li></ul><h5 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h5><p>1 管理模块：针对不同管理对象的程序模块（操作系统核心）</p><p>2.用户接口：shell,窗口系统</p><h4 id="1-4-操作系统功能"><a href="#1-4-操作系统功能" class="headerlink" title="1.4 操作系统功能"></a>1.4 操作系统功能</h4><h5 id="1-4-1-存储管理"><a href="#1-4-1-存储管理" class="headerlink" title="1.4.1 存储管理"></a>1.4.1 存储管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-1.jpg" alt></p><h5 id="1-4-2-处理机管理"><a href="#1-4-2-处理机管理" class="headerlink" title="1.4.2 处理机管理"></a>1.4.2 处理机管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-2.jpg" alt></p><h5 id="1-4-3-设备管理"><a href="#1-4-3-设备管理" class="headerlink" title="1.4.3 设备管理"></a>1.4.3 设备管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-3.jpg" alt></p><h5 id="1-4-4-文件管理"><a href="#1-4-4-文件管理" class="headerlink" title="1.4.4 文件管理"></a>1.4.4 文件管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-4.jpg" alt></p><h5 id="1-4-5-用户接口"><a href="#1-4-5-用户接口" class="headerlink" title="1.4.5 用户接口"></a>1.4.5 用户接口</h5><p>目标：提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供给用户。</p><p>命令接口：为联机用户提供的，由一组键盘操作命令及命令解释程序所组成，又分联机和脱机用户接口。</p><p>程序接口：为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的路径。它由一组系统调用组成。</p><p>图形接口：用户可用鼠标或菜单和对话框来完成对应应用程序和文件的操作。</p><h5 id="双模式操作"><a href="#双模式操作" class="headerlink" title="双模式操作"></a>双模式操作</h5><h6 id="用户模式（目态）"><a href="#用户模式（目态）" class="headerlink" title="用户模式（目态）"></a>用户模式（目态）</h6><p>执行普通用户的应用程序</p><h6 id="系统模式（管态）"><a href="#系统模式（管态）" class="headerlink" title="系统模式（管态）"></a>系统模式（管态）</h6><p>执行操作系统核心代码</p><h6 id="分辨方式："><a href="#分辨方式：" class="headerlink" title="分辨方式："></a>分辨方式：</h6><p>在程序状态字中添加模式位指示目前所处模式：系统态(0)或用户态(1)</p><p>发生中断或故障（自陷）<font color="red">硬件</font>自动从用户态切换到系统态</p><p>当用户程序需要操作系统的服务（通过系统调用）必须由管态切换到目态。</p><p><img src="/2020/08/14/OS-ch-1/1.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.4-6.jpg" alt></p><h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex1.jpg" alt="1."></p><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex2.jpg" alt="1."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统知识点梳理&quot;&gt;&lt;a href=&quot;#操作系统知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;操作系统知识点梳理&quot;&gt;&lt;/a&gt;操作系统知识点梳理&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是操作系统&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Ch.3</title>
    <link href="http://yokeso.top/2020/07/26/CSAPP-Ch-3/"/>
    <id>http://yokeso.top/2020/07/26/CSAPP-Ch-3/</id>
    <published>2020-07-26T09:07:46.000Z</published>
    <updated>2020-08-14T13:16:51.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP第三章"><a href="#CSAPP第三章" class="headerlink" title="CSAPP第三章"></a>CSAPP第三章</h2><h3 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h3><h4 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h4><p>Intel &amp; AMD</p><h4 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>gcc</strong>： Linux上默认的编译器</p></li><li><p><strong>-Og</strong>:   编译选项，告诉编译器使用会生成符合原始C代码整体结构的机器代码编译优化等级</p></li></ul><h5 id="gcc命令调用过程"><a href="#gcc命令调用过程" class="headerlink" title="gcc命令调用过程"></a>gcc命令调用过程</h5><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgcc%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="gcc命令调用过程"></p><p>用图片的形式描述一下就是这样的：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgccppt.jpg" alt="gccppt"></p><h5 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h5><ul><li><strong>机器级编程的两种抽象</strong><ul><li>指令集体系结构或指令集架构（Instruction Set Architexture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态，指令格式以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看起来像一个非常大的数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li></ul></li></ul><h5 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h5><p>以C代码文件<code>mstore.c</code>为例，在命令行上使用<code>-S</code>选项，可以看到C语言编译产生的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure><p>这时GCC会运行编译器，产生汇编文件<code>mstore.s</code>但是不做进一步操作</p><p>如果用  <code>-c</code>命令行选项GCC会编译并汇编该代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure><p>这样就会产生目标代码文件<code>mstore.o</code>它是二进制格式的，无法直接进行查看,想要查看机器代码的内容，可以通过<code>反汇编器(disassembler)</code>进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d mstore.o</span></span><br></pre></td></tr></table></figure><p>机器代码以及反汇编表示的特性：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E7%89%B9%E6%80%A7.jpg" alt="机器代码以及反汇编表示的特性"></p><h5 id="3-2-3-关于格式的注释"><a href="#3-2-3-关于格式的注释" class="headerlink" title="3.2.3 关于格式的注释"></a>3.2.3 关于格式的注释</h5><p>以书上内容为例</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.jpg" alt="example"></p><p>所有以<font color="red"><code>.</code></font>开头的行都是指导汇编器和连接器工作的伪指令，我们通常可以忽略。</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.2.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h4><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.3.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h4><h5 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h5><p>大多数指令具有一个或者多个操作符，用于指示出执行一个操作中要用的源数据值以及放置结果的目的地址值。不同种操作数可能被分为三类：</p><ul><li>立即数        <ul><li>用来表示常数值</li><li>书写方式是<code>$+标准C表示法表示的整数</code>，例如：<code>$-577，$0x1F</code></li><li>不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码</li></ul></li><li>寄存器        <ul><li>表示某个寄存器中的内容，16个寄存器的低1字节、2字节、4字节和8字节中的一个作为操作数，分别对应8位、16位、32位以及64位。</li><li>用r<sub>a</sub>来表示任意寄存器ａ，用引用R[r<sub>a</sub>]来表示它的值，（将寄存器集看做数组R）</li></ul></li><li>内存引用<ul><li>根据计算出来的地址（有效地址）访问某个内存位置。</li><li>用M<sub>b</sub>[Addr]表示对存储在内存中地址Addr开始的b个字节进行引用,为了方便通常省略下标b</li></ul></li></ul><p>操作数格式标示图如下：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%A4%BA%E5%9B%BE.jpg" alt="机器代码以及反汇编表示的特性"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSAPP第三章&quot;&gt;&lt;a href=&quot;#CSAPP第三章&quot; class=&quot;headerlink&quot; title=&quot;CSAPP第三章&quot;&gt;&lt;/a&gt;CSAPP第三章&lt;/h2&gt;&lt;h3 id=&quot;程序的机器级表示&quot;&gt;&lt;a href=&quot;#程序的机器级表示&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Git个人博客搭建</title>
    <link href="http://yokeso.top/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yokeso.top/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-26T15:34:47.000Z</published>
    <updated>2020-12-02T14:39:31.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Git个人博客搭建（一）"><a href="#Hexo-Git个人博客搭建（一）" class="headerlink" title="Hexo+Git个人博客搭建（一）"></a>Hexo+Git个人博客搭建（一）</h1><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​    拥有一个私人博客一直都是每个<del>程序员</del>的理想，恰好赶上最近不想学习，用了一下午的时间搭建<del><strong>采坑</strong></del>了Hexo+Git个人博客搭建（主要是免费啊！！！免费啊！！）遇到的一些问题以及搭建过程进行一个记录，也希望能减少后来人的掉发量（笑）。那我们现在就开始愉快的脱发之旅吧！</p><hr><h3 id="二、Hexo简介"><a href="#二、Hexo简介" class="headerlink" title="二、Hexo简介"></a>二、Hexo简介</h3><p>​    关于Hexo，我觉得没有什么比他简介中的说法能更好的解释这个软件的话语了。</p><blockquote><p>快速、简洁且高效的博客框架</p></blockquote><p>​    速度快、一键部署、支持MarkDown、可扩展插件。。最重要的是<font color="red"><strong>开源免费</strong></font>! 大写加粗的重要啊朋友们！！！开发者是台湾人，所以<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>的官网对中文支持极度友好，对英语有怨念的同学可以在官网选择中文查阅文档以及API。</p><p>​    Hexo是基于<strong>Node.js</strong>的静态博客框架，依赖少安装容易，可以很方便的生成网页托管在GitHub上或者云上，是搭建博客的首要选择。本文采用的是网页托管到GitHub上来进行博客搭建。</p><hr><h3 id="三、安装过程"><a href="#三、安装过程" class="headerlink" title="三、安装过程"></a>三、安装过程</h3><h4 id="1-系统配置"><a href="#1-系统配置" class="headerlink" title="1.系统配置"></a>1.系统配置</h4><p>​    提及安装过程不提系统以及版本的都是流氓！首先放上我自己的系统配置：</p><blockquote><p>win10_64位教育版 A卡全家桶套餐（与安装无关不详细写了）</p><p>git –version 2.27.0.windows.1</p><p>npm –version 6.14.5</p></blockquote><p>​    由于我本身是Windows版本，所以以下的安装过程主要按照windows版本来描述，但是用Linux的小伙伴的安装过程也是大同小异（具体安装方法我也会在下面提及）。特别是安装git后使用的命令行基本和linux一样，所以系统版本就没有那么重要了</p><hr><h4 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2.Node.js安装"></a>2.Node.js安装</h4><p>​    在上文说道，Hexo是基于Node.js的，所以首先就要安装Node.js的依赖。这里我直接给出Node.Js的下载网址以及Git的安装网址以方便查阅。</p><p>​                                                                          <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener"> 点击这里安装Node.js</a></p><p>​    Node.js的安装极度简单，如果直接下载.msi文件的话只要一路next就可以安装成功。这里有问题的小伙伴请自行百度谷歌</p><h4 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3.Git安装"></a>3.Git安装</h4><p>​    下一步是Git的安装，这里一样给出git的下载网址以便下载。</p><p>​                                                                                 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">点击这里下载Git</a></p><p>​    Linux的安装方法则更加简单，以Ubuntu为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line"></span><br><span class="line">sudo apt-get install npm</span><br><span class="line"></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装后打开cmd(terminal)输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果出现了版本号，就证明你安装成功了，我的是这样的：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Git&npm.jpg" alt="我的配置"></p><p>在安装成功后就可以在Git里面敲命令行啦，比Windows本身带的cmd要好用许多。</p><h4 id="4-Hexo安装"><a href="#4-Hexo安装" class="headerlink" title="4.Hexo安装"></a>4.Hexo安装</h4><p>​    到了这里，恭喜你终于开始安装框架了，进入到了安装博客的第一步。</p><p>​    首先要在自己喜欢的位置创建一个文件夹来放你的博客，我选择的位置是D://Blog (路径习惯性的用英文可以减少不少莫名其妙的Bug)</p><p>​    在此处右键打开Git Bash，或者勤快的同学也可以从桌面cd进去</p><p>​    输入命令<code>npm install -g heso-cli</code></p><p>​    安装好后用<code>hexo -v</code>检查版本号</p><p>​    下面继续回到GIt中，初始化一下Hexo输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>​    在你选择的文件夹中应该能看到这样的文件结构（我的文件经过编译提交了，安装完后应该会比这个少几个文件）：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo.jpg" alt="我的文件"></p><p>​    在这个文件列表中，</p><ul><li><p>node_modeules 是用来存放依赖包的文件</p></li><li><p>public 是用来存放生成的页面的文件</p></li><li><p>scaffold 用来生成文章的一些模板</p></li><li><p>source文件夹用来存放你的博客文件</p></li><li><p>themes是博客的主题</p></li><li><p>_config.yml是配置文件，</p><p>在推送到Git上时我们都会用到。但这都是之后的事情啦</p><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>​        这样就可以在<code>localhost:4000</code>看到你的博客啦，但是现在的博客不仅主题不好看，而且还只是在你自己电脑上运行的，并没有部署到Git上托管。</p><p>​    既然提到了博客界面很丑陋，那我们为什么不换一个主题呢？Hexo显然也考虑到了这点，为我们提供了一个很好的下载主题的网站，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>你就可以找到一个你喜欢的博客模板进行下载了。把下载的主题直接解压放在theme文件夹里，命名为你下载的主题，在_config.yml 中修改<code>theme</code>为你下载的名称。</p><p>​    比如我应用的是名称是<code>clean</code>的一个主题。那我修改的方式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: clean</span><br></pre></td></tr></table></figure><h4 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h4><p>​    我默认你在看这篇文章之前已经有一个GItHub账户了，如果没有的话直接去注册一个也很方便。如果你已经配置过Git以及SSH可以直接跳过。</p><p>在网页的右上角选择<code>new respository</code>新建一个仓库</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitNewRes.jpg" alt="New repository"></p><p>​    输入仓库名称为<code>UserName/UserName.git.io</code></p><p>​    可能这么说会有人不理解，那我就放上一个更直白的方式：</p><p>​    我的用户名称为Yokeso ,那我创建的库名称就为<code>Yokeso/Yokeso.git.io</code>顺便附上图片希望对小白有所帮助</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%5Cnewres.jpg" alt="Repository"></p><p>​    这个名称是GitHub专门用来给用户的网站接口，每个用户只能创建一个，并且<font color="red">是免费的</font>。</p><p>回到你的GItBash下，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure><p>​    这里的yourname 是你的用户名，youremail是你注册GItHub时用的邮箱，这样GitHub才知道你是他的对应用户。</p><p>​    输入完成之后如果不放心可以用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>​    来进行检查。</p><h4 id="5-Git创建SSH"><a href="#5-Git创建SSH" class="headerlink" title="5.Git创建SSH"></a>5.Git创建SSH</h4><p>​    创建SSH同样只需要GitBash上的一个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></table></figure><p>​    如果想创建秘钥的话可以创建，但只是个人博客的话没有创建秘钥的必要，所以一路回车直接过去。</p><p>​    SSH会默认在你的/User/.ssh下创建秘钥，这里的id_rsa是这台电脑的私人秘钥，Id_rsa.pub是公钥。需要提交到GItHub上。只有秘钥公钥相互匹配是你才能顺利的传输到你的gitHub上。你可以给他直接打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后将这段代码（普遍是以ssh-rsa AAAA开头）直接复制，粘贴到个人仓库上方<code>setting</code>中的SSH目录里。这里涉及到个人隐私，所以不贴图展示了。</p><p>如果不知道是否创建成功的话，你可以直接输入以下命令进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这个代码在成功情况下回返回这样的一个结果</p><p><code>Hi Yokeso(这里是我的用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h4 id="6-将Hexo部署上去"><a href="#6-将Hexo部署上去" class="headerlink" title="6.将Hexo部署上去"></a>6.将Hexo部署上去</h4><p>​    到了这里，你已经完成一大半了，最后一步就是要将你的博客部署到GitHub上。</p><p>​    打开_config.yml，在最后你会看到一个<code>deploy</code>字段，将其修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你的账户名称&#x2F;你的账户名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​    <font color="red">千万要注意repo字段，将git上面仓库的地址直接复制过来，选择https方式，我这里在网络上没找明白，弄了好久。</font></p><p><img src="Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/https.jpg" alt="复制到repo字段"></p><p>​    在最后部署之前,先要安装<code>hexo-deployer</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nom install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li><p><code>hexo clean</code>是用来清除你之前生成的东西</p></li><li><p><code>hexo g</code>用来生成静态文章 g的全称为generate （当然可以在命令行里写hexo generate）</p></li><li><p><code>hexo d</code>用来部署文章（deploy）</p><p>过一会儿就能在http://你的注册名称.github,io上看到你的博客了！</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>​    作为智能专业的学生，很少接触网络的一些东西，这次搭建Hexo也是一时的心血来潮，想要做一些整理工作。描述下来比较简单，但在repo字段的问题上就浪费了我将近一个小时去寻找问题。同时，这也是我第一次接触markdown 以及写博客。应该有些算晚了，但对于一个工具来说，也应该没有什么早晚的区别。我也希望通过我的博客能够与大家多多交流，将自己搭建各种环境包括做各种项目时候的一些心得和大家一起分享</p><p>Code To Make World Better!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Git个人博客搭建（一）&quot;&gt;&lt;a href=&quot;#Hexo-Git个人博客搭建（一）&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Git个人博客搭建（一）&quot;&gt;&lt;/a&gt;Hexo+Git个人博客搭建（一）&lt;/h1&gt;&lt;h2 id=&quot;文章目录&quot;
      
    
    </summary>
    
    
    
      <category term="-Hexo -个人博客" scheme="http://yokeso.top/tags/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
