<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yokeso.top/"/>
  <updated>2021-03-18T15:40:41.078Z</updated>
  <id>http://yokeso.top/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZigBee协议栈探究---（三）网络创建</title>
    <link href="http://yokeso.top/2021/03/15/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA/"/>
    <id>http://yokeso.top/2021/03/15/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA/</id>
    <published>2021-03-15T03:29:49.000Z</published>
    <updated>2021-03-18T15:40:41.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZigBee协议栈探究—-（三）网络创建"><a href="#ZigBee协议栈探究—-（三）网络创建" class="headerlink" title="ZigBee协议栈探究—-（三）网络创建"></a>ZigBee协议栈探究—-（三）网络创建</h1><p>关于设备的链接，还需要从头说起。</p><p>在（一）中我提到过一个函数<code>osalInitTasks</code>，这个函数位于<code>OSAL_Smart_home.c</code>中。我们再把这个函数拿出来看一下：</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      osalInitTasks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   This function invokes the initialization function for each task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">osalInitTasks</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint8 taskID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tasksEvents = (uint16 *)osal_mem_alloc( <span class="keyword">sizeof</span>( uint16 ) * tasksCnt); <span class="comment">//分配内存返回缓冲区指针</span></span><br><span class="line">  osal_memset( tasksEvents, <span class="number">0</span>, (<span class="keyword">sizeof</span>( uint16 ) * tasksCnt)); <span class="comment">//设置所分配内存空间单元值0</span></span><br><span class="line"></span><br><span class="line">  macTaskInit( taskID++ ); <span class="comment">//macTaskInit(0) ，用户不需考虑</span></span><br><span class="line">  nwk_init( taskID++ ); <span class="comment">//nwk_init(1)，用户不需考虑</span></span><br><span class="line">  Hal_Init( taskID++ ); <span class="comment">//Hal_Init(2) ，用户需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined( MT_TASK )</span></span><br><span class="line">  MT_TaskInit( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  APS_Init( taskID++ );  <span class="comment">//APS_Init(3) ，用户不需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line">  APSF_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ZDApp_Init( taskID++ ); <span class="comment">//ZDApp_Init(4) ，用户需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line">  ZDNwkMgr_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Smart_home_Init( taskID ); <span class="comment">//用户任务初始化用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在最开始的流程分析中，我们已经分析了<code>Smart_home_Init( taskID );</code>的作用：初始化用户进程，为用户创建Task。在分析的时候也提过ZDO层，也就是<code>ZigBee Device Object</code>，这个层掌管着ZigBee设备的终端节点具体提供以下功能</p><ul><li>初始化应用支持子层，网络层。</li><li>发现节点和节点功能。在无信标的网络中，加入的节点只对其父节点可见。而其他节点可以通过ZDO的功能来确定网络的整体拓扑结构已经节点所能提供的功能。</li><li>安全加密管理：主要包括安全key的建立和发送，已经安全授权。</li><li>网络的维护功能。</li><li>绑定管理：绑定的功能由应用支持子层提供，但是绑定功能的管理却是由ZDO提供，它确定了绑定表的大小，绑定的发起和绑定的解除等功能。</li><li>节点管理：对于网络协调器和路由器，ZDO提供网络监测、获取路由和绑定信息、发起脱离网络过程等一系列节点管理功能。</li></ul><p>也就是说，我们想要探究的设备发现与绑定，ZigBee组网的过程都在ZDO层进行实现。那就进入<code>ZDApp_Init()</code>这个函数来看看吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      ZDApp_Init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   ZDApp Initialization function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   task_id - ZDApp Task ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  None</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZDApp_Init</span><span class="params">( uint8 task_id )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 存储task ID</span></span><br><span class="line">  ZDAppTaskID = task_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化并存储ZDO设备短地址</span></span><br><span class="line">  ZDAppNwkAddr.addrMode = Addr16Bit;</span><br><span class="line">  ZDAppNwkAddr.addr.shortAddr = INVALID_NODE_ADDR;</span><br><span class="line">  (<span class="keyword">void</span>)NLME_GetExtAddr();  <span class="comment">// 加载saveExtAddr指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查手动“保持自动启动”</span></span><br><span class="line">  ZDAppCheckForHoldKey();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化ZDO项目并设置设备-要创建的设备类型。</span></span><br><span class="line">  ZDO_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向AF注册端点描述</span></span><br><span class="line">  <span class="comment">// 此任务没有简单描述，但我们仍然需要</span></span><br><span class="line">  <span class="comment">// 以注册端点。</span></span><br><span class="line">  afRegister( (endPointDesc_t *)&amp;ZDApp_epDesc );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined( ZDO_USERDESC_RESPONSE )</span></span><br><span class="line">  ZDApp_InitUserDesc();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ZDO_USERDESC_RESPONSE</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否启动设备</span></span><br><span class="line">  <span class="keyword">if</span> ( devState != DEV_HOLD )</span><br><span class="line">  &#123;</span><br><span class="line">    ZDOInitDevice( <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ZDOInitDevice( ZDO_INIT_HOLD_NWK_START );</span><br><span class="line">    <span class="comment">// LED闪烁来标识设备启动</span></span><br><span class="line">    HalLedBlink ( HAL_LED_4, <span class="number">0</span>, <span class="number">50</span>, <span class="number">500</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化ZDO回调函数指针zdoCBFunc []</span></span><br><span class="line">  ZDApp_InitZdoCBFunc();</span><br><span class="line"></span><br><span class="line">  ZDApp_RegisterCBs();</span><br><span class="line">&#125; <span class="comment">/* ZDApp_Init() */</span></span><br></pre></td></tr></table></figure><p>在这个函数中可以看到，最重要的一步就是<code>ZDOInitDevice()</code>设备在这里开始启动，并让LED闪烁。那么我们从这里来看看设备是如何启动的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      ZDOInitDevice</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   启动网络中的设备。该功能将读取ZCD_NV_STARTUP_OPTION（NV项目）以确定是否要</span></span><br><span class="line"><span class="comment"> *          恢复设备的网络状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   startDelay - 启动设备的时间延迟（以毫秒为单位）。</span></span><br><span class="line"><span class="comment"> *                       此延迟增加了抖动：((NWK_START_DELAY + startDelay)+</span></span><br><span class="line"><span class="comment"> *                       (osal_rand()&amp;EXTENDED_JOINING_RANDOM_MASK))</span></span><br><span class="line"><span class="comment"> *                       当startDelay设置为ZDO_INIT_HOLD_NWK_START时</span></span><br><span class="line"><span class="comment"> *                       此功能将保持网络初始化。应用可以启动设备。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span>    如果应用程序想要强制“新”加入，则应用程序在调用这个函数之前应设置在</span></span><br><span class="line"><span class="comment"> *          ZCD_NV_STARTUP_OPTION NV中的ZCD_STARTOPT_DEFAULT_NETWORK_STATE位。“新”加  </span></span><br><span class="line"><span class="comment"> *          入意味着不恢复网络设备状态。使用zgWriteStartupOptions（）设置这些选项。        </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - 设备的网络状态为已存储</span></span><br><span class="line"><span class="comment"> *    ZDO_INITDEV_NEW_NETWORK_STATE - 网络状态复位</span></span><br><span class="line"><span class="comment"> *          这可能表示ZCD_NV_STARTUP_OPTION 无法还原, 或者没有网络状态需要还原</span></span><br><span class="line"><span class="comment"> *    ZDO_INITDEV_LEAVE_NOT_STARTED - 重置之前，network leave将重加入选项设为真，因此，</span></span><br><span class="line"><span class="comment"> *          该设备不是在网络中启动（仅一次）。下次这个函数调用它将启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uint8 <span class="title">ZDOInitDevice</span><span class="params">( uint16 startDelay )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint8 networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;</span><br><span class="line">  uint16 extendedDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( devState == DEV_HOLD )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果已更新NV项目，则初始化RAM项目表</span></span><br><span class="line">    zgInitItems( FALSE );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ZDConfig_InitDescriptors();</span><br><span class="line">  <span class="comment">//devtag.071807.todo - fix this temporary solution</span></span><br><span class="line">  _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( NV_RESTORE )</span></span><br><span class="line">  <span class="comment">// 直接获取键盘以查看是否需要重置nv。</span></span><br><span class="line">  <span class="comment">// 按住SW_BYPASS_NV键（在OnBoard.h中定义）</span></span><br><span class="line">  <span class="comment">// 在引导时跳过过去的NV 复位。</span></span><br><span class="line">  <span class="keyword">if</span> ( HalKeyRead() == SW_BYPASS_NV )</span><br><span class="line">    networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 确定是否应恢复NV</span></span><br><span class="line">    networkStateNV = ZDApp_ReadNetworkRestoreState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( networkStateNV == ZDO_INITDEV_RESTORED_NETWORK_STATE )</span><br><span class="line">  &#123;</span><br><span class="line">    networkStateNV = ZDApp_RestoreNetworkState();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 清除NV中的网络状态</span></span><br><span class="line">    NLME_InitNV();</span><br><span class="line">    NLME_SetDefaultNV();</span><br><span class="line">    <span class="comment">// 清除NWK键值</span></span><br><span class="line">    ZDSecMgrClearNVKeyValues();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( networkStateNV == ZDO_INITDEV_NEW_NETWORK_STATE )</span><br><span class="line">  &#123;</span><br><span class="line">    ZDAppDetermineDeviceType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在加入网络时延迟-无法恢复网络状态</span></span><br><span class="line">    extendedDelay = (uint16)((NWK_START_DELAY + startDelay)</span><br><span class="line">              + (osal_rand() &amp; EXTENDED_JOINING_RANDOM_MASK));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化设备类型的安全性e</span></span><br><span class="line">  ZDApp_SecInit( networkStateNV );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( ZDO_INIT_HOLD_NWK_START != startDelay )</span><br><span class="line">  &#123;</span><br><span class="line">    devState = DEV_INIT;    <span class="comment">// 删除保持状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化请假控制逻辑</span></span><br><span class="line">    ZDApp_LeaveCtrlInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查请假控制重置设置</span></span><br><span class="line">    ZDApp_LeaveCtrlStartup( &amp;devState, &amp;startDelay );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开可能为持有态</span></span><br><span class="line">    <span class="keyword">if</span> ( devState == DEV_HOLD )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 设置NV启动选项以强制执行“新”连接。</span></span><br><span class="line">      zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知申请</span></span><br><span class="line">      osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ( ZDO_INITDEV_LEAVE_NOT_STARTED );   <span class="comment">// Don&#x27;t join - (one time).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发网络启动</span></span><br><span class="line">    ZDApp_NetworkInit( extendedDelay );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置广播地址掩码以支持广播过滤</span></span><br><span class="line">  NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ( networkStateNV );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读可以看到，这个函数的主要目的就是计算启动延迟，并启动网络设备，主要启动设备的语句为<code>ZDApp_NetworkInit( extendedDelay );</code>那我们就来看看这个函数又做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      ZDApp_NetworkInit()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   用来启动网络加入程序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   delay - 启动前需等待的毫秒数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZDApp_NetworkInit</span><span class="params">( uint16 delay )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( delay )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 启动设备前稍等片刻</span></span><br><span class="line">    osal_start_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT, delay );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这两个函数名称和形参来看，都是要将<code>ZDAppTaskID</code>的标识设置为<code>ZDO_NETWORK_INIT</code>。而被设置了flag的任务在这个时候就会被处理。接收这个处理的函数就是<code>ZDApp_event_loop()</code>，由于这个函数过长，所以只看与<code>ZDO_NETWORK_INIT</code>处理相关的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( events &amp; ZDO_NETWORK_INIT )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 初始化APP并启动网络</span></span><br><span class="line">  devState = DEV_INIT;</span><br><span class="line">  osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );</span><br><span class="line"></span><br><span class="line">  ZDO_StartDevice( (uint8)ZDO_Config_Node_Descriptor.LogicalType, devStartMode,</span><br><span class="line">                   DEFAULT_BEACON_ORDER, DEFAULT_SUPERFRAME_ORDER );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回未启动事件c</span></span><br><span class="line">  <span class="keyword">return</span> (events ^ ZDO_NETWORK_INIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里又调用了ZDO_StartDevice()函数，其中</p><p>ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR</p><p>devStartMode = MODE_HARD</p><p>且协调器编译了ZDO_COORDINATOR</p><p>也就是说，在这里就要分为协调器的开始组建网络，路由器的辅助转发网络消息，以及终端节点的加入网络进行区别，对于我们现在来说，主要的部分就来看协调器的组建网络：</p><p>我们把这一部分建网的代码拿来看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This function starts a device in a network.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZDO_StartDevice</span><span class="params">( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">if</span> ( ZG_BUILD_COORDINATOR_TYPE &amp;&amp; logicalType == NODETYPE_COORDINATOR )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( startMode == MODE_HARD )</span><br><span class="line">     &#123;</span><br><span class="line">       devState = DEV_COORD_STARTING;</span><br><span class="line">       ret = NLME_NetworkFormationRequest( zgConfigPANID, </span><br><span class="line">                                           zgApsUseExtendedPANID, </span><br><span class="line">                                           zgDefaultChannelList,</span><br><span class="line">                                           zgDefaultStartingScanDuration, </span><br><span class="line">                                           beaconOrder,</span><br><span class="line">                                           superframeOrder, </span><br><span class="line">                                           <span class="literal">false</span> );</span><br><span class="line">     &#125;</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>也就是说，组建网络的重要一环原来是在<code>NLME_NetworkFormationRequest()</code>这个函数中，很遗憾，这部分函数并不开源，但从网络查询中得知，这个函数是用来判断网络状态的，主要要分为两种状态</p><ul><li>nwkStatus为ZSuccess时，也就是网络创建成功了，将设备状态<code>decSAtatue</code>设置为对应的<code>DEV_ZB_COORD</code>,然后设置事件<code>ZDO_STATE_CHANGE_EVENT</code>也就是网络状态发生转变的事件，返回到<code>ZD_App_event_loop()</code>中继续执行</li><li>nwkStatus为非ZSuccess时，也就是网络创建不成功，那么就将增大功率返回到<code>ZD_App_event_loop()</code>中加大功率，如果功率已经是最大了，那么就将<code>devState</code>设置为<code>DEV_INIT</code>（创建网络失败）再设置事件<code>ZDO_STATE_CHANGE_EVENT</code>，返回到<code>ZD_App_event_loop()</code></li></ul><p>所以，无论如何，返回值都是在上面提到的语句中执行，也就是这一条</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );</span><br></pre></td></tr></table></figure><p>那再回过来看<code>ZD_App_event_loop()</code>是怎么处理这个状态的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( events &amp; ZDO_STATE_CHANGE_EVT )</span><br><span class="line">&#123;</span><br><span class="line">  ZDO_UpdateNwkStatus( devState );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动时，如果设备是集中器，则执行一次MTO路由发现</span></span><br><span class="line">  <span class="keyword">if</span> ( zgConcentratorEnable == TRUE )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Start next event</span></span><br><span class="line">    osal_start_timerEx( NWK_TaskID, NWK_MTO_RTG_REQ_EVT, <span class="number">100</span> );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用了<code>ZDO_UpdateNwkStatus( devState )</code>,网络状态改变,这个函数会更新和发送信息通知每个注册登记过的应用终端.我们再接着来看这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZDO_UpdateNwkStatus</span><span class="params">( devStates_t state )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Endpoint/Interface descriptor list.</span></span><br><span class="line">  epList_t *epDesc = epList;</span><br><span class="line">  byte bufLen = <span class="keyword">sizeof</span>(<span class="keyword">osal_event_hdr_t</span>);</span><br><span class="line">  <span class="keyword">osal_event_hdr_t</span> *msgPtr;</span><br><span class="line"></span><br><span class="line"> ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();</span><br><span class="line"> (<span class="keyword">void</span>)NLME_GetExtAddr();  <span class="comment">// Load the saveExtAddr pointer.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> ( epDesc )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( epDesc-&gt;epDesc-&gt;endPoint != ZDO_EP )</span><br><span class="line">    &#123;</span><br><span class="line">     msgPtr = (<span class="keyword">osal_event_hdr_t</span> *)osal_msg_allocate( bufLen );</span><br><span class="line">     <span class="keyword">if</span> ( msgPtr )</span><br><span class="line">     &#123;</span><br><span class="line">       msgPtr-&gt;event = ZDO_STATE_CHANGE; <span class="comment">// Command ID</span></span><br><span class="line">       msgPtr-&gt;status = (byte)state;</span><br><span class="line"></span><br><span class="line">       osal_msg_send( *(epDesc-&gt;epDesc-&gt;task_id), (byte *)msgPtr ); <span class="comment">//发往应用任务</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    epDesc = epDesc-&gt;nextDesc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对SampleApp的协调器来说，这里触发应用任务SampleApp_TaskID的ZDO_STATE_CHANGE事件,看下对ZDO_STATE_CHANGE的处理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Ccase ZDO_STATE_CHANGE:   </span><br><span class="line">SampleApp_NwkState = (devStates_t)(MSGpkt-&gt;hdr.status); <span class="comment">//获取设备当前状态</span></span><br><span class="line"><span class="keyword">if</span> ( (SampleApp_NwkState == DEV_ZB_COORD)</span><br><span class="line">    || (SampleApp_NwkState == DEV_ROUTER)</span><br><span class="line">    || (SampleApp_NwkState == DEV_END_DEVICE) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Start sending the periodic message in a regular interval.</span></span><br><span class="line">  osal_start_timerEx( SampleApp_TaskID,</span><br><span class="line">                    SAMPLEAPP_SEND_PERIODIC_MSG_EVT,</span><br><span class="line">                    SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Device is no longer in the network</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以看到当协调器建立网络成功,通过回调函数触发应用任务的ZDO_STATE_CHANGE事件,最终开启定时器发送周期信息.</p><p>路由器也可以按这个思路进行分析。</p><p>最后来给一下大致的流程</p><p>main()  -&gt;  osal_init_system()  -&gt;  osalInitTasks()  -&gt;  ZDApp_Init()  -&gt;  ZDOInitDevice()  -&gt;  ZDApp_NetworkInit  -&gt;  触发ZDAppTaskID的ZDO_NETWORK_INIT       -&gt;  ZDO_StartDevice()-&gt; NLME_NetworkFormationRequest()  -&gt;  网络建立成功ZDO_NetworkFormationConfirmCB    -&gt;                           触发ZDAppTaskID的ZDO_NETWORK_START  -&gt;  ZDApp_NetworkStartEvt()-&gt;触发ZDAppTaskID的ZDO_STATE_CHANGE_EVT-&gt;ZDO_UpdateNwkStatus()  -&gt;  触发SampleApp_TaskID的ZDO_STATE_CHANGE   -&gt;开户周期信息发送的定时器.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZigBee协议栈探究—-（三）网络创建&quot;&gt;&lt;a href=&quot;#ZigBee协议栈探究—-（三）网络创建&quot; class=&quot;headerlink&quot; title=&quot;ZigBee协议栈探究—-（三）网络创建&quot;&gt;&lt;/a&gt;ZigBee协议栈探究—-（三）网络创建&lt;/h1&gt;&lt;p&gt;关于设备的链接，还需要从头说起。&lt;/p&gt;
&lt;p&gt;在（一）中我提到过一个函数&lt;code&gt;osalInitTasks&lt;/code&gt;，这个函数位于&lt;code&gt;OSAL_Smart_home.c&lt;/code&gt;中。我们再把这个函数拿出来看一下：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ZigBee" scheme="http://yokeso.top/tags/ZigBee/"/>
    
      <category term="CC2530" scheme="http://yokeso.top/tags/CC2530/"/>
    
      <category term="协议栈" scheme="http://yokeso.top/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>ZigBee协议栈探究---（二）数据的接收与发送</title>
    <link href="http://yokeso.top/2021/03/12/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81/"/>
    <id>http://yokeso.top/2021/03/12/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%8F%91%E9%80%81/</id>
    <published>2021-03-12T02:03:41.000Z</published>
    <updated>2021-03-18T15:40:12.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZigBee协议栈探究—-（二）数据的接收与发送"><a href="#ZigBee协议栈探究—-（二）数据的接收与发送" class="headerlink" title="ZigBee协议栈探究—-（二）数据的接收与发送"></a>ZigBee协议栈探究—-（二）数据的接收与发送</h1><h2 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h2><p>上一章讲解了ZigBee协议栈中函数的运行走向，了解了ZigBee的任务最终在<code>ProgressEvent</code>这个函数中执行，那么在协议栈中这个函数在不改动的情况下究竟执行了什么？我们又应该如何改动它呢？我们又如何进行数据的发送与接收呢？</p><span id="more"></span><h2 id="2-从ProcessEvent函数开始讨论数据接收处理"><a href="#2-从ProcessEvent函数开始讨论数据接收处理" class="headerlink" title="2.从ProcessEvent函数开始讨论数据接收处理"></a>2.从ProcessEvent函数开始讨论数据接收处理</h2><p>首先来看看<code>Smart_home_ProcessEvent()</code>函数究竟做了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      Smart_home_ProcessEvent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   Generic Application Task event processor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   task_id  - The OSAL assigned task ID.</span></span><br><span class="line"><span class="comment"> * @param   events   - Bit map of events to process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  Event flags of all unprocessed events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">UINT16 <span class="title">Smart_home_ProcessEvent</span><span class="params">( uint8 task_id, UINT16 events )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>)task_id;  <span class="comment">// Intentionally unreferenced parameter</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( events &amp; SYS_EVENT_MSG )</span><br><span class="line">  &#123;</span><br><span class="line">    afIncomingMSGPacket_t *MSGpkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( Smart_home_TaskID )) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( MSGpkt-&gt;hdr.event )</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">case</span> ZDO_CB_MSG:</span><br><span class="line">        Smart_home_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">case</span> KEY_CHANGE:</span><br><span class="line">        Smart_home_HandleKeys( ((keyChange_t *)MSGpkt)-&gt;state, ((keyChange_t *)MSGpkt)-&gt;keys );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> AF_INCOMING_MSG_CMD:</span><br><span class="line">        Smart_home_ProcessMSGCmd( MSGpkt );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      osal_msg_deallocate( (uint8 *)MSGpkt );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( events ^ SYS_EVENT_MSG );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( events &amp; Smart_home_SEND_EVT )</span><br><span class="line">  &#123;</span><br><span class="line">    Smart_home_Send();</span><br><span class="line">    <span class="keyword">return</span> ( events ^ Smart_home_SEND_EVT );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( events &amp; Smart_home_RESP_EVT )</span><br><span class="line">  &#123;</span><br><span class="line">    Smart_home_Resp();</span><br><span class="line">    <span class="keyword">return</span> ( events ^ Smart_home_RESP_EVT );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ( <span class="number">0</span> );  <span class="comment">// Discard unknown events.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个函数中最引人瞩目的应该就是<code>MSGpkt</code>以及一大堆的宏调用了。让我们来逐一分析一下。首先就是<code>MSGpkt</code>，很明显这个函数的类型是<code>afIncomingMSGPacket_t</code>的指针，我们来看一下这个结构体的构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">osal_event_hdr_t</span> hdr;     <span class="comment">/* OSAL信息头部 */</span></span><br><span class="line">  uint16 groupId;           <span class="comment">/*组号，未设置时默认为0 */</span></span><br><span class="line">  uint16 clusterId;         <span class="comment">/* 信息簇号 */</span></span><br><span class="line">  afAddrType_t srcAddr;     <span class="comment">/* 源地址，如果端点号为STUBAPS_INTER_PAN_EP,</span></span><br><span class="line"><span class="comment">                               就是InterPAN 信息 */</span></span><br><span class="line">  uint16 macDestAddr;       <span class="comment">/* MAC头 目的短地址 */</span></span><br><span class="line">  uint8 endPoint;           <span class="comment">/* 目的端点号 */</span></span><br><span class="line">  uint8 wasBroadcast;       <span class="comment">/* 如果是广播则为真 */</span></span><br><span class="line">  uint8 LinkQuality;        <span class="comment">/* 收到数据帧的链接质量 */</span></span><br><span class="line">  uint8 correlation;        <span class="comment">/* 接收到的数据帧的原始相关值 */</span></span><br><span class="line">  int8  rssi;               <span class="comment">/* 接收的射频功率，单位dBm */</span></span><br><span class="line">  uint8 SecurityUse;        <span class="comment">/* 不推荐使用 */</span></span><br><span class="line">  uint32 timestamp;         <span class="comment">/*  MAC收据时间戳 */</span></span><br><span class="line">  uint8 nwkSeqNum;          <span class="comment">/* 网络报头帧序列号 */</span></span><br><span class="line">  afMSGCommandFormat_t cmd; <span class="comment">/* 应用层数据 */</span></span><br><span class="line">&#125; afIncomingMSGPacket_t;</span><br></pre></td></tr></table></figure><p>通过阅读注释，很明显能明白这是数据帧报文段的定义。也就是说<code>MSGpkt</code>是一个初始化的报文段指针。那么这个报文段是由谁给出来的呢？再来看下面这一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( Smart_home_TaskID )) </span><br></pre></td></tr></table></figure><p>对于<code>osal_msg_receive( Smart_home_TaskID )</code>这一部分，这里很容易从函数名看出指的是接收到的数据。这里暂且不深入探究，我更好奇的是：在while中按case进行划分时，这些case都是什么？又都可以设置为什么呢？我们随便挑几个来看一看。</p><p>可以看出，指引case的条件是<code>MSGpkt-&gt;hdr.event</code>，在上面可以找到，hdr的类型是<code>osal_event_hdr_t</code>,这个数据结构定义是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint8  event;</span><br><span class="line">  uint8  status;</span><br><span class="line">&#125; <span class="keyword">osal_event_hdr_t</span>;</span><br></pre></td></tr></table></figure><p>也就是说，这个结构体中只有uint8 的event和status两个。再回头来看这些case。通过观察我们发现，这几个case并不处于同一个.h文件，而是分散到几个.h文件中。但都具有一个比较共同的标识 ：<code>Global Generic System Message</code>，在下面我尽我所能的整理了一下可能出现的case，以供参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*comdef.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_CHANGE                0xC0    <span class="comment">// 按键事件</span></span></span><br><span class="line"><span class="comment">/*ZComDef.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_INCOMING_ZTOOL_PORT   0x21    <span class="comment">// 来自ZTool端口的原始数据（未实现）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_INCOMING_ZAPP_DATA    0x22    <span class="comment">// 来自ZAPP端口的原始数据（参见serialApp.c）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MT_SYS_APP_MSG            0x23    <span class="comment">// 来自MT Sys消息的原始数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MT_SYS_APP_RSP_MSG        0x24    <span class="comment">// MT Sys消息的原始数据输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MT_SYS_OTA_MSG            0x25    <span class="comment">// MT OTA Rsp的原始数据输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_DATA_CONFIRM_CMD       0xFD    <span class="comment">// 数据确认</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INCOMING_MSG_CMD       0x1A    <span class="comment">// 收到的MSG类型消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INCOMING_KVP_CMD       0x1B    <span class="comment">// 传入的KVP类型消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INCOMING_GRP_KVP_CMD   0x1C    <span class="comment">// 传入组KVP类型消息</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//＃define KEY_CHANGE 0xC0 //按键事件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_NEW_DSTADDR           0xD0    <span class="comment">// ZDO收到了此应用的新DstAddr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_STATE_CHANGE          0xD1    <span class="comment">// ZDO更改了设备的网络状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_MATCH_DESC_RSP_SENT   0xD2    <span class="comment">// 已发送ZDO匹配描述符响应</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_CB_MSG                0xD3    <span class="comment">// ZDO传入消息回调</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_NETWORK_REPORT        0xD4    <span class="comment">// ZDO收到网络报告消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_NETWORK_UPDATE        0xD5    <span class="comment">// ZDO收到网络更新消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZDO_ADDR_CHANGE_IND       0xD6    <span class="comment">// ZDO被告知设备地址更改</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_CHANNEL_INTERFERE      0x31    <span class="comment">// NwkMgr收到频道干扰消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_ED_SCAN_CONFIRM        0x32    <span class="comment">// NwkMgr收到ED扫描确认消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAPS_CHANNEL_CHANGE       0x33    <span class="comment">// 存根APS更改了设备的通道</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZCL_INCOMING_MSG          0x34    <span class="comment">// 传入的ZCL基础消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZCL_KEY_ESTABLISH_IND     0x35    <span class="comment">// ZCL密钥建立完成指示</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZCL_OTA_CALLBACK_IND      0x36    <span class="comment">// ZCL OTA完成指示</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为应用程序（用户应用程序）保留的OSAL系统消息ID /事件</span></span><br><span class="line"><span class="comment">// 0xE0 ?0xFC</span></span><br></pre></td></tr></table></figure><p> 在了解了case都可以用什么表示之后，我们再来看看对应情况的应对函数。在示例中总共涉及了三个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ZDO_CB_MSG:</span><br><span class="line">  Smart_home_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> KEY_CHANGE:</span><br><span class="line">  Smart_home_HandleKeys( ((keyChange_t *)MSGpkt)-&gt;state, ((keyChange_t *)MSGpkt)-&gt;keys );</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> AF_INCOMING_MSG_CMD:</span><br><span class="line">  Smart_home_ProcessMSGCmd( MSGpkt );</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这几个函数都是在<code>Smart_home.c</code>中定义的，都是对应情况下的希望对应解决方法，其中<code>Smart_home_HandleKeys</code>是需要用户自行实现填充的按键函数。</p><p>那么现在我们已经通过代码得知，我们所有的任务只要通过switch语句来处理网络包传输中表示事件的各种event，就可以成功的利用自写函数来控制设备进行反应。也就是说，我们已经掌握了数据接收处理的方法，那么就产生了一个更有趣的话题：数据的发送究竟是怎么完成的呢？又是通过什么样的代码来实现的呢？</p><h2 id="3-数据的发送"><a href="#3-数据的发送" class="headerlink" title="3.数据的发送"></a>3.数据的发送</h2><p>可以肯定的是，数据的发送也是ZigBee提供好的，只需我们直接调用就好。那这个函数在哪里呢？</p><p>经过查找，我在AF.c中找到了这个函数，下面就来看看这个名为<code>afStatus_t AF_DataRequest</code>的函数</p><p>这个函数比较长，所以从函数形参开始一点一点看，我会直接将函数说明标识在形参中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint8 AF_DataRequestDiscoverRoute = TRUE;</span><br><span class="line"><span class="comment">/* 函数功能，信息发送和多路传输*/</span></span><br><span class="line"><span class="function">afStatus_t <span class="title">AF_DataRequest</span><span class="params">( afAddrType_t *dstAddr,   <span class="comment">//完整的ZB目标地址：Nwk地址+端点</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           endPointDesc_t *srcEP,   <span class="comment">//起点描述（响应或确认）</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint16 cID,              <span class="comment">//由配置文件指定的有效集群ID。</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint16 len,              <span class="comment">//数据字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint8 *buf,              <span class="comment">//指向要发送的数据字节的指针。</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint8 *transID,          <span class="comment">/*指向可以修改的字节的指针，</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">                                                    该字节将用作msg的事务序列号。*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint8 options,           <span class="comment">//Tx选项的有效位掩码</span></span></span></span><br><span class="line"><span class="function"><span class="params">                           uint8 radius )</span>           <span class="comment">//通常设置为AF_DEFAULT_RADIUS。</span></span></span><br><span class="line"><span class="function"><span class="comment">/*结果及返回值</span></span></span><br><span class="line"><span class="function"><span class="comment">*如果成功transID 增加1</span></span></span><br><span class="line"><span class="function"><span class="comment">*返回 afStatus_t</span></span></span><br><span class="line"><span class="function"><span class="comment">  #define afStatus_SUCCESS            ZSuccess           // 0x00 </span></span></span><br><span class="line"><span class="function"><span class="comment">  #define afStatus_FAILED             ZFailure           // 0x01 </span></span></span><br><span class="line"><span class="function"><span class="comment">  #define afStatus_INVALID_PARAMETER  ZInvalidParameter  // 0x02 </span></span></span><br><span class="line"><span class="function"><span class="comment">  #define afStatus_MEM_FAIL           ZMemError          // 0x10 </span></span></span><br><span class="line"><span class="function"><span class="comment">  #define afStatus_NO_ROUTE           ZNwkNoRoute        // 0xCD </span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br></pre></td></tr></table></figure><p>这个函数看起来很像计算机网络中的网络层发送函数，在这里我们比较关心的是两个数据类型：<code>afAddrType_t</code>以及<code>endPointDesc_t</code>。这两个代表的是目的地址与源地址，下面就来看看这两个地址都是什么样的数据结构。先来看<code>afAddrType_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*afAddrType_t *dstAddr,  目的地址*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    uint16      shortAddr;</span><br><span class="line">    ZLongAddr_t extAddr;</span><br><span class="line">  &#125; addr;</span><br><span class="line">  afAddrMode_t addrMode;                 <span class="comment">//单播组播和广播选择</span></span><br><span class="line">  uint8 endPoint;                        <span class="comment">//目的端点</span></span><br><span class="line">  uint16 panId;                          <span class="comment">// used for the INTER_PAN feature</span></span><br><span class="line">&#125; afAddrType_t;</span><br></pre></td></tr></table></figure><p> 在这里，<code>addrMode</code>是模式选择选项，是一个枚举，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  afAddrNotPresent = AddrNotPresent,      <span class="comment">// 按照绑定表进行绑定传输</span></span><br><span class="line"></span><br><span class="line">  afAddr16Bit = Addr16Bit,                <span class="comment">// 指定目标网络地址进行单薄传输 16位</span></span><br><span class="line"></span><br><span class="line">  afAddrGroup = AddrGroup,                <span class="comment">// 组播传输</span></span><br><span class="line"></span><br><span class="line">  afAddrBroadcast = AddrBroadcast         <span class="comment">// 广播传输</span></span><br><span class="line"></span><br><span class="line">&#125; afAddrMode_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  AddrNotPresent = <span class="number">0</span>,</span><br><span class="line">  AddrGroup = <span class="number">1</span>,</span><br><span class="line">  Addr16Bit = <span class="number">2</span>,</span><br><span class="line">  Addr64Bit = <span class="number">3</span>,                          <span class="comment">// 指定IEEE地址进行单播传输 64位</span></span><br><span class="line"></span><br><span class="line">  AddrBroadcast = <span class="number">15</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>afAddrMode_t</code>中要特殊注意一下Addr16Bit这个变量，16Bit指的是16位的网络地址，ZigBee还有一个64位的MAC地址，由IEEE进行分配和维护。</p><p>16位的网络地址是设备加入网络后由协调器或者路由器分配的，可以在Tool目录下的<code>f8wConfig.cfg</code>中更改</p><p>然后再来看<code>endPointDesc_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*endPointDesc_t *srcEP,  源地址方*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint8 endPoint;                          <span class="comment">// 端点号</span></span><br><span class="line">  uint8 *task_id;                          <span class="comment">// 指向应用程序任务ID的位置的指针。</span></span><br><span class="line">  SimpleDescriptionFormat_t *simpleDesc;   <span class="comment">// 设备的简单描述</span></span><br><span class="line">  afNetworkLatencyReq_t latencyReq;        <span class="comment">// 枚举结构 必须用 noLatencyReqs 填充</span></span><br><span class="line">&#125; endPointDesc_t;</span><br></pre></td></tr></table></figure><p>其中的<code>SimpleDescriptionFormat_t</code>、<code>afNetworkLatencyReq_t</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  byte EndPoint;                          <span class="comment">// EP ID (EP=End Point)</span></span><br><span class="line">  uint16 AppProfId;                       <span class="comment">// profile ID（剖面ID）</span></span><br><span class="line">  uint16 AppDeviceId;                     <span class="comment">// Device ID</span></span><br><span class="line">  byte AppDevVer:<span class="number">4</span>;                       <span class="comment">// Device Version 0x00 为 Version 1.0</span></span><br><span class="line">  byte Reserved:<span class="number">4</span>;                        <span class="comment">// AF_V1_SUPPORT uses for AppFlags:4.</span></span><br><span class="line">  byte AppNumInClusters;                  <span class="comment">// 终端支持的输入簇的个数</span></span><br><span class="line">  cId_t *pAppInClusterList;               <span class="comment">// 指向输入Cluster ID列表的指针</span></span><br><span class="line">  byte AppNumOutClusters;                 <span class="comment">// 输出簇的个数</span></span><br><span class="line">  cId_t *pAppOutClusterList;              <span class="comment">// 指向输出Cluseter ID列表的指针</span></span><br><span class="line">&#125; SimpleDescriptionFormat_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  noLatencyReqs,</span><br><span class="line">  fastBeacons,</span><br><span class="line">  slowBeacons</span><br><span class="line">&#125; afNetworkLatencyReq_t;</span><br></pre></td></tr></table></figure><p>从这里可以看出来，只要设置好这几个参数之后就可以直接进行数据发送了。，具体的程序可以参见</p><p><code>GenericApp_SendTheMessage</code>，<code>GenericApp_Init</code></p><p>也就是说，通过简单的设置，我们就明白了数据收发的操作。但数据发送时又是如何绑定的呢？这个绑定又是如何实现的呢？请听下回分解</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZigBee协议栈探究—-（二）数据的接收与发送&quot;&gt;&lt;a href=&quot;#ZigBee协议栈探究—-（二）数据的接收与发送&quot; class=&quot;headerlink&quot; title=&quot;ZigBee协议栈探究—-（二）数据的接收与发送&quot;&gt;&lt;/a&gt;ZigBee协议栈探究—-（二）数据的接收与发送&lt;/h1&gt;&lt;h2 id=&quot;1-回顾&quot;&gt;&lt;a href=&quot;#1-回顾&quot; class=&quot;headerlink&quot; title=&quot;1.回顾&quot;&gt;&lt;/a&gt;1.回顾&lt;/h2&gt;&lt;p&gt;上一章讲解了ZigBee协议栈中函数的运行走向，了解了ZigBee的任务最终在&lt;code&gt;ProgressEvent&lt;/code&gt;这个函数中执行，那么在协议栈中这个函数在不改动的情况下究竟执行了什么？我们又应该如何改动它呢？我们又如何进行数据的发送与接收呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ZigBee" scheme="http://yokeso.top/tags/ZigBee/"/>
    
      <category term="CC2530" scheme="http://yokeso.top/tags/CC2530/"/>
    
      <category term="协议栈" scheme="http://yokeso.top/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>ZigBee协议栈探究---（一）OSAL</title>
    <link href="http://yokeso.top/2021/03/10/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%B8%80%EF%BC%89OSAL/"/>
    <id>http://yokeso.top/2021/03/10/ZigBee%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A2%E7%A9%B6---%EF%BC%88%E4%B8%80%EF%BC%89OSAL/</id>
    <published>2021-03-10T03:45:14.000Z</published>
    <updated>2021-03-11T15:43:53.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ZigBee协议栈探究—-（一）OSAL"><a href="#ZigBee协议栈探究—-（一）OSAL" class="headerlink" title="ZigBee协议栈探究—-（一）OSAL"></a>ZigBee协议栈探究—-（一）OSAL</h1><h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1.写在前面"></a>1.写在前面</h2><p>由于是毕设的要求，我开始再一次学习ZigBee协议栈。伴随着学的东西越来越多，代码结构也忘得越来越快。所以想把自己学的知识整理到几篇博客中，以方便自己随时翻看。我的记录主要是我学习时的思考历程，所以有些地方可能看着很乱。希望看这篇文章的人谅解。如果我学到的知识能帮助后人入门有些许帮助，对我来讲即是莫大的鼓励。</p><span id="more"></span><p>我的Zstack协议栈采用的是2.51a而不是最新的3.02版本。内核使用的是CC2530。这个内核是8051架构的，所以代码方面写起来和8051很像。</p><p>在硬件上我的目标是希望创建一套自己的终端传感器，所以有关于针脚的设置我会突出说明，并且也会另开坑记录自己设计PCB板子的心得。在记录的过程中我也会尽量的去挖掘一些内核以及操作系统的知识，</p><p>关于IAR的安装使用和工具的使用我不会详述，在网上有很多文档可以参考。</p><p>谢谢大家！现在正式开坑！</p><h2 id="2-文档结构"><a href="#2-文档结构" class="headerlink" title="2.文档结构"></a>2.文档结构</h2><p>第一次安装ZigBee协议栈，一般最大的问题就是文档结构。这里我想通过项目结构树的方式写出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Zstack-CC2530-<span class="number">2.5</span><span class="number">.1</span>a</span><br><span class="line">|-Components <span class="comment">#协议栈结构,包含协议栈的基本代码</span></span><br><span class="line">| |-hal  <span class="comment">#硬件层代码</span></span><br><span class="line">| |-mac  <span class="comment">#Mac层代码</span></span><br><span class="line">| |-mt   <span class="comment">#各层交互，通过串口联通</span></span><br><span class="line">| |-osal <span class="comment">#协议栈操作系统代码</span></span><br><span class="line">| |-services <span class="comment">#地址处理函数目录</span></span><br><span class="line">| |-stack <span class="comment">#</span></span><br><span class="line">| └-zmac  <span class="comment">#ZigBee Mac层参数配置和Lib库回调</span></span><br><span class="line">|-Documents  <span class="comment">#官方帮助文档，不详述结构</span></span><br><span class="line">|-ProJects   <span class="comment">#官方示例项目</span></span><br><span class="line">| └-zstack   <span class="comment">#代码都在下面这里</span></span><br><span class="line">|   |-HomeAutomation</span><br><span class="line">|   |-Libraries</span><br><span class="line">|   |-OTA</span><br><span class="line">|   |-Samples</span><br><span class="line">|   |-SE</span><br><span class="line">|   |-Tools</span><br><span class="line">|   |-Utilities</span><br><span class="line">|   |-ZBA</span><br><span class="line">|   |-ZMain <span class="comment">#Main函数所在位置</span></span><br><span class="line">|   └-ZNP</span><br><span class="line">|-Tools      <span class="comment">#官方调试工具集合</span></span><br><span class="line">| |-OTA</span><br><span class="line">| |-SBL Tool</span><br><span class="line">| |-Z-Concerter</span><br><span class="line">| |-ZOAD</span><br><span class="line">| └-Z-Tool</span><br><span class="line">|-Getting Started Guide-CC2530.pdf <span class="comment">#官方开始文档，很易懂</span></span><br></pre></td></tr></table></figure><p>想建立自己项目的话，可以查阅文档中的Create New Application For CC2530DB来查看。根据官方文档，需要串口数据的话就用SerialApp Project <code>...\Projects\zstack\Utilities.</code>,一切都从新开始的话可以用GenericApp project <code>...\Projects\zstack\Samples.</code></p><p>这里我使用SerialApp开始学习，并按照官方文档重命名为SmartHome。自此开始协议栈代码。后面的代码我也会用Smart_Home进行解说，这个函数对应的是自己设置的函数的名字</p><h2 id="3-从Main开始"><a href="#3-从Main开始" class="headerlink" title="3.从Main开始"></a>3.从Main开始</h2><p>面对工程文件中的庞大代码，最重要的自然是先去找Main函数。ZigBee的Main函数在<code>ZMain</code>下的<code>ZMain.c</code>中，可以看到Main是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      main</span></span><br><span class="line"><span class="comment"> * @brief   First function called after startup.</span></span><br><span class="line"><span class="comment"> * @return  don&#x27;t care</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//关闭所有中断</span></span><br><span class="line">  osal_int_disable( INTS_ALL );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化板子相关硬件（LED等）</span></span><br><span class="line">  HAL_BOARD_INIT();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查电源电压以确保运行</span></span><br><span class="line">  zmain_vdd_check();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化板载 I/O</span></span><br><span class="line">  InitBoard( OB_COLD );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化Hal层驱动</span></span><br><span class="line">  HalDriverInit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化NV系统</span></span><br><span class="line">  osal_nv_init( <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化Mac层</span></span><br><span class="line">  ZMacInit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//确定扩展地址</span></span><br><span class="line">  zmain_ext_addr();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ZCL_KEY_ESTABLISH</span></span><br><span class="line">  <span class="comment">//初始化Certicom证书信息</span></span><br><span class="line">  zmain_cert_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化基础NV事务</span></span><br><span class="line">  zgInit();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NONWK</span></span><br><span class="line">  <span class="comment">// Since the AF isn&#x27;t a task, call it&#x27;s initialization routine</span></span><br><span class="line">  afInit();<span class="comment">//初始化AF例程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化操作系统</span></span><br><span class="line">  osal_init_system();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//允许中断</span></span><br><span class="line">  osal_int_enable( INTS_ALL );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Final board initialization</span></span><br><span class="line">  InitBoard( OB_READY );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Display information about this device</span></span><br><span class="line">  zmain_dev_info();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Display the device info on the LCD */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LCD_SUPPORTED</span></span><br><span class="line">  zmain_lcd_init();   <span class="comment">//初始化LCD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WDT_IN_PM1</span></span><br><span class="line">  <span class="comment">/* If WDT is used, this is a good place to enable it. */</span></span><br><span class="line">  WatchDogEnable( WDTIMX );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  osal_start_system(); <span class="comment">//从这里开始运行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Shouldn&#x27;t get here.</span></span><br><span class="line">&#125; <span class="comment">// main()</span></span><br></pre></td></tr></table></figure><p>可以看出，在初始化之后真正开始运行程序的是<code>osal_start_system();</code>函数，所以从这里开始追踪。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      osal_start_system</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   This function is the main loop function of the task system (if</span></span><br><span class="line"><span class="comment"> *   ZBIT and UBIT are not defined). This Function doesn&#x27;t return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">osal_start_system</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined ( ZBIT ) &amp;&amp; !defined ( UBIT )</span></span><br><span class="line">  <span class="keyword">for</span>(;;)  <span class="comment">// Forever Loop</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    osal_run_system();  <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在osal_start_system里只调用了这个函数。所以继续跟踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      osal_run_system</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     此函数将遍历OSAL taskEvents表，并为发现至少有一个事件挂起</span></span><br><span class="line"><span class="comment"> *     的第一个任务调用task_event_processor（）函数。 如果没有</span></span><br><span class="line"><span class="comment"> *     待处理的事件（所有任务），则此功能可使处理器进入休眠状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">osal_run_system</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint8 idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  osalTimeUpdate();</span><br><span class="line">  Hal_ProcessPoll();<span class="comment">//UART轮询函数 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasksEvents[idx])        <span class="comment">//任务是已准备好的最高优先级。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;                     <span class="comment">//得到待处理的最高任务号 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (++idx &lt; tasksCnt);    <span class="comment">//这里的taskCnt是一个const uint8 任务总数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (idx &lt; tasksCnt)</span><br><span class="line">  &#123;</span><br><span class="line">    uint16 events;</span><br><span class="line">    halIntState_t intState;      <span class="comment">//typedef unsigned char </span></span><br><span class="line"></span><br><span class="line">    HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">//进入临界区</span></span><br><span class="line">    events = tasksEvents[idx];   <span class="comment">//将task号变成事件号</span></span><br><span class="line">    tasksEvents[idx] = <span class="number">0</span>;        <span class="comment">//将数组中的事件号改成0表明任务正在处理</span></span><br><span class="line">    HAL_EXIT_CRITICAL_SECTION(intState);  <span class="comment">//退出临界区</span></span><br><span class="line"></span><br><span class="line">    activeTaskID = idx;          <span class="comment">//正在处理的事件的事件号</span></span><br><span class="line">    events = (tasksArr[idx])( idx, events ); <span class="comment">//真正将事件号放入了事件的结构数组taxksArr[]</span></span><br><span class="line">    activeTaskID = TASK_NO_TASK;</span><br><span class="line"></span><br><span class="line">    HAL_ENTER_CRITICAL_SECTION(intState);  <span class="comment">//进入临界区</span></span><br><span class="line">    tasksEvents[idx] |= events;  <span class="comment">// 返回未处理的事件</span></span><br><span class="line">    HAL_EXIT_CRITICAL_SECTION(intState);   <span class="comment">//推出临界区</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined( POWER_SAVING )</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// Complete pass through all task events with no activity?</span></span><br><span class="line">  &#123;</span><br><span class="line">    osal_pwrmgr_powerconserve();  <span class="comment">// Put the processor/system into sleep</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Yield in case cooperative scheduling is being used. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (configUSE_PREEMPTION) &amp;&amp; (configUSE_PREEMPTION == 0)</span></span><br><span class="line">  &#123;</span><br><span class="line">    osal_task_yield();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过阅读源码和注释，我们知道，这个函数主要就是将任务列表<code>tasksEvents</code>中第<code>idx</code>号任务放入事件<code>event</code>中转化为<code>tesksEvents</code>进行处理。在这里有一个<code>tasksArr[idx]</code>，这个数组很关键，我们之后会提到他。但是首先我们需要知道这个<code>idx</code>号与任务是如何对应的呢？这就还要看回main中的<code>osal_init_system();</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      osal_init_system</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   This function initializes the &quot;task&quot; system by creating the</span></span><br><span class="line"><span class="comment"> *   tasks defined in the task table (OSAL_Tasks.h).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  SUCCESS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uint8 <span class="title">osal_init_system</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the Memory Allocation System</span></span><br><span class="line">  osal_mem_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the message queue</span></span><br><span class="line">  osal_qHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the timers</span></span><br><span class="line">  osalTimerInit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the Power Management System</span></span><br><span class="line">  osal_pwrmgr_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize the system tasks.</span></span><br><span class="line">  osalInitTasks();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup efficient search for the first free block of heap.</span></span><br><span class="line">  osal_mem_kick();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ( SUCCESS );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中与系统任务中有关系的只有一个函数<code>osalInitTasks();</code>，我们直接进入这里看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * @fn      osalInitTasks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief   This function invokes the initialization function for each task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">osalInitTasks</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint8 taskID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tasksEvents = (uint16 *)osal_mem_alloc( <span class="keyword">sizeof</span>( uint16 ) * tasksCnt); <span class="comment">//分配内存返回缓冲区指针</span></span><br><span class="line">  osal_memset( tasksEvents, <span class="number">0</span>, (<span class="keyword">sizeof</span>( uint16 ) * tasksCnt)); <span class="comment">//设置所分配内存空间单元值0</span></span><br><span class="line"></span><br><span class="line">  macTaskInit( taskID++ ); <span class="comment">//macTaskInit(0) ，用户不需考虑</span></span><br><span class="line">  nwk_init( taskID++ ); <span class="comment">//nwk_init(1)，用户不需考虑</span></span><br><span class="line">  Hal_Init( taskID++ ); <span class="comment">//Hal_Init(2) ，用户需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined( MT_TASK )</span></span><br><span class="line">  MT_TaskInit( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  APS_Init( taskID++ );  <span class="comment">//APS_Init(3) ，用户不需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line">  APSF_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ZDApp_Init( taskID++ ); <span class="comment">//ZDApp_Init(4) ，用户需考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line">  ZDNwkMgr_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Smart_home_Init( taskID ); <span class="comment">//用户任务初始化用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这个函数中可见，在这里<code>taskID</code>进行了初始化，每初始化一个<code>taskID++</code>，其中<code>Hal_Init</code>和<code>Smart_Home_Init</code>是用户需要考虑的，（第一个可以放传感器的任务，第二个可以初始化应用层的用户任务）</p><p>也就是说，用户处理进程包括串口信息都要在这里形成任务号。那下一步就来看看这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Smart_home_Init</span><span class="params">( uint8 task_id )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  halUARTCfg_t uartConfig;</span><br><span class="line"></span><br><span class="line">  Smart_home_TaskID = task_id;</span><br><span class="line">  Smart_home_RxSeq = <span class="number">0xC3</span>;</span><br><span class="line"></span><br><span class="line">  afRegister( (endPointDesc_t *)&amp;Smart_home_epDesc );</span><br><span class="line"></span><br><span class="line">  RegisterForKeys( task_id );</span><br><span class="line"></span><br><span class="line">  uartConfig.configured           = TRUE;              <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.baudRate             = SERIAL_APP_BAUD;</span><br><span class="line">  uartConfig.flowControl          = TRUE;</span><br><span class="line">  uartConfig.flowControlThreshold = SERIAL_APP_THRESH; <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.rx.maxBufSize        = SERIAL_APP_RX_SZ;  <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.tx.maxBufSize        = SERIAL_APP_TX_SZ;  <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.idleTimeout          = SERIAL_APP_IDLE;   <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.intEnable            = TRUE;              <span class="comment">// 2x30 don&#x27;t care - see uart driver.</span></span><br><span class="line">  uartConfig.callBackFunc         = Smart_home_CallBack;</span><br><span class="line">  HalUARTOpen (SERIAL_APP_PORT, &amp;uartConfig);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( LCD_SUPPORTED )</span></span><br><span class="line">  HalLcdWriteString( <span class="string">&quot;Smart_home&quot;</span>, HAL_LCD_LINE_2 );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  ZDO_RegisterForZDOMsg( Smart_home_TaskID, End_Device_Bind_rsp );</span><br><span class="line">  ZDO_RegisterForZDOMsg( Smart_home_TaskID, Match_Desc_rsp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中大部分的内容是初始化UART端口，并向LCD显示了<code>Smart_home</code>这样一串字符串。但上面有一个语句值得注意：<code>afRegister( (endPointDesc_t *)&amp;Smart_home_epDesc );</code>在步入这个函数查阅函数说明后发现这个函数是希望利用<code>epDesc</code>（也就是程序中的<code>Smart_home_epDesc</code>）这个指向应用程序端点描述符的指针来注册应用程序端点描述，并返回三个值中的一个（已注册、没有足够的内存来添加描述符、重复的端点）。</p><p>先不要着急了解这句话是什么意思，在<code>Smart_home_Init</code>的最下方还有两句话调用了同一个函数<code>ZDO_RegisterForZDOMsg()</code>，这是一个ZDO层的函数，所谓的ZDO层就是<code>ZigBee Device Object</code>设备对象层，通过端点0使应用程序与其他层通信。<code>ZDO_RegisterForZDOMsg()</code>在相应的任务中注册事件（每个事件智能被成功注册一次），将注册信息通过ZDO_Msg_t的形式加入到链表中，这个链表的头指针在zdoMsgCbs中保留。</p><p>对于上面这两段话我们又见到了一个新名词——-端点，所谓的端点也可以理解为电脑的端口号，一个ZigBee设备中有240个端点，他们共享一个网络地址，程序之间的通信则是通过确认端点号来区分数据是发送给该设备的哪个端点的。</p><p>那么按照这样，我们就找到了从应用层发送消息的路径。由<code>ZDO_RegisterForZDOMsg()</code>绑定然后从<code>afRegister</code>创建事件。这个任务在绑定之后，进入处理池进行处理的又是哪个函数呢？</p><p>这就要回到函数<code>osal_run_system()</code>中了，在这个函数中可以注意到这样几句话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activeTaskID = idx;          <span class="comment">//正在处理的事件的事件号</span></span><br><span class="line">events = (tasksArr[idx])( idx, events ); <span class="comment">//真正将事件号放入了事件的结构数组taxksArr[]</span></span><br><span class="line">activeTaskID = TASK_NO_TASK;</span><br></pre></td></tr></table></figure><p>这里使用了一个叫做<code>taskArr[idx]</code>的数组，进入数组定义可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * GLOBAL VARIABLES</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The order in this table must be identical to the task initialization calls below in osalInitTask.</span></span><br><span class="line"><span class="keyword">const</span> pTaskEventHandlerFn tasksArr[] = &#123;</span><br><span class="line">  macEventLoop,</span><br><span class="line">  nwk_event_loop,</span><br><span class="line">  Hal_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined( MT_TASK )</span></span><br><span class="line">  MT_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  APS_event_loop,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line">  APSF_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ZDApp_event_loop,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line">  ZDNwkMgr_event_loop,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Smart_home_ProcessEvent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">与Smart_home_Init中事件的对比，注意看事件的顺序</span></span><br><span class="line"><span class="comment">  macTaskInit( taskID++ ); //macTaskInit(0) ，用户不需考虑</span></span><br><span class="line"><span class="comment">  nwk_init( taskID++ ); //nwk_init(1)，用户不需考虑</span></span><br><span class="line"><span class="comment">  Hal_Init( taskID++ ); //Hal_Init(2) ，用户需考虑</span></span><br><span class="line"><span class="comment">#if defined( MT_TASK )</span></span><br><span class="line"><span class="comment">  MT_TaskInit( taskID++ );</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">  APS_Init( taskID++ );  //APS_Init(3) ，用户不需考虑</span></span><br><span class="line"><span class="comment">#if defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line"><span class="comment">  APSF_Init( taskID++ );</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">  ZDApp_Init( taskID++ ); //ZDApp_Init(4) ，用户需考虑</span></span><br><span class="line"><span class="comment">#if defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line"><span class="comment">  ZDNwkMgr_Init( taskID++ );</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">  Smart_home_Init( taskID ); //用户任务初始化用</span></span><br><span class="line"><span class="comment">  **************************************************************/</span></span><br></pre></td></tr></table></figure><p>这是一个全局变量数组，通过上面的这里面的事件是正好按照之前<code>taskID</code>的顺序排列的。也就是说，我们的任务应该设置在<code>Smart_home_ProcessEvent</code>中。</p><p>这样一来我们的流程也就捋顺了。我在下面放一个流程图来方便大家理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD </span><br><span class="line">main--初始化系统--&gt;osal_init_system</span><br><span class="line">main--运行系统--&gt;A[osal_run_system]</span><br><span class="line">osal_init_system--初始化任务--&gt;osalInitTasks</span><br><span class="line">osalInitTasks--分配任务号--&gt;C[Smart_home_Init]</span><br><span class="line">C--注册任务端点描述--&gt;afRegister...</span><br><span class="line">C--向下传输并加入链表--&gt;ZDO_RegisterForZDOMsg</span><br><span class="line">A--&gt;idx</span><br><span class="line">A--执行任务队列--&gt;tasksArr</span><br><span class="line">A--执行任务链表--&gt;taskEvents</span><br><span class="line">tasksArr--执行用户任务--&gt;B[Smart_home_ProcessEvents]</span><br><span class="line">C--对应---B</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>经过对代码的阅读我们发现，OSAL的执行过程就是在初始化之后从任务池中查询任务并执行。而用户函数需要做的则是写出自己的函数并将其赋予事件号放入事件池中等待OSAL执行。但我们使用协议栈的时候最重要的就是收发消息。这个又是怎么实现的呢？我们下次分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ZigBee协议栈探究—-（一）OSAL&quot;&gt;&lt;a href=&quot;#ZigBee协议栈探究—-（一）OSAL&quot; class=&quot;headerlink&quot; title=&quot;ZigBee协议栈探究—-（一）OSAL&quot;&gt;&lt;/a&gt;ZigBee协议栈探究—-（一）OSAL&lt;/h1&gt;&lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1.写在前面&quot;&gt;&lt;/a&gt;1.写在前面&lt;/h2&gt;&lt;p&gt;由于是毕设的要求，我开始再一次学习ZigBee协议栈。伴随着学的东西越来越多，代码结构也忘得越来越快。所以想把自己学的知识整理到几篇博客中，以方便自己随时翻看。我的记录主要是我学习时的思考历程，所以有些地方可能看着很乱。希望看这篇文章的人谅解。如果我学到的知识能帮助后人入门有些许帮助，对我来讲即是莫大的鼓励。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ZigBee" scheme="http://yokeso.top/tags/ZigBee/"/>
    
      <category term="CC2530" scheme="http://yokeso.top/tags/CC2530/"/>
    
      <category term="协议栈" scheme="http://yokeso.top/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>NaiveBayes</title>
    <link href="http://yokeso.top/2021/01/11/NaiveBayes/"/>
    <id>http://yokeso.top/2021/01/11/NaiveBayes/</id>
    <published>2021-01-11T09:30:04.000Z</published>
    <updated>2021-03-09T12:01:54.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>logistic回归：本质是对$p(y|\vec x)$进行建模</p><span id="more"></span><p>贝叶斯公式：求$\vec x$和y的联合概率（联合分布）$p(y|\vec x) = \frac {p(\vec x,y)}{p(\vec x)}$</p><p>判别模型：对$p(y|\vec x)$进行建模，且$\sum_{y}p(y|\vec x)=1$（分类问题）</p><p>生成模型：对$p(\vec x,y)$进行建模，且$\sum_{y}p(\vec x,y)=1$（联合分布）</p><p>决策函数：$\hat y =argmax_cp(\vec x,c)=argmax_cp(c)\prod p(\vec x_i,c)$</p><p>样本修正（拉普拉斯修正）</p><script type="math/tex; mode=display">\breve p(x_i|c)=\frac{|D_{c_i}x_i|+1}{|D_c|+N_i}</script><p>分子加1是为了避免0概率，分母则是为了将第i个特征的可能取值数添加进去</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;朴素贝叶斯&quot;&gt;&lt;a href=&quot;#朴素贝叶斯&quot; class=&quot;headerlink&quot; title=&quot;朴素贝叶斯&quot;&gt;&lt;/a&gt;朴素贝叶斯&lt;/h2&gt;&lt;p&gt;logistic回归：本质是对$p(y|\vec x)$进行建模&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ANNs</title>
    <link href="http://yokeso.top/2021/01/11/ANNs/"/>
    <id>http://yokeso.top/2021/01/11/ANNs/</id>
    <published>2021-01-11T09:29:06.000Z</published>
    <updated>2021-03-09T12:01:43.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p>神经网络解决的问题是线性不可分的问题，但线性不可分问题可以拆分为线性运算的组合</p><span id="more"></span><h3 id="1-神经网络结构"><a href="#1-神经网络结构" class="headerlink" title="1.神经网络结构"></a>1.神经网络结构</h3><p>可以将感知机看作是一种单层神经网络，可以解决线性问题</p><p>那么多层感知机就被称为神经网络，用来解决线性不可分问题</p><h3 id="2-模型表示（全链接）"><a href="#2-模型表示（全链接）" class="headerlink" title="2.模型表示（全链接）"></a>2.模型表示（全链接）</h3><p>假设$z_i^{(l)}$是第l层第i个神经单元的的净输入，$a_i^{(l)}$是第l层第i个神经单元的的激活值，$g_l(.)$是第l层的激活函数</p><p>最终模型的表达无法表示，但每一层的均可知：</p><script type="math/tex; mode=display">\vec {z^{(l)}} = (\vec{w^{(l)}})^T\vec{a^{(l-1)}}+\vec{b^{(l)}}</script><p>前向传播：$\vec x =\vec {a^{(0)}}\rightarrow (\vec {z^{(1)}}\rightarrow\vec {a^{(1)}})\rightarrow……\rightarrow(\vec {z^{(l)}}\rightarrow\vec {a^{(l)}}=h_{\vec w,\vec b}(x))$</p><h3 id="3-损失函数（多分类为例）"><a href="#3-损失函数（多分类为例）" class="headerlink" title="3.损失函数（多分类为例）"></a>3.损失函数（多分类为例）</h3><p>设最后一层的激活函数是softmax，即$\vec {a^{(l)}} = softmax(\vec {z^{(l)}})$</p><script type="math/tex; mode=display">J_{\vec w,\vec b}(h_{\vec w,\vec b}(\vec x),\vec y) = -\frac {1}{m} \sum_{i=1}^m \sum_{c=1}^Cy^{(i)}log((h_{\vec w,\vec b}(\vec x^{(i)})_c</script><h3 id="5-优化方法"><a href="#5-优化方法" class="headerlink" title="5.优化方法"></a>5.优化方法</h3><p>1.梯度下降</p><p>2.反向传播</p><h3 id="7-自动梯度计算"><a href="#7-自动梯度计算" class="headerlink" title="7.自动梯度计算"></a>7.自动梯度计算</h3><p>数值微分，符号微分（对公式求导）、自动微分$\Rightarrow$计算图</p><h3 id="8-激活函数"><a href="#8-激活函数" class="headerlink" title="8.激活函数"></a>8.激活函数</h3><p>1.Sigmoid</p><script type="math/tex; mode=display">Sigmoid： h_{\vec \theta}(\vec x) = \frac {1} {1+e^{-{\vec \theta}^T \vec x}}</script><p>2.Softmax</p><script type="math/tex; mode=display">Softmax:h_{\vec \theta}(\vec x) = \frac {e^{-{\vec \theta}_c^T \vec x}} {\sum_{i=1}^Ne^{-{\vec \theta}^T \vec x}}</script><p>3.Relu</p><script type="math/tex; mode=display">Relu(x) = \begin{cases} x& x\geq0\\ 0& x=0 \end{cases}</script><p>4.LeakyRelu</p><script type="math/tex; mode=display">LeakyRelu(x) = \begin{cases} x& x\geq0\\ \delta x& x=0 \end{cases}</script><p>5.swish函数</p><script type="math/tex; mode=display">swish(x) = x\times Sigmoid(\beta x)</script><p>$\beta$是可学习固定参数或者超参数</p><p>6.maxout</p><script type="math/tex; mode=display">maxout(\vec z)=max_{k\in (l,k)}z_k \</script><h3 id="9-卷积神经网络"><a href="#9-卷积神经网络" class="headerlink" title="9.卷积神经网络"></a>9.卷积神经网络</h3><p>全连接NN无法表示局部不变特征（无法胜任图像分类）</p><p>所以需要卷积神经网络来进行扩展，卷积神经网络学习的参数是卷积核的参数</p><p>这里的卷积表示的是直接对位相乘$\vec r = \vec w *\vec x$ </p><p>基本结构：一般由卷积层,polling层（降采样层）和全连接层构成</p><h3 id="10-循环神经网络RNN"><a href="#10-循环神经网络RNN" class="headerlink" title="10.循环神经网络RNN"></a>10.循环神经网络RNN</h3><p>用来处理具有时序的数据</p><script type="math/tex; mode=display">\vec h_t=g(\vec w \vec h_{t-1}+\vec w \vec x_t +\vec b)</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人工神经网络&quot;&gt;&lt;a href=&quot;#人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;人工神经网络&quot;&gt;&lt;/a&gt;人工神经网络&lt;/h2&gt;&lt;p&gt;神经网络解决的问题是线性不可分的问题，但线性不可分问题可以拆分为线性运算的组合&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SVM</title>
    <link href="http://yokeso.top/2021/01/11/SVM/"/>
    <id>http://yokeso.top/2021/01/11/SVM/</id>
    <published>2021-01-11T09:28:20.000Z</published>
    <updated>2021-03-09T12:02:08.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="1-模型表示"><a href="#1-模型表示" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><p>支持向量机是一种二分类的广义分类器，其假设函数为</p><span id="more"></span><script type="math/tex; mode=display">h_{\vec \theta}(\vec x)=\vec \theta^T\vec x</script><p>决策函数为：</p><script type="math/tex; mode=display">\hat y=sgn(h_{\vec \theta}(\vec x))</script><h3 id="2-优化准则"><a href="#2-优化准则" class="headerlink" title="2.优化准则"></a>2.优化准则</h3><p>支持向量机运行的是基于边界决策的优化准则，决策边界不止一条 = 模型参数不唯一这种时候就要寻找中间线。</p><script type="math/tex; mode=display">h_{\vec \theta}(\vec x)=\vec \theta^T\vec x = \theta_0+\theta_1x_1+......+\theta_nx_n (增广形式)</script><p>使$b=\theta_0$,其余部分视为$\vec w^T\vec x$的话，那么寻找中间决策线的方程就可以表述为：</p><script type="math/tex; mode=display">\vec w^T\vec x+b=\vec 0</script><h4 id="1-点到超平面的距离"><a href="#1-点到超平面的距离" class="headerlink" title="1.点到超平面的距离"></a>1.点到超平面的距离</h4><script type="math/tex; mode=display">r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}</script><p>其中，$||\vec w||$表示一个二范数的模，这个式子的大前提是同时使得正样本大于0，负样本小于0</p><p>在r的集合中，间隔定义为$r = min<em>ir^{(i)}$,间隔最大化则是求$max</em>{\vec w,b} r$的过程</p><p>最终约束条件：</p><script type="math/tex; mode=display">r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}S>=r</script><h3 id="3-优化目标loss"><a href="#3-优化目标loss" class="headerlink" title="3.优化目标loss"></a>3.优化目标loss</h3><script type="math/tex; mode=display">max_{\vec w,b} r,s.t.  r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}S>=r</script><p>loss的意义：平行超平面$\vec w^T\vec x+b_1=0$与$\vec w^T\vec x+b_2=0$之间的距离</p><script type="math/tex; mode=display">d=\frac {b_1-b_2}{\vec w}</script><p>即辅助决策边界之间的距离$d=\frac{2}{||\vec w||}$</p><p>loss的最大化的d就是让决策边界到正负样本之间的安全距离最大</p><h3 id="4-参数求解（对偶优化）"><a href="#4-参数求解（对偶优化）" class="headerlink" title="4.参数求解（对偶优化）"></a>4.参数求解（对偶优化）</h3><p>原问题：</p><script type="math/tex; mode=display">min_{\vec w,b}J(\vec w)=min_{\vec w,b}\frac{1}{2}||\vec w||^2 ,\quad s.t. \quad 1-y^{(i)}(\vec w^T\vec x^{(i)}+b) \leq 0,\forall i\in (1,2...m)</script><p>构造拉格朗日函数：</p><script type="math/tex; mode=display">L(\vec w,b,\vec \alpha) =\frac{1}{2}||\vec w||^2+\sum_{i=1}^m \alpha_i(1-y_i(\vec w^T\vec x^{(i)}+b))</script><p>等价于：</p><script type="math/tex; mode=display">min_{\vec w,b}\quad max_{\vec \alpha}L(\vec w,b,\vec \alpha)\quad s.t. \quad \alpha_i \geq0,\forall i\in (1,2...m)</script><p>由于强对偶性，交换min,max下的$\vec w,b与\vec \alpha$也同样成立</p><p>求解对偶问题的过程就是求拉格朗日函数的过程。</p><p>对偶问题的等价推广条件：KKT条件</p><ul><li>$g(\vec \theta)\leq 0$ 原问题可行</li><li>$\vec \alpha\geq0$ 对偶问题可行</li><li>$g(\vec \theta)\vec \alpha=\vec 0$互补松弛</li></ul><p>其中$\vec {\theta^*}$是$\vec \theta$的最优解</p><h5 id="决策函数"><a href="#决策函数" class="headerlink" title="决策函数"></a>决策函数</h5><script type="math/tex; mode=display">\vec {w^*}=\sum_{i=1}^m \alpha_i^*y^{(i)}\vec x^{(i)}\Rightarrow \alpha_i^*=0的样本对\vec {w^*}无贡献</script><script type="math/tex; mode=display">\hat y = sgn(h\vec{w^*},b^*(\vec x))=sgn((\vec{w^*})^T\vec x+b)=sgn(\sum_{i=1}^m \alpha_i^*y^{(i)}{\vec x^{(i)}}^T\vec x^{(i)}+b^*)</script><h3 id="5-SVM优点"><a href="#5-SVM优点" class="headerlink" title="5.SVM优点"></a>5.SVM优点</h3><ol><li>小样本学习（但学习过程中所有样本依然参与运算，给少量样本和大量样本意义相同）</li><li>分类鲁棒性高</li><li>理论上可得全局最优解</li></ol><h3 id="6-软间隔（线性不可分的情况）"><a href="#6-软间隔（线性不可分的情况）" class="headerlink" title="6.软间隔（线性不可分的情况）"></a>6.软间隔（线性不可分的情况）</h3><p>由于线性不可分，则无论什么分法都会将样本分错。可以设$\varepsilon$作为对难分样本的容忍度，loss就是要获得最小的$\varepsilon_i$,公式为</p><script type="math/tex; mode=display">min_{\vec w,b,\varepsilon}J(\vec w)=min_{\vec w,b,\varepsilon}\frac{1}{2}||\vec w||^2+C\sum_{i=1}^m\varepsilon_i ,\quad s.t. \quad y^{(i)}(\vec w^T\vec x^{(i)}+b) \geq 1,\forall i\in (1,2...m)\quad \varepsilon_i\geq0</script><p>这里的C是一个常数，用来调和两项的系数</p><h4 id="软间隔的优化目标"><a href="#软间隔的优化目标" class="headerlink" title="软间隔的优化目标"></a>软间隔的优化目标</h4><p>拉格朗日函数：</p><script type="math/tex; mode=display">L(\vec w,b,\vec \varepsilon ,\vec \alpha,\vec \mu) =(\frac{1}{2}||\vec w||^2+C\sum_{i=1}^m\varepsilon_i)+\sum_{i=1}^m \alpha_i(1-y^{(i)}(\vec w^T\vec x^{(i)}+b)-\varepsilon_i)-\sum_{i=1}^m\mu+\varepsilon_i</script><p>软间隔支持的向量满足：$y^{(i)}(\vec w^T\vec x^{(i)}+b)+\varepsilon_i=1$</p><p>优点：小样本学习，可以容忍一些难以分类的样本点</p><h3 id="7-核技巧解线性不可分问题"><a href="#7-核技巧解线性不可分问题" class="headerlink" title="7.核技巧解线性不可分问题"></a>7.核技巧解线性不可分问题</h3><p>核技巧的基本思想是：低维线性不可分的问题可以转化为高维线性可分的问题</p><p>核函数表示：</p><script type="math/tex; mode=display">k(\vec x,\vec z) = \phi(\vec x)^T \phi(\vec z)</script><p>这是对特征距离的一种重新度量。</p><p>常用和函数：</p><script type="math/tex; mode=display">\begin{aligned}k(\vec x,\vec z) &= \vec x^T \vec z  \quad (线性)\\&=(\vec x^T \vec z+c)^d \quad (多项式)\\&=exp(-\frac{||\vec x-\vec z||_2^2}{2\delta^2}) \quad (高斯)\end{aligned}</script><h2 id="线性模型总结"><a href="#线性模型总结" class="headerlink" title="线性模型总结"></a>线性模型总结</h2><p><img src="/2021/01/11/SVM/image-20210112160624373.png" alt="image-20210112160624373"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;支持向量机&quot;&gt;&lt;a href=&quot;#支持向量机&quot; class=&quot;headerlink&quot; title=&quot;支持向量机&quot;&gt;&lt;/a&gt;支持向量机&lt;/h2&gt;&lt;h3 id=&quot;1-模型表示&quot;&gt;&lt;a href=&quot;#1-模型表示&quot; class=&quot;headerlink&quot; title=&quot;1.模型表示&quot;&gt;&lt;/a&gt;1.模型表示&lt;/h3&gt;&lt;p&gt;支持向量机是一种二分类的广义分类器，其假设函数为&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>enntropy</title>
    <link href="http://yokeso.top/2021/01/11/enntropy/"/>
    <id>http://yokeso.top/2021/01/11/enntropy/</id>
    <published>2021-01-11T09:27:56.000Z</published>
    <updated>2021-03-09T12:02:19.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="几种熵的介绍"><a href="#几种熵的介绍" class="headerlink" title="几种熵的介绍"></a>几种熵的介绍</h2><h3 id="1-信息熵"><a href="#1-信息熵" class="headerlink" title="1.信息熵"></a>1.信息熵</h3><p>给定随机变量x,在系统中可能的输出为x1,x2….xn,这些输出对应发生的概率为p(x1),p(x2)…p(xn)</p><span id="more"></span><p>这时x的熵的定义为：</p><script type="math/tex; mode=display">H(x) = -\sum_{i=1}^n p(x_i)log(p(x_i))</script><p>这个值是非负的，意义是对于不确定性的度量。当等概率出现时，不确定性达到最大，此时系统最公平</p><h3 id="2-相对熵"><a href="#2-相对熵" class="headerlink" title="2.相对熵"></a>2.相对熵</h3><p>给定随机变量x，有两个离散概率分布$\vec p$和$\vec q$，$\vec p$相对于$\vec q$的相对熵定义为</p><script type="math/tex; mode=display">D_{kl}(\vec p||\vec q)=-\sum_{i=1}^n p(x_i)log(\frac{p(x_i)}{q(x_i)})</script><p>这种定义的意义是对两个概率分布p和q的分布差异的度量</p><p>具有非负性$D<em>{kl}(\vec p||\vec q)$&gt;=0,并且$D</em>{kl}(\vec p||\vec q)\not = D_{kl}(\vec q||\vec p)$</p><h3 id="3-交叉熵"><a href="#3-交叉熵" class="headerlink" title="3.交叉熵"></a>3.交叉熵</h3><p>交叉熵也要给定x和离散概率分布$\vec p$和$\vec q$，则交叉熵可定义为：</p><script type="math/tex; mode=display">H(\vec p,\vec q) = H(\vec p)+D_{kl}(\vec p||\vec q)</script><script type="math/tex; mode=display">=-\sum_{i=1}^n p(x_i)log(q(x_i))</script><p>是用于估计概率分布q相对于真实概率分布p的度量，具有非负性，所以可以作为loss使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;几种熵的介绍&quot;&gt;&lt;a href=&quot;#几种熵的介绍&quot; class=&quot;headerlink&quot; title=&quot;几种熵的介绍&quot;&gt;&lt;/a&gt;几种熵的介绍&lt;/h2&gt;&lt;h3 id=&quot;1-信息熵&quot;&gt;&lt;a href=&quot;#1-信息熵&quot; class=&quot;headerlink&quot; title=&quot;1.信息熵&quot;&gt;&lt;/a&gt;1.信息熵&lt;/h3&gt;&lt;p&gt;给定随机变量x,在系统中可能的输出为x1,x2….xn,这些输出对应发生的概率为p(x1),p(x2)…p(xn)&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Perceptron</title>
    <link href="http://yokeso.top/2021/01/11/Perceptron/"/>
    <id>http://yokeso.top/2021/01/11/Perceptron/</id>
    <published>2021-01-11T06:50:22.000Z</published>
    <updated>2021-03-09T12:02:30.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>有证据表明，人脑就是利用相同的算法来理解不同的输入，感知机就是利用这种思想，将不同的输入放入同一个模型进行预测分析，从而得到结果。</p><span id="more"></span><h3 id="1-感知机模型表示"><a href="#1-感知机模型表示" class="headerlink" title="1.感知机模型表示"></a>1.感知机模型表示</h3><p><img src="/2021/01/11/Perceptron/1.jpg" alt="1" style="zoom: 25%;"></p><h3 id="2-感知机的loss与参数学习"><a href="#2-感知机的loss与参数学习" class="headerlink" title="2.感知机的loss与参数学习"></a>2.感知机的loss与参数学习</h3><script type="math/tex; mode=display">J(\vec \theta) = \frac {1}{m} \sum_{i=1}^M max(0,-y^{(i)}\vec \theta^T \vec x^{(i)})</script><script type="math/tex; mode=display">其中\vec \theta^T \vec x^{(i)}也就是h_{\vec \theta}(\vec x)</script><p>准则：只有计算符号预测错误时的loss(ReLu)</p><p>那么，梯度下降的方式改变也就很明显了</p><script type="math/tex; mode=display">\vec \theta ：= \vec \theta-\alpha\frac {\delta J_{\vec \theta}}{\vec{\theta_j}}</script><script type="math/tex; mode=display">\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} = \begin{cases} 0& {y\vec \theta^T \vec x}>=0\\ -y\vec x& {y\vec \theta^T \vec x}<0 \end{cases}</script><h3 id="4-多分类感知机"><a href="#4-多分类感知机" class="headerlink" title="4.多分类感知机"></a>4.多分类感知机</h3><p>多分类的感知机和单分类的最大区别是多分类只取损失最大的类进行更新，其损失函数为</p><script type="math/tex; mode=display">J(\vec \theta) = \frac {1}{m} \sum_{i=1}^M max(0,max_{j=0...C}(\vec \theta_j\vec x^{(i)}-\vec \theta_{y^{(i)}}^T \vec x^{(i)}))</script><script type="math/tex; mode=display">\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} = \begin{cases} 0& c'=y^{(i)} \\ \vec x^{(i)}& j=c' \\-\vec x^{(i)}& j=y^{(i)}\end{cases} 其中C'=argmax_{j=1.2..C}\theta_j^T \vec x</script><p>损失函数特点：（要和极大似然函数分清）</p><ul><li>J&gt;=0(非负性)</li><li>J可导但不要求处处可倒</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;感知机&quot;&gt;&lt;a href=&quot;#感知机&quot; class=&quot;headerlink&quot; title=&quot;感知机&quot;&gt;&lt;/a&gt;感知机&lt;/h2&gt;&lt;p&gt;有证据表明，人脑就是利用相同的算法来理解不同的输入，感知机就是利用这种思想，将不同的输入放入同一个模型进行预测分析，从而得到结果。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>logistic回归与softmax回归</title>
    <link href="http://yokeso.top/2021/01/11/logistic%E5%9B%9E%E5%BD%92%E4%B8%8Esoftmax%E5%9B%9E%E5%BD%92/"/>
    <id>http://yokeso.top/2021/01/11/logistic%E5%9B%9E%E5%BD%92%E4%B8%8Esoftmax%E5%9B%9E%E5%BD%92/</id>
    <published>2021-01-11T01:59:06.000Z</published>
    <updated>2021-03-09T11:59:24.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>逻辑回归问题不是回归问题，而是一种分类问题，默认为二分类</p><h3 id="1-模型表示"><a href="#1-模型表示" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><span id="more"></span><script type="math/tex; mode=display">Sigmoid： h_{\vec \theta}(\vec x) = \frac {1} {1+e^{-{\vec \theta}^T \vec x}}</script><p>物理意义：这是$h_{\vec \theta}(\vec x)$是$\vec x$为正样本的概率（输出为1的概率）是人为规定的，用指数形式表示是为了加大两个概率之间的区别。</p><h3 id="2-分类的决策"><a href="#2-分类的决策" class="headerlink" title="2.分类的决策"></a>2.分类的决策</h3><p>在分类问题中，函数只会输出$h_{\vec \theta}(\vec x)$中$\vec x$属于某一种类的概率，但没有给出样本究竟属于哪一类，所以就需要利用决策函数进行分类。</p><p>决策函数：$\hat y = f(x)= \begin{cases} 0&amp; \text{g(z)<0.5}\\ 1& \text{g(z)>= 0.5} \end{cases}$</0.5}\\></p><h3 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3.损失函数"></a>3.损失函数</h3><script type="math/tex; mode=display">loss：Cost(h_{\vec \theta}(\vec x^{(i)}),y^{(i)})\begin{cases} -log(h_{\vec \theta}(\vec x^{(i)})& \text{y^{(i)}=1}\\ -log(1-h_{\vec \theta}(\vec x^{(i)})& \text{y =0} \end{cases}</script><p>类似于$-p_ilogq_i$这种形式，我们称为交叉熵，它表示了预测值与真实值之间的差异,其中$-p_i$表示真实值，$logq_i$表示预测值</p><p>上式可以同一形式变化为</p><script type="math/tex; mode=display">J(\vec \theta) = \frac {1}{m} \sum_{i=1}^N [-y^{(i)}log(h_{\vec \theta}(\vec x^{(i)})-(1-y^{(i)})log(1-h_{\vec \theta}(\vec x^{(i)})]</script><h3 id="4-梯度下降优化"><a href="#4-梯度下降优化" class="headerlink" title="4.梯度下降优化"></a>4.梯度下降优化</h3><script type="math/tex; mode=display">\frac {\delta J_{\vec \theta} }{\vec{\theta_j} } =\frac {1}{m} \sum_{i=1}^N\frac {\delta J_{\vec \theta} }{\delta h_{\vec \theta}(\vec x^{(i)})}\frac {\delta h_{\vec \theta}(\vec x^{(i)})}{ {\delta \vec \theta}^T \vec x^{(i)}}\frac { {\delta \vec \theta}^T \vec x^{(i)} }{\delta \vec{\theta_j} }</script><script type="math/tex; mode=display">=\frac {1}{m}\sum_{i=1}^N(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}</script><p>那么梯度下降的跟新规则即为</p><script type="math/tex; mode=display">\vec \theta=\vec \theta-\alpha\frac {1}{m}\sum_{i=1}^N(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}</script><h3 id="5-随机梯度下降优化"><a href="#5-随机梯度下降优化" class="headerlink" title="5.随机梯度下降优化"></a>5.随机梯度下降优化</h3><p>随机梯度下降优化是随机选择一个样本进行梯度计算，然后更新权重，并重复下一过程</p><h3 id="6-小批量梯度下降法"><a href="#6-小批量梯度下降法" class="headerlink" title="6.小批量梯度下降法"></a>6.小批量梯度下降法</h3><p>这个方法最常用，是GD与SGD的这种方法，取一个小批量的数据对参数进行更改。</p><h3 id="7-牛顿法"><a href="#7-牛顿法" class="headerlink" title="7.牛顿法"></a>7.牛顿法</h3><script type="math/tex; mode=display">θ:=θ−f(θ)f′(θ)</script><h3 id="8-二分类评价指标"><a href="#8-二分类评价指标" class="headerlink" title="8.二分类评价指标"></a>8.二分类评价指标</h3><div class="table-container"><table><thead><tr><th></th><th>$y_{gt}=1$</th><th>$y_{gt}\not= 1$</th></tr></thead><tbody><tr><td>$\hat y=1$</td><td>True Positive (TP)</td><td>Flase Positive (FP)</td></tr><tr><td>$\hat y\not=1$</td><td>Flase Negative(FN)</td><td>True Negative (TN)</td></tr></tbody></table></div><script type="math/tex; mode=display">precision(精确率，查找率)= \frac{TP}{TP+FP} 【\hat y=1的所有项】 高代表找的更对</script><script type="math/tex; mode=display">Recall(召回率)=\frac{TP}{TP+FN} 【y_{gt}=1的所有项】 高代表保证不漏</script><p>这两个参数不可兼得，需要根据实际情况来。</p><h2 id="SoftMax分类"><a href="#SoftMax分类" class="headerlink" title="SoftMax分类"></a>SoftMax分类</h2><p>Softmax是一种多分类问题的解决方法，是logistics的一种多维形式的推广，多维分类通常采用独热码表示。</p><h3 id="1-模型表示-1"><a href="#1-模型表示-1" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><script type="math/tex; mode=display">Softmax:h_{\vec \theta}(\vec x) = \frac {e^{-{\vec \theta}_c^T \vec x} } {\sum_{i=1}^Ne^{-{\vec \theta}^T \vec x} }</script><h3 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h3><script type="math/tex; mode=display">loss: J(\vec \theta) = -\frac {1}{m} \sum_{i=1}^m \sum_{c=1}^Cy^{(i)}log(h_{\vec \theta}(\vec x^{(i)})</script><script type="math/tex; mode=display">=-\frac {1}{m} \sum_{i=1}^m(y^{(i)})^Tlog(h_{\vec \theta}(\vec x^{(i)})</script><p>实际上只算了$y_c^{(i)}$为1的那个loss</p><h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><script type="math/tex; mode=display">\vec \theta=\vec \theta-\alpha\frac {1}{m}\sum_{i=1}^N{x_j}^{(i)}(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)})</script><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="1-过拟合："><a href="#1-过拟合：" class="headerlink" title="1.过拟合："></a>1.过拟合：</h3><p>可能是因为模型过于复杂，模型可以很好的拟合训练数据，但不能拟合预测数据。可能会导致预测失败。</p><h3 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2.解决方法："></a>2.解决方法：</h3><p>1.减少特征数量 </p><p>2.正则化（通过降低$J_{\vec \theta}$的值来改变一些高次特征）</p><h3 id="3-正则项"><a href="#3-正则项" class="headerlink" title="3.正则项"></a>3.正则项</h3><p>通式：</p><script type="math/tex; mode=display">J(\theta)=\frac {1}{2m} [\sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^N\theta_j^2]</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Logistic回归&quot;&gt;&lt;a href=&quot;#Logistic回归&quot; class=&quot;headerlink&quot; title=&quot;Logistic回归&quot;&gt;&lt;/a&gt;Logistic回归&lt;/h2&gt;&lt;p&gt;逻辑回归问题不是回归问题，而是一种分类问题，默认为二分类&lt;/p&gt;
&lt;h3 id=&quot;1-模型表示&quot;&gt;&lt;a href=&quot;#1-模型表示&quot; class=&quot;headerlink&quot; title=&quot;1.模型表示&quot;&gt;&lt;/a&gt;1.模型表示&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linear-regression</title>
    <link href="http://yokeso.top/2021/01/10/linear-regression/"/>
    <id>http://yokeso.top/2021/01/10/linear-regression/</id>
    <published>2021-01-10T07:39:59.000Z</published>
    <updated>2021-03-09T12:01:33.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习之线性回归"><a href="#机器学习之线性回归" class="headerlink" title="机器学习之线性回归"></a>机器学习之线性回归</h2><h3 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h3><p>线性回归问题作为机器学习的经典，是一种有监督学习</p><span id="more"></span><p>所谓的线性回归问题就是希望用线性模型去拟合数据，利用回归方法从而得到回归方程，从而预测结果</p><p>线性回归的学习可以用如下公式表示</p><script type="math/tex; mode=display">\hat y = h_\theta(x)</script><p>其中<code>x</code>是输入，<code>y</code>是输出/目标，$\theta$是要学习的参数。$h_\theta()$是指和$\theta$相关的模型，h()由模型给定。</p><p>当$\hat y$是连续的，且$h_\theta()$是线性的，那么这个模型就是线性回归模型。线性模型表示为</p><script type="math/tex; mode=display">h(x) = \theta_0+\theta_1x</script><p>其中$\theta_0,\theta_1$可以表示为向量$\theta = (\theta_0,\theta_1)^T$</p><p>则有$h_{\vec \theta}(x)=\theta_0+\theta_1x$</p><h3 id="监督学习框架"><a href="#监督学习框架" class="headerlink" title="监督学习框架"></a>监督学习框架</h3><h4 id="训练："><a href="#训练：" class="headerlink" title="训练："></a>训练：</h4><script type="math/tex; mode=display">训练集(x,y) \rightarrow 学习算法 \rightarrow h:假设函数 \hat y = h_\theta(x)</script><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><script type="math/tex; mode=display">x_{new} \rightarrow \hat y=h_\theta(x_{New})</script><h4 id="启发式评估："><a href="#启发式评估：" class="headerlink" title="启发式评估："></a>启发式评估：</h4><p>Evaluation</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>由于训练的最终目标是让$h_\theta$与y越接近越好，那么损失函数可以定义为：</p><script type="math/tex; mode=display">J(\theta)=\frac {1}{2m} \sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2</script><p>平方误差最小准则：优化问题就是找到使$J(\theta)$最小的解</p><h3 id="求闭式解"><a href="#求闭式解" class="headerlink" title="求闭式解"></a>求闭式解</h3><script type="math/tex; mode=display">J(\theta)=\frac {1}{2m} \sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2</script><script type="math/tex; mode=display">=\frac {1}{2m} \sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})^2</script><script type="math/tex; mode=display">\frac {\delta J}{\delta \theta_0}=\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})</script><script type="math/tex; mode=display">\frac {\delta J}{\delta \theta_1}=\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})x^{(i)}</script><p>令(8)与(9)为0，解得：</p><script type="math/tex; mode=display">\theta_0=\frac{1}{m}\sum_{i=1}^N (y^{(i)}-\theta_1(x^{(i)}))</script><script type="math/tex; mode=display">\theta_1=\frac{\sum_{i=1}^N (y^{(i)}-\theta_0) x^{(i)}}{\sum_{i=1}^N {x^{(i)}}^2}</script><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>沿着梯度反方向改变（函数值下降最快的地方）即</p><script type="math/tex; mode=display">\theta_j = \theta_j-\alpha \frac {\delta J(\theta_0,\theta_1)}{\theta_j}</script><p>这种方式让每次都算出$\theta_j$再进行下一轮更新，但可能出现局部最优解</p><h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><script type="math/tex; mode=display">\frac {\delta J(\theta_0,\theta_1)}{\theta} =\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})(x^{(i)})</script><h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><p>假设函数为$h_\theta(x)=\theta_0+\theta_1x+……\theta_nx$</p><p>即$h_{\vec \theta}(x)=\vec \theta^T \vec x $</p><h3 id="多元梯度："><a href="#多元梯度：" class="headerlink" title="多元梯度："></a>多元梯度：</h3><script type="math/tex; mode=display">\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} =\frac {1}{m} \sum_{i=1}^N (h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}</script><h3 id="多元闭式解"><a href="#多元闭式解" class="headerlink" title="多元闭式解"></a>多元闭式解</h3><script type="math/tex; mode=display">{ J_{\vec \theta}} =\frac {1}{2m} \sum_{i=1}^N (h_{\vec \theta}({\vec x}^{(i)})-y^{(i)})^2 = \frac{1}{2}(\vec x \vec \theta -\vec y)^T(\vec x \vec \theta -\vec y)</script><script type="math/tex; mode=display">\bigtriangledown_\theta J(\vec \theta) = \bigtriangledown_\theta\frac{1}{2}(\vec x \vec \theta -\vec y)^T(\vec x \vec \theta -\vec y)</script><script type="math/tex; mode=display">{\vec x}^T\vec x\vec \theta-{\vec x}^T\vec y = 0 \Rightarrow \vec \theta =  { {\vec x}^T\vec x}^{-1}{\vec x}^T\vec y</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;机器学习之线性回归&quot;&gt;&lt;a href=&quot;#机器学习之线性回归&quot; class=&quot;headerlink&quot; title=&quot;机器学习之线性回归&quot;&gt;&lt;/a&gt;机器学习之线性回归&lt;/h2&gt;&lt;h3 id=&quot;什么是线性回归&quot;&gt;&lt;a href=&quot;#什么是线性回归&quot; class=&quot;headerlink&quot; title=&quot;什么是线性回归&quot;&gt;&lt;/a&gt;什么是线性回归&lt;/h3&gt;&lt;p&gt;线性回归问题作为机器学习的经典，是一种有监督学习&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>scala</title>
    <link href="http://yokeso.top/2021/01/06/scala/"/>
    <id>http://yokeso.top/2021/01/06/scala/</id>
    <published>2021-01-06T02:51:57.000Z</published>
    <updated>2021-03-09T13:04:41.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Scala编程方法简化版"><a href="#Scala编程方法简化版" class="headerlink" title="Scala编程方法简化版"></a>Scala编程方法简化版</h2><h3 id="1-变量常量"><a href="#1-变量常量" class="headerlink" title="1.变量常量"></a>1.变量常量</h3><p>字符数字标识符：字母或者下划线开头，<code>$</code>被认作字母</p><span id="more"></span><h6 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h6><p>先乘除后加减</p><p>先算数，后移位，最后位运算</p><p>指针最优，单目优于双目</p><p>var 声明变量，val声明常量</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hellostr=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">//hellostr:string = Hello World</span></span><br><span class="line"><span class="comment">//定义后不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hellostr1=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">//hellostr1:string = Hello World</span></span><br></pre></td></tr></table></figure><p>在声明变量和常量不一定需要指定数据类型，没有指明时通过初始值推断。<strong>变量常量必须付初始值，否则会报错</strong></p><p>可以用val声明一个元组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mr=(<span class="string">&quot;key&quot;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="comment">//mr:(string,int)=(key,22)</span></span><br></pre></td></tr></table></figure><p>Scala与Java有相同的变量类型，但是首字母必须大写，因为是对象，例如Int,String,Boolean</p><p>可以直接用<code>0x</code>表示16进制，<code>0</code>表示8进制，表示<code>Long</code>用<code>L</code>或者<code>l</code>作为后缀，表示<code>float</code>用<code>F/f</code>否则默认为double</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="number">41</span></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">0x29</span></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">051</span></span><br><span class="line"><span class="comment">//x:Int=41</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">0777</span>l</span><br><span class="line"><span class="comment">//x:Long=511</span></span><br><span class="line"><span class="keyword">val</span> f = <span class="number">3.14</span>f</span><br><span class="line"><span class="comment">//f:Float=3.14</span></span><br><span class="line"><span class="keyword">val</span> f=<span class="number">3.14</span><span class="comment">//0.314e1</span></span><br><span class="line"><span class="comment">//f:Double=3.14</span></span><br></pre></td></tr></table></figure><p>单字符用‘ ’引用，特殊字符要添加转义字符\，双引号同理</p><p>Scala还提供一种原样字符内容输出方法，用<code>“&quot;&quot;</code>的方式来表述</p><p><img src="/2021/01/06/scala/image-20210107142102498.png" alt="image-20210107142102498"></p><h3 id="2-流程控制与函数"><a href="#2-流程控制与函数" class="headerlink" title="2.流程控制与函数"></a>2.流程控制与函数</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句与C++相似，有if,if…else…,if…elseif…else</p><p>但if可以作为表达式使用：且可以直接赋值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>==<span class="string">&quot;hell&quot;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//x:Int=0</span></span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><p>Scala中while与C++同，唯一不一样的是有返回值且恒为Unit(相当于void，<code>Unit=()</code>)</p><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>for循环Scala有自己的风格，基础格式为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-表达式)&#123;</span><br><span class="line"><span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.其中<code>&lt;-</code>称为生成器（generator），而for循环实际上是通过集合遍历来实现循环的</p><p> 2.表达式调用<code>RichInt</code>中的<code>to，until</code>方法来实现遍历，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>) println(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line"><span class="comment">//i=1</span></span><br><span class="line"><span class="comment">//i=2</span></span><br><span class="line"><span class="comment">//i=3</span></span><br><span class="line"><span class="comment">//i=4</span></span><br><span class="line"><span class="comment">//i=5</span></span><br></pre></td></tr></table></figure><p>3.如果希望集合右开，[1,5)则用<code>1 until 5</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> until (<span class="number">10</span>,<span class="number">2</span>)) print(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line"><span class="comment">//这里的2是步长</span></span><br></pre></td></tr></table></figure><p>4.引入break：Scala没有break,continue，但实现类似操作有两种方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入scala.util.control.Breaks类</span></span><br><span class="line"><span class="comment">//有条件过滤的for循环格式为</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">40</span> <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>);<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>))&#123;<span class="comment">//这里中间是&amp;&amp;关系</span></span><br><span class="line">println(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=20</span></span><br><span class="line"><span class="comment">//i=40</span></span><br></pre></td></tr></table></figure><p>5.多重for循环：Scala支持for循环嵌套</p><p>6.for表达式：与yield配合使用执行完后有返回值：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x =<span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>) <span class="keyword">yield</span> i/<span class="number">2</span></span><br><span class="line"><span class="comment">//x:scala.collection.immutable.IndexedSeq[Int]=vector(0,1,1,2,2)</span></span><br></pre></td></tr></table></figure><h5 id="函数声明，定义和调用"><a href="#函数声明，定义和调用" class="headerlink" title="函数声明，定义和调用"></a>函数声明，定义和调用</h5><h6 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义包</span></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">package</span> com.baidu</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">package</span> com.dubai1&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用包</span></span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Color</span></span><br><span class="line"><span class="keyword">import</span> java.awt_<span class="comment">//引入包内所有成员</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(&#123;参数列表&#125;):[<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>]</span></span><br><span class="line"><span class="class"><span class="comment">//定义</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fun</span>(<span class="params">&#123;参数列表&#125;</span>)</span>:[<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>]</span>=&#123;</span><br><span class="line">    function body</span><br><span class="line">    <span class="keyword">return</span> [expr]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的格式</span></span><br><span class="line">fun(参数列表)</span><br><span class="line"><span class="comment">//如果函数使用了实例的对象来调用，可以使用类似java的格式 (使用 . 号)：</span></span><br><span class="line">[instance.]fun(参数列表)</span><br></pre></td></tr></table></figure><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Scala用New来创建对象</p><p>类的第一个字母大写，方法的第一个字母小写</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">   <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">      x = x + dx</span><br><span class="line">      y = y + dy</span><br><span class="line">      println (<span class="string">&quot;Point x location : &quot;</span> + x);</span><br><span class="line">      println (<span class="string">&quot;Point y location : &quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> pt = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Move to a new location</span></span><br><span class="line">      pt.move(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Point x location:20</span></span><br><span class="line"><span class="comment">//Point y location:30</span></span><br></pre></td></tr></table></figure><p>类继承：extend  隐形类：impact  </p><h3 id="集合：数组、列表与映射"><a href="#集合：数组、列表与映射" class="headerlink" title="集合：数组、列表与映射"></a>集合：数组、列表与映射</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> z = <span class="type">Array</span>(<span class="string">&quot;Hello&quot;</span>，<span class="string">&quot;Cruel&quot;</span>，<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">z(<span class="number">0</span>)=<span class="string">&quot;Hello&quot;</span>;z(<span class="number">1</span>)=<span class="string">&quot;Cruel&quot;</span>;z(<span class="number">4</span>/<span class="number">2</span>)=<span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line"><span class="keyword">var</span> myMatrix = ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//简单数组操作：</span></span><br><span class="line"><span class="comment">//合并：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span></span>[<span class="type">T</span>]( xss: <span class="type">Array</span>[<span class="type">T</span>]* ): <span class="type">Array</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//复制：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>( src: <span class="type">AnyRef</span>, srcPos: <span class="type">Int</span>, dest: <span class="type">AnyRef</span>, destPos: <span class="type">Int</span>, length: <span class="type">Int</span> ): <span class="type">Unit</span></span><br><span class="line"><span class="comment">//mkString方法：</span></span><br><span class="line">mkString（“&lt;”,”,”,”&gt;”）</span><br><span class="line"><span class="comment">//得用&lt;&gt;所扩，”，”分隔的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串列表</span></span><br><span class="line"><span class="keyword">val</span> site: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Baidu&quot;</span>)</span><br><span class="line"><span class="comment">// 整型列表</span></span><br><span class="line"><span class="keyword">val</span> nums: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 二维列表</span></span><br><span class="line"><span class="keyword">val</span> dim: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] =</span><br><span class="line"><span class="type">List</span>(</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(i&lt;-<span class="type">List</span>)</span><br><span class="line"><span class="comment">//创建列表</span></span><br><span class="line"><span class="keyword">val</span> nums =<span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span></span><br><span class="line"><span class="comment">//nums:List[Int]=List(1,2,3,4)</span></span><br><span class="line"><span class="comment">//获取第一个第二个，最后一个元素</span></span><br><span class="line"><span class="type">List</span>.head <span class="type">List</span>.tail <span class="type">List</span>.last</span><br><span class="line"><span class="comment">//连接操作</span></span><br><span class="line"><span class="type">List1</span>:::<span class="type">List2</span></span><br><span class="line"><span class="comment">//获取和丢弃</span></span><br></pre></td></tr></table></figure><p><img src="/2021/01/06/scala/image-20210107152128223.png" alt="image-20210107152128223"></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>•Scala中的映射是键/值对的集合。任何值可以根据它的键进行检索。键是在映射唯一的，但值不一定是唯一的。</p><p>•映射也被称为哈希表。有两种类型的映射，不可变以及可变的。可变和不可变的对象之间的区别在于，当一个对象是不可变的，对象本身不能被改变。</p><p>•默认情况下，Scala中使用不可变的映射。如果想使用可变集，必须明确地导入scala.collection.mutable.Map类。但是可以通过生成新的映射来对原来的值进行改变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors = <span class="type">Map</span>(<span class="string">&quot;red&quot;</span> -&gt; <span class="string">&quot;#FF0000&quot;</span>, <span class="string">&quot;azure&quot;</span> -&gt; <span class="string">&quot;#F0FFFF&quot;</span>)</span><br><span class="line"><span class="comment">//colors:scala.collection.immutable.Map[String,String]=Map(red-&gt;#FF0000,azure-&gt;#F0FFFF)</span></span><br></pre></td></tr></table></figure><p>基本操作：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>keys</td><td>返回 Map 所有的键(key)</td></tr><tr><td>values</td><td>返回 Map 所有的值(value)</td></tr><tr><td>isEmpty</td><td>在 Map 为空时返回true</td></tr></tbody></table></div><p>使用++运算符或Map.++()来连接两个map ,Map合并时会移除重复的Key</p><p><img src="/2021/01/06/scala/image-20210107152502957.png" alt="image-20210107152502957"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Scala编程方法简化版&quot;&gt;&lt;a href=&quot;#Scala编程方法简化版&quot; class=&quot;headerlink&quot; title=&quot;Scala编程方法简化版&quot;&gt;&lt;/a&gt;Scala编程方法简化版&lt;/h2&gt;&lt;h3 id=&quot;1-变量常量&quot;&gt;&lt;a href=&quot;#1-变量常量&quot; class=&quot;headerlink&quot; title=&quot;1.变量常量&quot;&gt;&lt;/a&gt;1.变量常量&lt;/h3&gt;&lt;p&gt;字符数字标识符：字母或者下划线开头，&lt;code&gt;$&lt;/code&gt;被认作字母&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spark</title>
    <link href="http://yokeso.top/2021/01/06/spark/"/>
    <id>http://yokeso.top/2021/01/06/spark/</id>
    <published>2021-01-06T02:51:09.000Z</published>
    <updated>2021-03-09T12:02:51.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPARK"><a href="#SPARK" class="headerlink" title="SPARK"></a>SPARK</h2><h3 id="1-为什么要用Spark"><a href="#1-为什么要用Spark" class="headerlink" title="1.为什么要用Spark"></a>1.为什么要用Spark</h3><span id="more"></span><ol><li>speed ：比Hadoop快100倍，比disk快十倍</li><li>Ease of use：比java,Scala,Python,R写程序块</li><li>Generality</li><li>Runs Everywhere:可跑在Hadoop，standalone等，可以接受包括HDFS，Cassandra,HBase等数据来源</li></ol><h3 id="2-与Hadoop差异"><a href="#2-与Hadoop差异" class="headerlink" title="2.与Hadoop差异"></a>2.与Hadoop差异</h3><ol><li>Spark把中间数据放在内存中，迭代运算效率高，MapReduce中计算结果需要存在磁盘上，影响整体速度。Spark支持DAG图分布式并行计算的编程框架，减少迭代过程数据落地</li><li>Spark容错性高：引进弹性分布式数据集RDD的抽象。它是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“血统”（即充许基于数据衍生过程）对它们进行重建。</li><li>Spark更加通用。不像Hadoop只提供了Map和Redu ce两种操作，Spark提供的数据集操作类型有很多种，大致分为：Transformations和Actions两大类。Transformations包括Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort和PartionBy等多种操作类型，同时还提供Count, Actions包括Collect、Reduce、Lookup和Save等操作。另外各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名、物化，控制中间结果的存储、分区等。</li></ol><h3 id="3-Spark体系结构与运行模式"><a href="#3-Spark体系结构与运行模式" class="headerlink" title="3.Spark体系结构与运行模式"></a>3.Spark体系结构与运行模式</h3><p><img src="/2021/01/06/spark/image-20210106130224820.png" alt="image-20210106130224820"></p><p><img src="/2021/01/06/spark/image-20210106130320155.png" alt="image-20210106130320155"></p><h3 id="4-RDD"><a href="#4-RDD" class="headerlink" title="4.RDD"></a>4.RDD</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RDD是spark最基本的抽象，是对分布式内存的抽象使用。实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD表示了已被分区，不可变的能够并行操作的数据集合，不同数据格式对应不同的RDD实现。RDD必须可序列化，可以cache到内存中，每次RDD的结果都放在内存中，下次可以直接从内存中输入，省去MapReduce的大量磁盘IO操作。对于迭代常见的机器学习和交互式数据挖掘效率提升很大。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>来源：从持久存储获取或者从其他RDD生成</li><li>只读：状态不可变，不能修改</li><li>分区：支持元素根据key分区，保存到多个节点上</li><li>路径：RDD中叫世族或者血统，即RDD有充足的信息关于如何从其他RDD产生</li><li>持久化：控制存储级别来进行持久化</li><li>操作：丰富的动作：Count,Reduce,Collect,Save等</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="/2021/01/06/spark/image-20210106164259353.png" alt="image-20210106164259353"></p><h4 id="例子：控制台日志挖掘"><a href="#例子：控制台日志挖掘" class="headerlink" title="例子：控制台日志挖掘"></a>例子：控制台日志挖掘</h4><p>假设网站中的一个 WebService 出现错误，我们想要从数以 TB 的 HDFS 日志文件中找到问题的原因，此时我们就可以用 Spark 加载日志文件到一组结点组成集群的 RAM 中，并交互式地进行查询。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = spark.textFile(<span class="string">&quot;hdfs://...&quot;</span>)</span><br></pre></td></tr></table></figure><p>这行从HDFS文件中创建出一个RDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors = line.fliter(_.startWith(<span class="string">&quot;Error&quot;</span>))</span><br></pre></td></tr></table></figure><p>这行衍生出一个经过某种条件过滤的RDD（挑选出头为<code>Error</code>的值）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors.persisit()</span><br></pre></td></tr></table></figure><p>这行将上一行出来的RDD errors缓存到内存中，但不会将第一个lines放到缓存中，因为文件可能比较大，缓存放不下，但是Error的集合比较小，缓存足以装进全部内存</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Count errors mentioning MySQL</span></span><br><span class="line">errors.filter(._contains(<span class="string">&quot;MySQL&quot;</span>)).count</span><br></pre></td></tr></table></figure><p>这行统计errors中包含MySQL 字样的总行数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return time fields of errors mentioning</span></span><br><span class="line"><span class="comment">//HDFS as an array (assuming time is field number 3 in a tab-separated format):</span></span><br><span class="line">errors.filter(._contains(<span class="string">&quot;HDFS&quot;</span>))</span><br><span class="line">.map(._split(&#x27;\t&#x27;)(<span class="number">3</span>))</span><br><span class="line">.collect()</span><br></pre></td></tr></table></figure><p>取出包含HDFS字样的行的第三列时间，并保存成一个集合</p><h4 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h4><p>RDD是Spark的核心抽象，所有计算都是围绕这RDD进行的</p><ul><li>转换：一个RDD经过计算后生成新的RDD，比如wordcount中的flatmap,map和ReduceByKey</li><li>动作：返回结果到Driver程序中，意味着RDD的计算结果，比如wordcount的collect操作</li></ul><p>转换是lazy模式，要等到有action操作时运行启动计算过程计算</p><p>action会返回结果或把RDD写到存储系统中，是触发Spark运算的动因</p><p><img src="/2021/01/06/spark/image-20210106195342838.png" alt="image-20210106195342838"></p><p><img src="/2021/01/06/spark/image-20210106195354883.png" alt="image-20210106195354883"></p><h4 id="传递函数参数"><a href="#传递函数参数" class="headerlink" title="传递函数参数"></a>传递函数参数</h4><p><img src="/2021/01/06/spark/image-20210106201542727.png" alt="image-20210106201542727"></p><p><img src="/2021/01/06/spark/image-20210106202040819.png" alt="image-20210106202040819"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">  <span class="comment">//设置数据路径</span></span><br><span class="line">  <span class="keyword">val</span> text = sc.textFile(<span class="string">&quot;./GoneWithTheWind&quot;</span>)</span><br><span class="line">  <span class="comment">//将文本数据按行处理，每行按空格拆成一个数组</span></span><br><span class="line">  <span class="comment">// flatMap会将各个数组中元素合成一个大的集合</span></span><br><span class="line">  <span class="keyword">val</span> textSplit = text.flatMap(line =&gt;line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">  <span class="comment">//处理合并后的集合中的元素，每个元素的值为1，返回一个元组（key,value）</span></span><br><span class="line">  <span class="comment">//其中key为单词，value这里是1，即该单词出现一次</span></span><br><span class="line">  <span class="keyword">val</span> textSplitFlag = textSplit.map(word =&gt; (word,<span class="number">1</span>))</span><br><span class="line">  <span class="comment">//reduceByKey会将textSplitFlag中的key相同的放在一起处理</span></span><br><span class="line">  <span class="comment">//传入的（x,y）中，x是上一次统计后的value，y是本次单词中的value，即每一次是x+1</span></span><br><span class="line">  <span class="keyword">val</span> countWord = textSplitFlag.reduceByKey((x,y)=&gt;x+y)</span><br><span class="line">  <span class="comment">//将计算后的结果存在项目目录下的result目录中</span></span><br><span class="line">  countWord.saveAsTextFile(<span class="string">&quot;./result&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="宽依赖和窄依赖"><a href="#宽依赖和窄依赖" class="headerlink" title="宽依赖和窄依赖"></a>宽依赖和窄依赖</h4><ul><li><p>窄依赖</p><ul><li>子RDD的每个分区依赖于常数个父分区（即与数据规模无关）</li><li>输入输出一对一的算子，且结果RDD的分区结构不变，主要是map,flatmap</li><li>输入输出一对一，但结果RDD的分区结构发生变化，如union,coalesce</li><li>从输入中选择部分元素的算子，如flater,distinct,subract,sample</li></ul></li><li><p>宽依赖</p><ul><li>子RDD的每个分区依赖于所有父分区</li><li>对单个RDD基于Key进行重组和reduce，如groupByKey,reduceByKey</li><li>对两个RDD基于Key进行join和重组，如join</li></ul></li></ul><h3 id="5-Shuffle"><a href="#5-Shuffle" class="headerlink" title="5.Shuffle"></a>5.Shuffle</h3><p><strong>当一个RDD的一个分区依赖前一个RDD的所有分区</strong>时，例如，对于单词Spark出现次数汇总时，该单词可能出现在所有分区中，需要将所有分区中Spark出现的键值汇总到某一数据节点进行汇总，这个过程叫做shuffle</p><h3 id="6-Spark内存管理"><a href="#6-Spark内存管理" class="headerlink" title="6.Spark内存管理"></a>6.Spark内存管理</h3><p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前<strong>记录</strong>这些内存，我们来看其具体流程：</p><p><strong>申请内存</strong>：</p><p>Spark 在代码中 new 一个对象实例</p><p>JVM 从堆内内存分配空间，创建对象并返回对象引用</p><p>Spark 保存该对象的引用，记录该对象占用的内存</p><p><strong>释放内存</strong>：</p><p>Spark 记录该对象释放的内存，删除该对象的引用</p><p>等待 JVM 的垃圾回收机制释放该对象占用的堆内内存</p><p><img src="/2021/01/06/spark/image-20210106212352334.png" alt="image-20210106212352334"></p><p>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。利用 JDK Unsafe API（从 Spark 2.0 开始，在管理堆外的存储内存时不再基于 Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现[3]），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放，而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p><p>在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。</p><p><img src="/2021/01/06/spark/image-20210106212503514.png" alt="image-20210106212503514"></p><h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p><img src="/2021/01/06/spark/image-20210106212901176.png" alt="image-20210106212901176"></p><h4 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h4><h5 id="RDD的持久化机制："><a href="#RDD的持久化机制：" class="headerlink" title="RDD的持久化机制："></a>RDD的持久化机制：</h5><p>弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的 RDD 上执行转换（Transformation）操作产生一个新的 RDD。转换后的 RDD 与原始的 RDD 之间产生的依赖关系，构成了血统（Lineage）。凭借血统，Spark 保证了每一个 RDD 都可以被重新恢复。但 RDD 的所有转换都是惰性的，即只有当一个返回结果给 Driver 的行动（Action）发生时，Spark 才会创建任务读取 RDD，然后真正触发转换的执行。<br> Task 在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查 Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist 或 cache 方法，在内存或磁盘中持久化或缓存这个 RDD，从而在后面的行动时提升计算速度。事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 <strong>堆内和堆外存储内存的设计，便可以对缓存</strong> <strong>RDD</strong> <strong>时使用的内存做统一的规划和管 理</strong> （存储内存的其他应用场景，如缓存 broadcast 数据，暂时不在本文的讨论范围之内）。</p><p>RDD 的持久化由 Spark 的 Storage 模块 [7] 负责，实现了 RDD 与物理存储的解耦合。Storage 模块负责管理 Spark 在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时 Driver 端和 Executor 端的 Storage 模块构成了主从式的架构，即 Driver 端的 BlockManager 为 Master，Executor 端的 BlockManager 为 Slave。Storage 模块在逻辑上以 Block 为基本存储单位，RDD 的每个 Partition 经过处理后唯一对应一个 Block（BlockId 的格式为 rdd_RDD-ID_PARTITION-ID ）。Master 负责整个 Spark 应用程序的 Block 的元数据信息的管理和维护，而 Slave 需要将 Block 的更新等状态上报到 Master，同时接收 Master 的命令，例如新增或删除一个 RDD。</p><h4 id="RDD缓存过程"><a href="#RDD缓存过程" class="headerlink" title="RDD缓存过程"></a>RDD缓存过程</h4><p>在缓存到存储内存之前，partition中数据用Iterator访问。可以获取分区中每一条序列化或者非序列化的数据项，他们逻辑上占用JVM堆内的other部分空间，同一partition的不同Record空间并不连续</p><p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，所有Record 在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</p><p>因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的 Unroll 空间来临时占位，空间不足则 Unroll 失败，空间足够时可以继续进行。对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。而非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间</p><p><img src="/2021/01/06/spark/image-20210107104530406.png" alt="image-20210107104530406"></p><h4 id="淘汰和落盘"><a href="#淘汰和落盘" class="headerlink" title="淘汰和落盘"></a>淘汰和落盘</h4><p>存储内存的淘汰规则为：</p><p>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存</p><p>新旧 Block 不能属于同一个 RDD，避免循环淘汰</p><p>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题</p><p>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。其中 LRU 是 LinkedHashMap 的特性。</p><p>落盘的流程则比较简单，如果其存储级别符合_useDisk 为 true 的条件，再根据其_deserialized 判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在 Storage 模块中更新其信息。</p><ul><li>由于同一个 Executor 的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对 LinkedHashMap 中的旧 Block 进行淘汰（Eviction），而被淘汰的 Block 如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该 Block。</li></ul><h4 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h4><p>Executor 内运行的任务同样共享执行内存，Spark 用一个 HashMap 结构保存了任务到内存耗费的映射。每个任务可占用的执行内存大小的范围为 1/2N ~ 1/N，其中 N 为当前 Executor 内正在运行的任务的个数。每个任务在启动之时，要向 MemoryManager 请求申请最少为 1/2N 的执行内存，如果不能被满足要求则该任务被阻塞，直到有其他任务释放了足够的执行内存，该任务才可以被唤醒</p><h4 id="shuffle内存占用"><a href="#shuffle内存占用" class="headerlink" title="shuffle内存占用"></a>shuffle内存占用</h4><p>·在 ExternalSorter 和 Aggregator 中，Spark 会使用一种叫 AppendOnlyMap 的哈希表在堆内执行内存中存储数据，但在 Shuffle 过程中所有数据并不能都保存到该哈希表中，当这个哈希表占用的内存会进行周期性地采样估算，当其大到一定程度，无法再从 MemoryManager 申请到新的执行内存时，Spark 就会将其全部内容存储到磁盘文件中，这个过程被称为溢存(Spill)，溢存到磁盘的文件最后会被归并(Merge)。</p><p>Shuffle Write 阶段中用到的 Tungsten 是 Databricks 公司提出的对 Spark 优化内存和 CPU 使用的计划[9]，解决了一些 JVM 在性能上的限制和弊端。Spark 会根据 Shuffle 的情况来自动选择是否采用 Tungsten 排序。Tungsten 采用的页式内存管理机制建立在 MemoryManager 之上，即 Tungsten 对执行内存的使用进行了一步的抽象，这样在 Shuffle 过程中无需关心数据具体存储在堆内还是堆外。每个内存页用一个 MemoryBlock 来定义，并用 Object obj 和 long offset 这两个变量统一标识一个内存页在系统内存中的地址。堆内的 MemoryBlock 是以 long 型数组的形式分配的内存，其 obj 的值为是这个数组的对象引用，offset 是 long 型数组的在 JVM 中的初始偏移地址，两者配合使用可以定位这个数组在堆内的绝对地址；堆外的 MemoryBlock 是直接申请到的内存块，其 obj 为 null，offset 是这个内存块在系统内存中的 64 位绝对地址。Spark 用 MemoryBlock 巧妙地将堆内和堆外内存页统一抽象封装，并用页表(pageTable)管理每个 Task 申请到的内存页。</p><p>•执行内存主要用来存储任务在执行 Shuffle 时占用的内存，Shuffle 是按照一定规则对 RDD 数据重新分区的过程，我们来看 Shuffle 的 Write 和 Read 两阶段对执行内存的使用</p><p>•Shuffle Write：若在 map 端选择普通的排序方式，会采用 ExternalSorter 进行外排，在内存中存储数据时主要占用堆内执行空间。若在 map 端选择 Tungsten 的排序方式，则采用 ShuffleExternalSorter 直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。</p><p>•Shuffle Read：在对 reduce 端的数据进行聚合时，要将数据交给 Aggregator 处理，在内存中存储数据时占用堆内执行空间。如果需要进行最终结果排序，则要将再次将数据交给 ExternalSorter 处理，占用堆内执行空间。</p><h4 id="BlackManager在spark中扮演的角色"><a href="#BlackManager在spark中扮演的角色" class="headerlink" title="BlackManager在spark中扮演的角色"></a>BlackManager在spark中扮演的角色</h4><p>shuffle过程用到了BlackManager作为数据中转站</p><p>spark board cast调度task到多个executor的时候，broadcast底层使用的时数据存储层</p><p>如果我们对一个rdd进行cache，cacheManager也是把数据放在blockmanager中，截断了对计算链依赖，后续task运行的时候可以直接从cachemanager中获取到cacherdd，不用从头计算</p><h4 id="block和partition的关系"><a href="#block和partition的关系" class="headerlink" title="block和partition的关系"></a>block和partition的关系</h4><ul><li><p>RDD的运算基于partition每个task代表一个分区上的一个stage内的运算闭包，task被分别调度到多个executor上去运行，</p></li><li><p>如果 Block 在 BlockManager 中存在， 就会从 BlockManager 中获取，如果不存在， 就进行计算这个Block, 然后在 BlockManager 中进行存储持久化， 方便下次使用。</p></li><li><p>首先根据RDD id和partition index构造出block id (rdd_xx_xx)，接着从BlockManager中取出相应的block。</p><ul><li>如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。</li><li>如果该block不存在则需要调用RDD的computeOrReadCheckpoint()函数计算出新的block，并将其存储到BlockManager中。</li></ul></li><li><p>需要注意的是block的计算和存储是阻塞的，若另一线程也需要用到此block则需等到该线程block的loading结束。</p></li><li><p>获取的时候是先从本地的 BlockManager 中获取， 如果本地没有， 然后再 从 remote 获取， 先从 driver 上获取到元数据 Block的位置， 然后去到真正的节点上fetch。</p></li><li><p>如果没有，就进行计算，然后根据存储级别，存储到计算节点本地的BlockManager 的内存或磁盘中，这样RDD的transformation、action就和block数据建立了联系，虽然抽象上我们的操作是在partition层面上进行的，但是partition最终还是被映射成为block，因此实际上我们的所有操作都是对block的处理和存取。</p></li></ul><h4 id="SparkCache过程总结"><a href="#SparkCache过程总结" class="headerlink" title="SparkCache过程总结"></a>SparkCache过程总结</h4><p>存在则取出即可，不存在则计算下次使用同一个rdd时从分布式直接取出</p><p>rdd 计算的时候， 首先根据RDD id和partition index构造出block id (rdd_xx_xx)， 接着从BlockManager中取出相应的block， 如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。 如果 block 不存在我们可以 计算出来， 然后吧 block 通过 doPutIterator 函数存储在 节点上的 BlockManager上面， 汇报block信息到 driver, 下次如果使用同一个 rdd, 就可以直接从分布式存储中 直接取出相应的 block。</p><p><img src="/2021/01/06/spark/image-20210107134919314.png" alt="image-20210107134919314"></p><p><img src="/2021/01/06/spark/image-20210107134926188.png" alt="image-20210107134926188"></p><p><img src="/2021/01/06/spark/image-20210107134932364.png" alt="image-20210107134932364"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SPARK&quot;&gt;&lt;a href=&quot;#SPARK&quot; class=&quot;headerlink&quot; title=&quot;SPARK&quot;&gt;&lt;/a&gt;SPARK&lt;/h2&gt;&lt;h3 id=&quot;1-为什么要用Spark&quot;&gt;&lt;a href=&quot;#1-为什么要用Spark&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要用Spark&quot;&gt;&lt;/a&gt;1.为什么要用Spark&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MapReduce</title>
    <link href="http://yokeso.top/2021/01/04/MapReduce/"/>
    <id>http://yokeso.top/2021/01/04/MapReduce/</id>
    <published>2021-01-04T08:36:14.000Z</published>
    <updated>2021-03-09T12:03:24.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce原理及介绍"><a href="#MapReduce原理及介绍" class="headerlink" title="MapReduce原理及介绍"></a>MapReduce原理及介绍</h2><p>MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式运算。抽象了分布式计算系统上运行一个并行程序的数据流，以函数形式提供给用户两个接口：Map（映射）和Reduce（化简）用户可以重载这两个函数以实现交互和操纵其中的程序数据流</p><span id="more"></span><h4 id="MapReduce形式化定义"><a href="#MapReduce形式化定义" class="headerlink" title="MapReduce形式化定义"></a>MapReduce形式化定义</h4><p>MapReduce软件框架向用户提供了一个具有数据流和控制流的抽象层，并隐藏了数据流的实现步骤。但抽象层提供了Map和Reduce两个函数，用户可以通过重载这两个主函数达到特定目标</p><p>用户首先重载Map和Reduce函数，然后调用<code>MapReduce（Spec，&amp;Results）</code>来开始数据流，其中<code>Spec</code>先在用户程序中初始化，然后用户编写代码来填入输入和输出文件名以及其他可选调节参数。这个对象还填入了Map和Reduce函数的名字，以识别这些用户定义的函数和MapReduce库里提供的函数</p><p><img src="/2021/01/04/MapReduce/image-20210105164548758.png" alt="image-20210105164548758"></p><h4 id="MapReduce逻辑数据流"><a href="#MapReduce逻辑数据流" class="headerlink" title="MapReduce逻辑数据流"></a>MapReduce逻辑数据流</h4><p>Map的输入数据是以<code>（key,value）</code>对形式出现，输出数据的结构类似于<code>（key,value）</code>对，称为中间<code>（key,value）</code>对，换句话说，用户自定义Map函数处理每个<code>（key,value）</code>对，并产生很多<code>（zero,one,ormore）</code>中间<code>（key,value）</code>对。目的是为了Map函数并行处理所有的<code>（key,value）</code>对</p><p><img src="/2021/01/04/MapReduce/image-20210105170548205.png" alt="image-20210105170548205"></p><p>反过来，Reduce函数以中间值群组的形式接受中间<code>（key,value）</code>对，这些中间值群组和一个中间key<code>（key,[set of values]）</code>相关。实际上，MapReduce框架形成了这些群组，先对中间<code>（key,value）</code>对排序，然后用key来对value分组</p><p><strong>注意，排序是为了简化分组</strong></p><p>reduce 函数处理每个<code>（key,[set of values]）</code>群组，并产生<code>（key,value）</code>对集合作为输出。</p><h4 id="单词计数顺序"><a href="#单词计数顺序" class="headerlink" title="单词计数顺序"></a>单词计数顺序</h4><p><img src="/2021/01/04/MapReduce/image-20210105191718304.png" alt="image-20210105191718304"></p><p><strong>符号化</strong>：（key1,val1）-Map函数-&gt;List(key2,val2)</p><p>​                （key2,List(val2)）-Reduce函数-&gt;List（val2）</p><h4 id="MapReduce真实数据和控制流"><a href="#MapReduce真实数据和控制流" class="headerlink" title="MapReduce真实数据和控制流"></a>MapReduce真实数据和控制流</h4><p>1.数据分区：MapReduce库将已存入GFS的输入数据分割成m份，M也即映射任务的数量。</p><p>2.计算分区：计算模块强迫用户以Map和Reduce函数的形式编写程序，并在框架中隐式处理，所以MapReduce库只生成用户程序的多个复制（fork），包含MAp和Reduce函数，然后在多个可用的计算引擎上分配。</p><p>3.决定主服务器（master）和服务器（worker）：MapReduce基于主服务器-服务器模式，一个用户程序的复制变为主服务器，其余是服务器。主服务器挑选空闲服务器，分配MapReduce任务给他们。</p><p>4.读取输入数据（数据分发）：每一个映射服务器读取其输入数据的相应部分，即输入数据分割，然后输入至其Map函数。虽然一个映射服务器可能运行多个Map函数，这意味着它分到了不止一个输入数据分割；通常每个服务器只分到一个输入分割。</p><p>5.Map函数：用<code>（key,value）</code>对集合的形式收到输入数据分割，来处理并产生中间<code>（key,value）</code>对。</p><p>6.Combiner函数：映射服务器中一个可选的本地函数。适用于中间的<code>（key,value）</code>对。用户可以在用户程序里调用。Combiner运行与Reduce一样的功能。合并每个映射服务器的本地数据然后送到网络传输。</p><p>7.Partitioning函数：分块是由Partitioning（分区）函数完成，并能保证有相同键值的所有<code>（key,value）</code>对都能存储在同一区域内。因此，由于化简服务器i读取所有映射服务器区域i中的数据，有相同key的所有<code>（key,value）</code>对将由相应的化简服务器i收集。 </p><p><img src="/2021/01/04/MapReduce/image-20210105201025104.png" alt="image-20210105201025104"></p><p>8.同步：当所有映射任务完成，他们之间的通信开始</p><p>9.通信：Reduce服务器i已经知道所有映射服务器的区域i的位置，使用远程过程调用来从所有映射服务器的各个区域中读取数据。由于所有化简服务器从所有映射服务器中读取数据，映射和化简服务器之间的多对多通信在网络中进行，会引发网络拥塞。这个问题是提高此类系统性能的一个主要瓶颈。</p><p>10.排序和分组：当化简服务器完成读取输入数据的过程时，数据首先在化简服务器的本地磁盘中缓冲。然后化简服务器根据key将数据排序来对中间(key, value)对进行分组，之后对出现的所有相同key进行分组。注意，缓冲数据已经排序并分组，因为一个映射服务器产生的唯一key的数量可能会多于R个区域，所以在每个映射服务器区域中可能有不止一个key。</p><p>11.Reduce函数：简化服务器在已分组的<code>（key,value）</code>对上的迭代。对于每一个唯一的key，把key对应的value发送给Reduce函数，然后把这个函数出来输入数据，最后的结果存入用户程序指定的文件中。</p><p><img src="/2021/01/04/MapReduce/image-20210105205303260.png" alt="image-20210105205303260"></p><h4 id="来自Apache的Hadoop软件库"><a href="#来自Apache的Hadoop软件库" class="headerlink" title="来自Apache的Hadoop软件库"></a>来自Apache的Hadoop软件库</h4><p>Hadoop是Apache用Java实现的MapReduce开源实现，使用HDFS作为底层，MapReduce引擎是运行在HDFS上的计算引擎，HDFS是他的数据存储管理器。</p><p>HDFS：源于GFS的分布式文件系统，分布式计算系统上管理文件和存储数据</p><p><img src="/2021/01/04/MapReduce/image-20210106100205802.png" alt="image-20210106100205802"></p><p>HDFS体系结构：主从体系结构，包括单个NameNode(master)和多个DataNode(slave)。HDFS将文件分为固定大小的块，并存放在工作机中，块的映射由Namenode决定。master也管理文件系统的元数据和命名空间，在系统中，命名空间是维护元数据的区域，元数据是指一个文件系统存储的所有信息。是所有文件的全面管理所需要的。</p><p><img src="/2021/01/04/MapReduce/image-20210106103330168.png" alt="image-20210106103330168"></p><p>HDFS特性：HDFS不支持安全性，主要讨论两个特性</p><ul><li><p>容错能力：Hadoop设计时默认部署在廉价的硬件上，系统故障很常见。</p><ul><li>块复制：HDFS把文件存储为一个块集，每个块都有备份并且在整个集群上分发。</li><li>备份布置：提供更大的可靠性，但通信成本稍高</li><li>HeartBeat和LockReport消息：这两个消息都由DataNode传输给NameNode，收到Heartbeat意味着DataNode正常运行，而每个Blockreport包括DataNode上所有块的清单</li></ul></li><li><p>高吞吐量访问大规模数据集：因为是为批处理设计而非交互式处理，所以吞吐量比延时更重要。</p></li></ul><p>HDFS操作：控制流能正确突出在管理操作中NameNode和DataNode的角色</p><ul><li>读取文件：用户发送Open请求给NameNode来获取文件块位置信息</li><li>写入文件：用户发送create请求给NameNode来在命名空间里创建文件</li></ul><h4 id="Hadoop里运行作业"><a href="#Hadoop里运行作业" class="headerlink" title="Hadoop里运行作业"></a>Hadoop里运行作业</h4><p><img src="/2021/01/04/MapReduce/image-20210105214423025.png" alt="image-20210105214423025"></p><ul><li><p>作业提交：每个作业由用户提交到master</p><ul><li>用户从master请求新ID，并计算输入文件分块</li><li>用户复制资源l比如用户的JAR文件、配置文件和计算输入分块，至JobTracker文件系统。</li><li>用户节点通过调用submitJob()函数提交任务至JobTracker。</li></ul></li><li><p>任务分配：JobTracker为用户节点的每个计算输入块建立一个映射任务，并分配给TaskTracker的执行槽。当分配映射任务给TaskTracker时，JobTracker会考虑数据的定位。JobTracker也会创建化简任务，并分配给TaskTracker。 </p></li><li><p>任务执行：把作业JAR文件复制到其文件系统之后，在TaskTracker执行一个任务（不管映射还是化简）的控制流就开始了。在启动Java虚拟机（Java Virtual Machine，JVM）来运行它的映射或化简任务后，就开始执行作业JAR文件里的指令。</p></li><li><p>任务运行校验：通过接收从TaskTracker到JobTracker的周期性心跳监听消息来完成任务运行校验。每个心跳监听会告知JobTracker传送中的TaskTracker是可用的，以及传送中的TaskTracker是否准备好运行一个新的任务。 </p></li></ul><p><img src="/2021/01/04/MapReduce/image-20210106104041624.png" alt="image-20210106104041624"></p><p><img src="/2021/01/04/MapReduce/image-20210106104054859.png" alt="image-20210106104054859"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MapReduce原理及介绍&quot;&gt;&lt;a href=&quot;#MapReduce原理及介绍&quot; class=&quot;headerlink&quot; title=&quot;MapReduce原理及介绍&quot;&gt;&lt;/a&gt;MapReduce原理及介绍&lt;/h2&gt;&lt;p&gt;MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式运算。抽象了分布式计算系统上运行一个并行程序的数据流，以函数形式提供给用户两个接口：Map（映射）和Reduce（化简）用户可以重载这两个函数以实现交互和操纵其中的程序数据流&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Distributed_cloud-computing</title>
    <link href="http://yokeso.top/2021/01/03/Distributed-cloud-computing/"/>
    <id>http://yokeso.top/2021/01/03/Distributed-cloud-computing/</id>
    <published>2021-01-03T02:17:09.000Z</published>
    <updated>2021-03-09T12:03:07.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-分布式系统模型和关键技术"><a href="#第一章-分布式系统模型和关键技术" class="headerlink" title="第一章 分布式系统模型和关键技术"></a>第一章 分布式系统模型和关键技术</h2><h3 id="1-1互联网上的可扩展计算"><a href="#1-1互联网上的可扩展计算" class="headerlink" title="1.1互联网上的可扩展计算"></a>1.1互联网上的可扩展计算</h3><p>一个并行的、分布式的计算系统使用大量的计算机解决互联网上的大规模计算问题。</p><span id="more"></span><p>   分布式计算的缺点是数据敏感和网络中心化</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103101834253.png" alt="image-20210103101834253"></p><h3 id="计算范式之间区别"><a href="#计算范式之间区别" class="headerlink" title="计算范式之间区别"></a>计算范式之间区别</h3><p>集中式计算：计算资源存储在一个物理系统内，所有资源共享，紧耦合在一个集成式操作系统中</p><p>并行计算：所有处理器紧耦合于中心共享内存或松耦合于分布式内存</p><p>分布式计算：众多自治的计算机组成，拥有私有内存，通过计算机网络通信。信息交换通过消息传递完成。</p><p>云计算：集中式或分布式，由物理的或虚拟的计算资源构建</p><p>普适计算：任何地点时间通过有线或者无线用普遍设备计算</p><p>物联网：通过互联网云实现普适计算</p><h3 id="分布式和云计算系统模型"><a href="#分布式和云计算系统模型" class="headerlink" title="分布式和云计算系统模型"></a>分布式和云计算系统模型</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103104520742.png" alt="image-20210103104520742"></p><h3 id="协同计算机集群"><a href="#协同计算机集群" class="headerlink" title="协同计算机集群"></a>协同计算机集群</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103104933760.png" alt="image-20210103104933760"></p><h3 id="互联网云计算"><a href="#互联网云计算" class="headerlink" title="互联网云计算"></a>互联网云计算</h3><p>云提供了虚拟机或物理机快速配置和划分，云支持冗余，自恢复，高可扩展编程模型，允许负载从许多不可避免的硬件软件错误中恢复。最终云计算系统可以通过实时监视资源来确保分配在需要时平衡</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103105242598.png" alt="image-20210103105242598"></p><h3 id="性能、安全和节能"><a href="#性能、安全和节能" class="headerlink" title="性能、安全和节能"></a>性能、安全和节能</h3><h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><ul><li>性能度量（MIPS、Tflops）每秒浮点运算次数（M/T）、（TPS）每秒事物数，其他度量包括作业响应时间和网络延迟</li><li>系统开销归因于系统启动时间、编译时间、IO数据速率和运行时支持系统消耗。其他性能包括互联网WEb QoS，系统可用性和可靠性，抵抗网络攻击的安全弹性</li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103105756172.png" alt="image-20210103105756172"></p><h2 id="第三章-虚拟机集群和数据中心虚拟化"><a href="#第三章-虚拟机集群和数据中心虚拟化" class="headerlink" title="第三章 虚拟机集群和数据中心虚拟化"></a>第三章 虚拟机集群和数据中心虚拟化</h2><h3 id="3-1-虚拟化的实现层次"><a href="#3-1-虚拟化的实现层次" class="headerlink" title="3.1 虚拟化的实现层次"></a>3.1 虚拟化的实现层次</h3><p>通过在一个硬件主机上多路复用的虚拟机方式共享昂贵的硬件资源</p><p>基本思想是分离软硬件以产生更好的系统性能</p><h4 id="虚拟化实现层次"><a href="#虚拟化实现层次" class="headerlink" title="虚拟化实现层次"></a>虚拟化实现层次</h4><p>为了让客户操作系统独立于主机操作系统并同时运行在一个硬件上，添加虚拟化层软件完成（hypercisor）/虚拟机监视器（VMM）</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103111007166.png" alt="image-20210103111007166"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103111806694.png" alt="image-20210103111806694"></p><ul><li><p>指令集体系结构级：代码解释和动态二进制翻译</p></li><li><p>硬件抽象级：虚拟化一个计算机硬件资源</p></li><li><p>操作系统级：在单一物理服务器上创建隔离的容器和操作系统实例</p></li><li><p>库支持级：库接口的虚拟化</p></li><li><p>应用程序级：进程级虚拟化、高级语言（High Level Language，HLL）虚拟机</p></li></ul><h4 id="VMM设计需求"><a href="#VMM设计需求" class="headerlink" title="VMM设计需求"></a>VMM设计需求</h4><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><ul><li><p>为程序提供与原始硬件机器一致的环境</p></li><li><p>运行在环境中的程序性能损失较低</p></li><li><p>系统资源处在完全控制中</p></li></ul><h5 id="资源："><a href="#资源：" class="headerlink" title="资源："></a>资源：</h5><ul><li>为应用程序分配硬件</li><li>程序不能访问任何未分配给他的资源</li><li>某些情况下VMM可以获得对已分配资源的控制权</li></ul><h4 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h4><p>操作系统中插入一个虚拟化层，使得操作系统内核中同时运行多个隔离虚拟机，这种虚拟机也称（VE、VPS、容器）</p><p>用户看来VE就是真实服务器，有自己进程，文件系统，用户账号，带IP的网络接口，路由表，防火墙规则和其他个人设置，</p><p>不同用户共享一个系统内核，<strong>操作系统虚拟化也称系统镜像虚拟化</strong></p><h3 id="3-2虚拟化的结构、工具与机制"><a href="#3-2虚拟化的结构、工具与机制" class="headerlink" title="3.2虚拟化的结构、工具与机制"></a>3.2虚拟化的结构、工具与机制</h3><p>hypervisor与Xen体系结构</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103131438789.png" alt="image-20210103131438789"></p><ul><li>Xen属于微内核hypersor</li><li>提供一种客户端直接访问物理设备的机制</li><li>提供处于硬件和操作系统之间的虚拟环境</li><li>核心组件是hypercisor、内核和应用程序</li><li>具有控制特权的客户操作系统称为Doman0，其他称为DomanU</li><li>Doman0首先启动，直接访问硬件和设备，为所有DomanU分配资源</li></ul><h4 id="全虚拟化的二进制翻译"><a href="#全虚拟化的二进制翻译" class="headerlink" title="全虚拟化的二进制翻译"></a>全虚拟化的二进制翻译</h4><p>全虚拟化（依赖二进制翻译，客户端和应用由非临界和临界指令生成）</p><p>基于主机的虚拟化（操作系统和客户机同时存在，虚拟化软件层位于两者之间，客户端跑在虚拟化层上，特定的应用运行在虚拟机中）</p><h4 id="编译器支持的半虚拟化技术"><a href="#编译器支持的半虚拟化技术" class="headerlink" title="编译器支持的半虚拟化技术"></a>编译器支持的半虚拟化技术</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103141520694.png" alt="image-20210103141520694"></p><h3 id="3-3CPU、内存和IO设备的虚拟化"><a href="#3-3CPU、内存和IO设备的虚拟化" class="headerlink" title="3.3CPU、内存和IO设备的虚拟化"></a>3.3CPU、内存和IO设备的虚拟化</h3><h4 id="虚拟化的硬件支持"><a href="#虚拟化的硬件支持" class="headerlink" title="虚拟化的硬件支持"></a>虚拟化的硬件支持</h4><p>为防止系统崩溃，设置用户模式和管理模式，对临界区硬件的受控访问（特权指令和非特权指令）</p><h4 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h4><ul><li>非特权指令直接在物理主机运行</li><li><p>关键指令</p><ul><li>特权指令在特权模式执行，非特权模式发生<strong>陷入</strong></li><li>控制敏感指令尝试改变资源配置</li><li>行为敏感指令根据资源配置有不同行为，包括虚拟内存的负载和存储</li></ul></li><li><p>VMM在运行管理模式时，CPU支持在用户模式运行虚拟机的特权指令和非特权指令，则CPU体系结构是可虚拟化的</p></li><li>RISC的所有控制敏感和行为敏感指令都是特权指令，所以RISC的CPU是天然可虚拟化的</li></ul><h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><p>多级页表，虚拟内存</p><h4 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I/O虚拟化"></a>I/O虚拟化</h4><ul><li>全设备模拟：一个设备的所有功能和总线结构都在软件中复制</li><li>半虚拟化：Xen使用的方法，分为前端后端，前端在DomainU中，后端在Domain0中，通过一块共享内存交互</li><li>直接IO虚拟化：虚拟机直接访问设备硬件获得近乎本地性能，CPU开销不高</li></ul><h4 id="多核处理器虚拟化"><a href="#多核处理器虚拟化" class="headerlink" title="多核处理器虚拟化"></a>多核处理器虚拟化</h4><p>困难</p><ul><li>编程者必须完全并行使用所有处理器核</li><li>软件明确的为处理器分配任务</li></ul><p>使用三级的Cache进行层次缓冲</p><h3 id="3-4-虚拟集群与资源管理"><a href="#3-4-虚拟集群与资源管理" class="headerlink" title="3.4 虚拟集群与资源管理"></a>3.4 虚拟集群与资源管理</h3><h4 id="物理集群与虚拟集群"><a href="#物理集群与虚拟集群" class="headerlink" title="物理集群与虚拟集群"></a>物理集群与虚拟集群</h4><p>虚拟集群：多个客户虚拟机，安装在由一个或多个物理集群构成的分布式服务器上，逻辑上跨越物理网络的虚拟网络互联，为虚拟集群提供虚拟机的过程可以动态运行</p><ul><li>虚拟集群节点可以是物理机器或者虚拟机器</li><li>主机操作系统管理物理机器资源，虚拟机运行其上，可以运行与主机相异的操作系统</li><li>虚拟机的目的是合并同一台物理服务器的多个功能</li><li>虚拟机可以在多个物理服务器上备份，提高分布式并行度，容错性，加快灾难恢复速度</li><li>节点数可以动态删减（与P2P类似）</li><li>物理节点失效会使运行在其上的虚拟机失效，但是虚拟机失效不会影响主机系统</li></ul><h4 id="快速-部署和有效调度"><a href="#快速-部署和有效调度" class="headerlink" title="快速 部署和有效调度"></a>快速 部署和有效调度</h4><h5 id="快速部署："><a href="#快速部署：" class="headerlink" title="快速部署："></a>快速部署：</h5><ul><li><p>集群内的物理节点尽快构建发布软件栈，</p></li><li><p>运行时环境可以从一个用户虚拟集群快速切换到另一个用户虚拟集群</p></li></ul><p>虚拟化另一个优点：负载均衡（通过负载指数和用户登录频率等指标完成）</p><h4 id="高性能虚拟存储"><a href="#高性能虚拟存储" class="headerlink" title="高性能虚拟存储"></a>高性能虚拟存储</h4><p>用于减少虚拟集群分布式文件中的复制块</p><h4 id="在线迁移虚拟机的步骤与性能影响"><a href="#在线迁移虚拟机的步骤与性能影响" class="headerlink" title="在线迁移虚拟机的步骤与性能影响"></a>在线迁移虚拟机的步骤与性能影响</h4><p>虚拟集群中的虚拟机客户系统与主机系统并存，当一个虚拟机失效时，其角色可被其他节点上虚拟机替代，只要两个虚拟机运行相同的客户端系统</p><p>一个物理节点故障转移至另一个主机的虚拟机上</p><h4 id="管理虚拟集群的四种方式"><a href="#管理虚拟集群的四种方式" class="headerlink" title="管理虚拟集群的四种方式"></a>管理虚拟集群的四种方式</h4><ul><li>基于客户的管理器 集群管理器在客户系统中，多个虚拟机形成一个虚拟集群</li><li>基于主机的集群管理器，监督客户系统并能在另一物理量机器上重启客户系统</li><li>在主机系统和客户系统中使用相同独立的集群管理器（基础设施复杂）</li><li>主机系统和客户系统中使用集成的集群：管理器能区分虚拟资源和物理资源</li></ul><h4 id="虚拟机迁移"><a href="#虚拟机迁移" class="headerlink" title="虚拟机迁移"></a>虚拟机迁移</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103152653011.png" alt="image-20210103152653011"></p><h4 id="内存、文件与网络资源迁移"><a href="#内存、文件与网络资源迁移" class="headerlink" title="内存、文件与网络资源迁移"></a>内存、文件与网络资源迁移</h4><p>内存迁移：将虚拟机的内存实例从一个物理节点迁到另一个物理节点</p><p>文件系统迁移：为每个虚拟机提供一个一致的位置无关的在所有物理主机上都能访问的文件系统</p><p>网络迁移：迁移时虚拟机应维持所有开放的网络连接，不依赖原始主机转发或者依赖移动性或重定向机制的支持</p><p>在线迁移主要使用预复制方法：先传输所有的内存页，然后迭代传输上次传输中被修改的内存页</p><h3 id="3-5-数据中心的自动化与虚拟化"><a href="#3-5-数据中心的自动化与虚拟化" class="headerlink" title="3.5 数据中心的自动化与虚拟化"></a>3.5 数据中心的自动化与虚拟化</h3><h4 id="数据中心服务器合并"><a href="#数据中心服务器合并" class="headerlink" title="数据中心服务器合并"></a>数据中心服务器合并</h4><p>减少服务器数目，改进硬件资源低利用效率</p><p>数据中心需要优化资源管理，这些服务器合并技术在整机服务器运行，难以使资源管理得到有效优化</p><ul><li>合并增强硬件利用效率</li><li>资源得到更灵活的配置调度</li><li>总体拥有成本降低</li><li>改进可用性和业务连续性</li></ul><h4 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h4><p>虚拟存储包括由VMM和客户操作系统管理的存储</p><p>分为虚拟机镜像和应用程序数据</p><p>最重要的是封装和隔离：一个虚拟机仅运行一个系统，系统中运行许多应用程序，系统虚拟化允许许多虚拟机同时运行在物理机器上并且虚拟机之间完全隔离。</p><h4 id="虚拟化数据中心的可信管理"><a href="#虚拟化数据中心的可信管理" class="headerlink" title="虚拟化数据中心的可信管理"></a>虚拟化数据中心的可信管理</h4><p>VMM是虚拟系统安全基础，虚拟机访问任何硬件都需要VMM的审查</p><h2 id="第四章：构建在虚拟化数据中心上的云平台体系结构"><a href="#第四章：构建在虚拟化数据中心上的云平台体系结构" class="headerlink" title="第四章：构建在虚拟化数据中心上的云平台体系结构"></a>第四章：构建在虚拟化数据中心上的云平台体系结构</h2><h3 id="4-1-云计算和服务模型"><a href="#4-1-云计算和服务模型" class="headerlink" title="4.1 云计算和服务模型"></a>4.1 云计算和服务模型</h3><ul><li>任意位置访问部署（便宜）</li><li>构建在大规模数据中心之上</li><li>致力于自动化的硬件、数据库、用户接口和应用程序环境吧他们结构化为虚拟资源，来驱动下一代的数据中心</li><li>渴望通过自动化资源配置来构建更好的数据中心</li></ul><p>云计算是一种高吞吐量的计算范式，通过大的数据中心或服务器群提供服务。使得用户可以随时随地通过狐狸啊设备访问共享资源</p><h4 id="公有云和私有云"><a href="#公有云和私有云" class="headerlink" title="公有云和私有云"></a>公有云和私有云</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210103162023316.png" alt="image-20210103162023316"></p><h4 id="云设计目标"><a href="#云设计目标" class="headerlink" title="云设计目标"></a>云设计目标</h4><ul><li><p>将计算从桌面转向数据中心，计算中心</p></li><li><p>服务配置与云效益</p></li><li><p>性能可扩展</p></li><li>数据隐私保护</li><li>高质量云服务</li><li>新标准和接口</li><li>降低小型用户大型企业计算成本</li><li>减轻创业型公司经济负担</li></ul><h4 id="基础设施及服务（IaaS）"><a href="#基础设施及服务（IaaS）" class="headerlink" title="基础设施及服务（IaaS）"></a>基础设施及服务（IaaS）</h4><p>云计算将基础设施，平台和软件作为服务发布，是的用户能够即用即付，使用基于订阅的服务。</p><p>云上服务分为三种：IaaS,Paas(平台即服务),SaaS（软件即服务）</p><p>SaaS由用户使用特殊接口，在应用程序端，PaaS层，云平台进行计费服务，处理作业队列，启动监视服务。底层是IaaS服务，需要配置数据库，计算实例，文件系统和存储以满足用户需求。IaaS包括存储即服务，计算实例即服务和通信即服务</p><h4 id="平台即服务（PaaS）"><a href="#平台即服务（PaaS）" class="headerlink" title="平台即服务（PaaS）"></a>平台即服务（PaaS）</h4><p>平台云是一个由硬件和软件基础设施构成的集成的计算机系统，可以在这个虚拟化云平台使用提供商支持的一些编程语言和软件工具开发用户应用程序</p><p>用户不需要管理底层基础设施，世界不同的用户可以在统一的软件平台协同工作，鼓励第三方组织提供软件管理，集成和服务监视解决方案。</p><h4 id="软件即服务（SaaS）"><a href="#软件即服务（SaaS）" class="headerlink" title="软件即服务（SaaS）"></a>软件即服务（SaaS）</h4><p>软件即服务是指上千的云客户通过浏览器访问的应用程序软件</p><p>PaaS 提供的服务和工具用于构建应用程序和管理他们所部署的由IaaS提供的资源</p><p>SaaS模型将软件应用作为服务进行提供，对客户来讲，无需为服务器或软件预先投资，对提供商来讲，与传统的用户应用程序托管相比成本很低</p><p>为支持PaaS和IaaS，客户数据存储在云中，云或者是专门的提供商，或者公开托管</p><h3 id="4-2-数据中心设计与互联网络"><a href="#4-2-数据中心设计与互联网络" class="headerlink" title="4.2 数据中心设计与互联网络"></a>4.2 数据中心设计与互联网络</h3><p>数据中心是大量服务器通过巨大互联网构建而成</p><p>数据中心越大，运营成本越低</p><p>数据中心关键的核心设计师数据中心集群中所有服务器之间的互联网络，要求低延迟，高带宽，低成本，消息传递接口，通信支持和容错，必须满足服务器节点之间点对点和群对群通信模式</p><ul><li>应用程序的网络通信支持</li><li>网络可扩展性</li><li>容错与降级</li><li>以交换机为中心的数据中心设计</li></ul><h4 id="数据中心管理问题"><a href="#数据中心管理问题" class="headerlink" title="数据中心管理问题"></a>数据中心管理问题</h4><ul><li>使普通用户满意</li><li>可控信息流</li><li>多用户管理</li><li>适应数据库增长可扩展性</li><li>用户和提供商低成本</li><li>安全防范和数据保护</li><li>绿色信息技术</li></ul><h3 id="4-3-计算与存储云体系结构设计"><a href="#4-3-计算与存储云体系结构设计" class="headerlink" title="4.3 计算与存储云体系结构设计"></a>4.3 计算与存储云体系结构设计</h3><h4 id="通用云体系结构设计"><a href="#通用云体系结构设计" class="headerlink" title="通用云体系结构设计"></a>通用云体系结构设计</h4><p>云设计目标：可扩展性，虚拟化，有效性，可靠性</p><p>云管理器软件要同时支持物理机和虚拟机，共享资源的安全性和数据中心的共享访问为设计提出另一个挑战</p><h4 id="云的关键技术"><a href="#云的关键技术" class="headerlink" title="云的关键技术"></a>云的关键技术</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105513118.png" alt="image-20210104105513118"></p><h4 id="通用云体系结构"><a href="#通用云体系结构" class="headerlink" title="通用云体系结构"></a>通用云体系结构</h4><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105602739.png" alt="image-20210104105602739"></p><h4 id="层次化云体系结构开发"><a href="#层次化云体系结构开发" class="headerlink" title="层次化云体系结构开发"></a>层次化云体系结构开发</h4><p>三层：基础设施层，平台层，应用程序层，<strong>使用云中分配的经虚拟化和标准化的硬件与软件资源实现</strong></p><p>首先部署基础设施层来支持IaaS服务。基础设施层是为支持PaaS服务构建云平台层的基础。平台层是为SaaS应用而实现应用层的基础。</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104105813088.png" alt="image-20210104105813088"></p><h4 id="虚拟化支持和灾难恢复"><a href="#虚拟化支持和灾难恢复" class="headerlink" title="虚拟化支持和灾难恢复"></a>虚拟化支持和灾难恢复</h4><p>云计算的虚拟化意味着资源和基础设施都是虚拟化的。</p><p>虚拟化软件用来虚拟化硬件。系统虚拟化软件是一种特殊类型的软件，它模拟硬件的执行并在其上运行未经修改的操作系统。云计算系统使用虚拟化软件作为遗产软件（如旧操作系统或罕见应用）的运行环境。虚拟化软件也被用作开发新的云应用的平台</p><p>  系统虚拟化软件可被看做是一种硬件模拟机制，可以在系统虚拟化软件上不经修改地直接运行之前运行在裸机上的操作系统。</p><h4 id="体系结构设计挑战"><a href="#体系结构设计挑战" class="headerlink" title="体系结构设计挑战"></a>体系结构设计挑战</h4><p>挑战1：服务可用性和数据锁定问题</p><p>挑战2：数据隐私和安全性考虑</p><p>挑战3：不可预测的性能和瓶颈</p><p>挑战4：分布式存储和广泛存在的软件故障</p><p>挑战5：云可扩展性、互操作性和标准化</p><p>挑战6：软件许可和信誉共享</p><h2 id="第五章-面向服务的分布式体系结构"><a href="#第五章-面向服务的分布式体系结构" class="headerlink" title="第五章 面向服务的分布式体系结构"></a>第五章 面向服务的分布式体系结构</h2><h4 id="服务和面向服务体系结构"><a href="#服务和面向服务体系结构" class="headerlink" title="服务和面向服务体系结构"></a>服务和面向服务体系结构</h4><p>SOA是一种分布式系统体系结构，旨在如何设计一套使用的服务的软件系统，</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104113827935.png" alt="image-20210104113827935"></p><p>SOA特性：</p><ul><li>逻辑视图：SOA是实际程序，数据库，商业流程的逻辑视图</li><li>基于消息：人不必知道实现服务代理如何构造的</li><li>基于描述：服务由元数据描述，只包括哪些公开可访问并对服务应用很重要的细节<ul><li>粒度：服务倾向使用少量的操作，使用大而复杂的信息</li><li>网络方向：服务往往是在网络上沿着使用的方向，尽管不是必须</li><li>平台中立性：标准化格式通过接口发送，XML</li></ul></li></ul><p>web服务时SOA最常见实例之一</p><h4 id="REST和系统的系统"><a href="#REST和系统的系统" class="headerlink" title="REST和系统的系统"></a>REST和系统的系统</h4><p>REST是应用于分布式系统的软件体系结构风格，基于以下四个基本原则</p><ul><li>通过URI的资源标识：标识与客户端进行交互的目标</li><li>统一的受限接口：通过客户端、服务器可缓存的协议标准进行交互</li><li>自我描述的信息：消息包含足够的信息来描述如何处理</li><li>无状态的交互：不依赖会话状态</li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104132219474.png" alt="image-20210104132219474"></p><h4 id="WEB的核心技术"><a href="#WEB的核心技术" class="headerlink" title="WEB的核心技术"></a>WEB的核心技术</h4><p>简单对象访问协议（SOAP）提供标准封装结构用在不同协议中传输xml</p><p>WEB服务描述语言（WSDL）描述了接口，标准化了操作的输入和输出参数的表示以及服务协议绑定，</p><p>通用描述发现和集成（UDDI）提供通过搜索名称、标识符、类别、或Web服务实现的规范来广告和发现Web服务的全局注册表</p><h4 id="企业多层体系结构"><a href="#企业多层体系结构" class="headerlink" title="企业多层体系结构"></a>企业多层体系结构</h4><p>企业应用程序用多重体系结构封装各种功能。</p><p>多层体系机构基于C/S，最简单的是两层，也就是C/S，传统的服务器集群在维修升级部署时需要服务器下线，并且胖客户端环境下新应用增强部署消耗时间，降低可用性</p><p>三层系统包含：</p><ul><li>表述层：向外部实体描述信息，允许通过提交操作和获得响应和系统交互</li><li>商业、应用逻辑层或中间件：可控制用户认证，访问资源，完成一些客户端查询处理</li><li>资源管理层/数据层：处理实现信息系统的不同数据源</li></ul><h4 id="网络服务和OGSA"><a href="#网络服务和OGSA" class="headerlink" title="网络服务和OGSA"></a>网络服务和OGSA</h4><p>开放网络服务体系结构（OGSA）旨在为基于网格的应用定义一个通用的开放的体系结构，意图在于：</p><ul><li><p>便于在分布式的异构环境上使用和管理资源。</p></li><li><p>提供无缝的服务质量。</p></li><li><p>为了提供不同资源之间的互操作性，定义开放的发布接口。</p></li><li><p>采用工业标准的集成技术。</p></li><li><p>开发实现互操作性的标准。</p></li><li><p>在分布式的异构环境中集成、虚拟化和管理各种服务与资源。</p></li><li><p>提供松耦合的可交互服务，并且满足工业可接受的Web服务标准。</p></li></ul><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104143018926.png" alt="image-20210104143018926"></p><h3 id="5-2-面向消息的中间件"><a href="#5-2-面向消息的中间件" class="headerlink" title="5.2 面向消息的中间件"></a>5.2 面向消息的中间件</h3><h4 id="企业总线"><a href="#企业总线" class="headerlink" title="企业总线"></a>企业总线</h4><p>企业服务总线（ESB）指总线支持许多组件，采用不同风格能够方便的集成到一起，在源和目的之间开一个通道，把带有足够信息的消息注入总线</p><h4 id="发布订阅模型和通知"><a href="#发布订阅模型和通知" class="headerlink" title="发布订阅模型和通知"></a>发布订阅模型和通知</h4><p>“发布-订阅”概念对于消息总线，描述源和目的连接起来的特殊模型，在发布者上贴上标签，与词汇表里主题名词管理，消息的接受者会接收到他们希望接收的相关消息，或者可以给予内容发布系统（SQL）查询</p><p>使用基于主题或内容的消息选择称为消息过滤</p><h3 id="5-3-门户和科学网关"><a href="#5-3-门户和科学网关" class="headerlink" title="5.3 门户和科学网关"></a>5.3 门户和科学网关</h3><p>网关是更复杂的实体，科学网关也称门户</p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104150739351.png" alt="image-20210104150739351"></p><h3 id="5-4-发现、注册表、元数据和数据库"><a href="#5-4-发现、注册表、元数据和数据库" class="headerlink" title="5.4 发现、注册表、元数据和数据库"></a>5.4 发现、注册表、元数据和数据库</h3><p>注册表是复杂的命名和目录服务：为了存储元数据，有一套数据结构规范，为了存储主，包含和归类服务元数据，要一套操作来存储，删除和查找数据。</p><p>注册表包含三类信息：</p><p>白页：实体名字和一般联系信息</p><p>黄页：条目提供服务类型和位置分类信息</p><p>绿页：如何调用所提供服务的详细信息</p><h4 id="UDDI和服务注册表"><a href="#UDDI和服务注册表" class="headerlink" title="UDDI和服务注册表"></a>UDDI和服务注册表</h4><p>UDDI（统一描述发现和集成）创建平台无关的开放框架定义一种描述发布WEb服务信息的方法。提供名字和目录服务爱通过名字或特定属性查找服务描述</p><p>注册表有两类</p><ul><li>公共注册表：逻辑的集中式分布服务，彼此在一个约定的基础上传数据。</li><li>私有注册表：单个组织内部访问，或特定目的的商业伙伴共享</li></ul><h4 id="数据库和订阅-发布"><a href="#数据库和订阅-发布" class="headerlink" title="数据库和订阅-发布"></a>数据库和订阅-发布</h4><p>订阅-发布是分布式应用实现异步交互的设计模式</p><p>防止轮询查询数据库，时间订阅者注册某个事件类型，发布者产生这样的事件时，订阅者从发布者得到通知，订阅者与发布者是多对多的关系。为数据库的静态本质增加了动态性。</p><p>分为基于主题的和基于内容的。</p><p>数据库提供基于消息传递的体系结构，可以使用许多特性，例如可靠的存储，事物和触发器。</p><h4 id="元数据目录"><a href="#元数据目录" class="headerlink" title="元数据目录"></a>元数据目录</h4><p>元数据是关于数据的信息，识别，定位和解释数据，为数据增加上下文。</p><p>网格上的关键元数据包括数据源的名称和位置、在这些数据源中数据的结构，数据项名称和描述以及用户信息或者可用服务的基本列表和简单查找。</p><h4 id="语义Web和网络"><a href="#语义Web和网络" class="headerlink" title="语义Web和网络"></a>语义Web和网络</h4><p>语义Web是关于自动化发现和集成的：给数据增加机器可处理语义，让机器理解并代表终端处理。从而基于为Web页面附加丰富元数据使web搜索链接更智能。</p><p>语义Web旨在提供一个环境，在里面软件代理能够动态的发现，询问和互操作资源并代替人执行复杂任务。</p><h4 id="作业执行环境和监控"><a href="#作业执行环境和监控" class="headerlink" title="作业执行环境和监控"></a>作业执行环境和监控</h4><p>分布式作业执行环境包括：作业执行引擎（处理作业调度，资源分配与容错）和分布式数据管理系统（为作业访问分布式数据提供抽象）。</p><h3 id="5-5-面向服务的体系结构工作流"><a href="#5-5-面向服务的体系结构工作流" class="headerlink" title="5.5 面向服务的体系结构工作流"></a>5.5 面向服务的体系结构工作流</h3><h4 id="工作流基本概念"><a href="#工作流基本概念" class="headerlink" title="工作流基本概念"></a>工作流基本概念</h4><p>对服务之间交互进行编程的方法。意味着分布式两层编程模型，基本服务采用传统语言编程，描述了服务之间彼此交互的粗粒度编程。他们之间的交互用工作流描述。</p><h4 id="工作流标准"><a href="#工作流标准" class="headerlink" title="工作流标准"></a>工作流标准</h4><h4 id="工作流体系和规范"><a href="#工作流体系和规范" class="headerlink" title="工作流体系和规范"></a>工作流体系和规范</h4><p>两个关键组件：工作流规范和工作流运行引擎，通过接口互相连接</p><h4 id="工作流运行引擎"><a href="#工作流运行引擎" class="headerlink" title="工作流运行引擎"></a>工作流运行引擎</h4><p>有向无环图，</p><p>使用传统语言和工具集的脚本是构建工作流的主要技术</p><p>最复杂的工作流支持层次化规范，即工作流节点可以是服务或服务集。</p><h2 id="第六章-云编程和软件环境"><a href="#第六章-云编程和软件环境" class="headerlink" title="第六章 云编程和软件环境"></a>第六章 云编程和软件环境</h2><h3 id="6-1-云和网络平台的特性"><a href="#6-1-云和网络平台的特性" class="headerlink" title="6.1 云和网络平台的特性"></a>6.1 云和网络平台的特性</h3><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165649219.png" alt="image-20210104165649219"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165659938.png" alt="image-20210104165659938"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165707706.png" alt="image-20210104165707706"></p><p><img src="/2021/01/03/Distributed-cloud-computing/image-20210104165716339.png" alt="image-20210104165716339"></p><h4 id="网络和云的公共传统特征"><a href="#网络和云的公共传统特征" class="headerlink" title="网络和云的公共传统特征"></a>网络和云的公共传统特征</h4><p>工作流：在真实应用中工作流按需连接多个云和非云服务</p><p>数据传输：商业云中的数据传输成本</p><p>云编程环境的安全隐私和可用性需求：</p><ul><li>使用虚拟集群化实现最小开销成本达到资源动态供应</li><li>使用稳定和持续数据传输，带有用于信息检索的快速查询</li><li>特殊API来验证用户</li><li>使用HTTPS或者SSL等安全协议访问云资源</li><li>细粒度保护数据完整性，阻止入侵者或黑客</li><li>保护共享数据集</li><li>实时迁移和灾难恢复</li><li>使用信用系统保护数据中心</li></ul><h4 id="数据特性和数据库"><a href="#数据特性和数据库" class="headerlink" title="数据特性和数据库"></a>数据特性和数据库</h4><p>程序库：允许方便部署配置镜像（即支持IaaS）</p><p>Blob和驱动：类似共享文件系统</p><p>DPFS：这个文件系统是为执行数据密集型应用设计的</p><p>SQL和关系型数据库</p><p>表格和NOSQL非关系型数据库</p><p>队列服务：扩展组件间通信</p><h3 id="6-2-并行和分布式编程范式"><a href="#6-2-并行和分布式编程范式" class="headerlink" title="6.2 并行和分布式编程范式"></a>6.2 并行和分布式编程范式</h3><p>是运行在多个计算引擎或一个分布式计算系统上的并行程序，包含分布式系统和并行计算。分布式系统是一系列网络连接的计算引擎，完成一个共同目标：运行一个作业或者应用。并行计算时同时用多个引擎运行作业或者应用。</p><h4 id="并行计算和编程范式"><a href="#并行计算和编程范式" class="headerlink" title="并行计算和编程范式"></a>并行计算和编程范式</h4><p>多个网络节点或工作机组成用并行或者分布式方式来运行并行的程序，包括以下方面</p><ul><li><p>分区 分为识别分区和计算分区</p><ul><li>计算分区：<strong>将指定任务分割为小任务</strong>，分区过程很大程度依靠正确识别可以并发执行的作业或程序的每一小部分</li><li>数据分区：<strong>将输入或中间数据分割成更小部分</strong>。类似地，一旦识别出输入数据的并行性，它也可以被分割成多个部分，能在不同的工作机上运行。数据块可由程序的不同部分或者同一程序的副本来处理。</li></ul></li><li><p>映射：把更小的程序部分或更小的数据分块分给底层的资源，过程目的在于合理分配这些部分或者分块，使它们能同时在不同的工作机上运行。由系统中的资源分配器处理</p></li><li><p>同步：不同工作机可以执行不同任务，工作机之间同步和协同很有必要。可以避免竞争条件，不同工作机之间数据依赖也能恰当的管理。然而，一个工作机需要其他工作机处理的数据时会产生数据依赖</p></li><li><p>通信：中间数据转备好在工作机之间传送时通信就开始了</p></li><li>调度：数据块多于可用工作机数量时，调度程序选择一个任务序列分配给工作机。只基于一套称为调度策略的规则，对于多作业或多程序，调度器会选择运行在分布式系统上的一个任务或程序序列。</li></ul><h4 id="编程范式动机"><a href="#编程范式动机" class="headerlink" title="编程范式动机"></a>编程范式动机</h4><ul><li>提供并行或分布式范式或模型来抽象用户数据流的多个部分</li><li><p>编写并行程序的简单性是度量并行和分布式编程范式的重要标准。</p><ul><li>提高程序员效率</li><li>减少程序进入市场时间</li><li>有效利用系统资源</li><li>提高吞吐量</li><li>支持更高层抽象</li></ul></li><li><p>MapReduce、Hadoop和Dryad是最近提出的三种并行和分布式编程模型，为信息检索而开发。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-分布式系统模型和关键技术&quot;&gt;&lt;a href=&quot;#第一章-分布式系统模型和关键技术&quot; class=&quot;headerlink&quot; title=&quot;第一章 分布式系统模型和关键技术&quot;&gt;&lt;/a&gt;第一章 分布式系统模型和关键技术&lt;/h2&gt;&lt;h3 id=&quot;1-1互联网上的可扩展计算&quot;&gt;&lt;a href=&quot;#1-1互联网上的可扩展计算&quot; class=&quot;headerlink&quot; title=&quot;1.1互联网上的可扩展计算&quot;&gt;&lt;/a&gt;1.1互联网上的可扩展计算&lt;/h3&gt;&lt;p&gt;一个并行的、分布式的计算系统使用大量的计算机解决互联网上的大规模计算问题。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP-summarize</title>
    <link href="http://yokeso.top/2020/12/01/CSAPP-summarize/"/>
    <id>http://yokeso.top/2020/12/01/CSAPP-summarize/</id>
    <published>2020-12-01T08:45:41.000Z</published>
    <updated>2021-03-09T13:03:40.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP重要知识点总结"><a href="#CSAPP重要知识点总结" class="headerlink" title="CSAPP重要知识点总结"></a>CSAPP重要知识点总结</h2><h4 id="第一章-—-计算机系统漫游"><a href="#第一章-—-计算机系统漫游" class="headerlink" title="第一章 — 计算机系统漫游"></a>第一章 — 计算机系统漫游</h4><h5 id="1-Hello-world的生命周期"><a href="#1-Hello-world的生命周期" class="headerlink" title="1.Hello world的生命周期"></a>1.Hello world的生命周期</h5><h6 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h6><span id="more"></span><ul><li>shell程序输入<code>./hello</code>,shell将其逐一读到寄存器里并放入内存。</li><li>shell利用fork()函数创建进程</li></ul><h6 id="2-程序加载运行"><a href="#2-程序加载运行" class="headerlink" title="2.程序加载运行"></a>2.程序加载运行</h6><ul><li>调用execve()函数映射进程结构</li><li>对程序所需要的共享库进行动态连接</li><li>利用mmap将文件或其他对向映射到内存</li></ul><h6 id="3-执行指令"><a href="#3-执行指令" class="headerlink" title="3.执行指令"></a>3.执行指令</h6><ul><li>执行第一条代码，产生缺页中断<ul><li>处理器将VA给MMU，</li><li>MMU产生TLBA传给页表，</li><li>从页表中加载PTE。</li><li>PTE有效位为0，产生缺页异常。</li><li>缺页处理程序选择物理内存的牺牲页，如果页被修改则换出到磁盘。</li><li>新页调入内存。</li><li>更新PTE,返回原进程重新执行缺页指令</li></ul></li></ul><p><img src="/2020/12/01/CSAPP-summarize/image-20201202203601317.png" alt="image-20201202203601317"></p><h6 id="4-访问数据"><a href="#4-访问数据" class="headerlink" title="4.访问数据"></a>4.访问数据</h6><ul><li>访问数据时同样会产生缺页中断。</li></ul><h6 id="5-显示输出"><a href="#5-显示输出" class="headerlink" title="5.显示输出"></a>5.显示输出</h6><ul><li>调用c标准函数printf()，调用运行时会产生堆栈段缺页，调用write()函数进行屏幕显示。</li></ul><h6 id="6-进程终止"><a href="#6-进程终止" class="headerlink" title="6.进程终止"></a>6.进程终止</h6><ul><li>显示完成后进程终止，被父进程回收</li></ul><h5 id="2-一些小知识点"><a href="#2-一些小知识点" class="headerlink" title="2.一些小知识点"></a>2.一些小知识点</h5><p>1.操作系统使用抽象的概念</p><ul><li>防止硬件被失控程序滥用</li><li>提供简单的一致的机制管理复杂不同的低级硬件设备</li></ul><p><img src="/2020/12/01/CSAPP-summarize/image-20201202195155158.png" alt="image-20201202195155158"></p><p>2.编译系统包括（预处理器 编译器 汇编器 链接器）</p><h4 id="第二章-—-信息的表示和处理"><a href="#第二章-—-信息的表示和处理" class="headerlink" title="第二章 — 信息的表示和处理"></a>第二章 — 信息的表示和处理</h4><h5 id="1-算数溢出产生的漏洞"><a href="#1-算数溢出产生的漏洞" class="headerlink" title="1.算数溢出产生的漏洞"></a>1.算数溢出产生的漏洞</h5><h5 id="2-浮点数IEEE表示"><a href="#2-浮点数IEEE表示" class="headerlink" title="2.浮点数IEEE表示"></a>2.浮点数IEEE表示</h5><p>规格化数与非规格化数</p><h5 id="3-左移右移"><a href="#3-左移右移" class="headerlink" title="3.左移右移"></a>3.左移右移</h5><h5 id="4-带符号数与无符号数的转换"><a href="#4-带符号数与无符号数的转换" class="headerlink" title="4.带符号数与无符号数的转换"></a>4.带符号数与无符号数的转换</h5><p>sizeof()函数输出的数值是一个无符号数。如果直接拿去进行循环对比的话可能会产生问题</p><h4 id="第三章-—-程序的机器级表示"><a href="#第三章-—-程序的机器级表示" class="headerlink" title="第三章 — 程序的机器级表示"></a>第三章 — 程序的机器级表示</h4><h4 id="第四章-—-处理器体系结构"><a href="#第四章-—-处理器体系结构" class="headerlink" title="第四章 — 处理器体系结构"></a>第四章 — 处理器体系结构</h4><p>Y86-64CPU顺序结构设计与实现中分为6个阶段<code>P264</code></p><p>取指 译码 执行 访存 写回 更新PC</p><h4 id="第五章-—-优化程序性能"><a href="#第五章-—-优化程序性能" class="headerlink" title="第五章 — 优化程序性能"></a>第五章 — 优化程序性能</h4><h4 id="第六章-—-存储器层次结构"><a href="#第六章-—-存储器层次结构" class="headerlink" title="第六章 — 存储器层次结构"></a>第六章 — 存储器层次结构</h4><h4 id="第七章-—-链接"><a href="#第七章-—-链接" class="headerlink" title="第七章 — 链接"></a>第七章 — 链接</h4><h5 id="1-ELF头（可重定位目标文件格式）"><a href="#1-ELF头（可重定位目标文件格式）" class="headerlink" title="1.ELF头（可重定位目标文件格式）"></a>1.ELF头（可重定位目标文件格式）</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201202223638552.png" alt="image-20201202223638552"></p><p>ELF头以16字节序列开始，描述了系统字大小和字节顺序，帮助连接器语法分析和解释目标文件信息（ELF头大小，目标文件类型、机器类型、节头部表的文件偏移、节头部表中条目的大小和数量）不同节的大小是由节头部hi奥描述的。目标文件中每一个节都有固定大小的条目</p><p>关于几个节的解释</p><ul><li>.text： 已编译程序的机器代码</li><li>.rodata：只读数据，printf语句中的格式串和switch的跳转表</li><li>.data：已初始化的全局和静态C变量。局部C变量运行时保存在栈中，既不出现在.data中，也不出现在.bss中</li><li>.bss：未初始化的全局和静态C变量。以及所有被初始化为0的全局或静态变量。<strong>在目标文件中这个节不占用实际的空间</strong>。仅仅是一个占位符。运行时内存分配变量，初始值为0</li><li>.symtab：一个符号表。存放程序中定义和引用的全局变量的信息（不包含全局变量的条目、与编译器中的符号表不同）</li><li>.rel.text：text节中位置的表，目标文件与其他文件组合时需要修改（调用外部函数或者引用全局变量的指令）。调用本地函数时则不需要修改。<strong>通常省略</strong></li><li>.rel.data：被模块引用或定义的所有全局变量的重定位信息。如果一个初始化的全局变量的初始值时一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li>.debug：调试符号表。-g选项才能得到这张表</li><li>.line：C中行号和.text节中机器指令的映射。-g编译时才能得到</li><li>.strtab：一个字符串表，包括.symtab和.debug中的符号表以及节头部中的节名字</li></ul><h5 id="2-常考的几点"><a href="#2-常考的几点" class="headerlink" title="2.常考的几点"></a>2.常考的几点</h5><ul><li><strong>.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理</strong></li><li><strong>C static属性的本地变量不在栈中管理，而是在.data或.bss中为每个定义分配空间，并在符号表中创建一个由唯一名字（eg: x.1、x.2）的本地链接器符号表</strong></li><li><p>可重定位目标文件中的伪节</p><ul><li>ABS：不该被重定义的符号</li><li>UNDEF：未定义的符号，本目标模块引用但是在其他地方定义的符号</li><li>COMMON：未分配位置的未初始化数据目标</li></ul></li><li><p>COMMON与.bss区别</p><ul><li>COMMON 未初始化全局变量</li><li>.bss 未初始化静态变量，以及初始化未0的全局或静态变量</li></ul></li></ul><h5 id="3-强符号与弱符号（连接器如何解析多重定义的全局符号）"><a href="#3-强符号与弱符号（连接器如何解析多重定义的全局符号）" class="headerlink" title="3.强符号与弱符号（连接器如何解析多重定义的全局符号）"></a>3.强符号与弱符号（连接器如何解析多重定义的全局符号）</h5><p>在编译时，编译器向汇编器输出每个全局符号（强或者是弱），而汇编器把这个信息隐含的编码在<strong>可重定位目标文件的符号表里</strong>。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号</p><p>Linux连接器使用下面规则来定义强弱符号：</p><ul><li>不允许有多个同名的强符号</li><li>如果有一个强符号和多个弱符号同名，那么选择强符号</li><li>如果有多个弱符号同名，那么从这些弱符号中任选一个</li></ul><h4 id="第八章-—-异常控制流"><a href="#第八章-—-异常控制流" class="headerlink" title="第八章 — 异常控制流"></a>第八章 — 异常控制流</h4><h5 id="信号："><a href="#信号：" class="headerlink" title="信号："></a>信号：</h5><p>信号是通知进程系统中发生某种类型事件的一条小消息</p><h6 id="需要记的几个信号"><a href="#需要记的几个信号" class="headerlink" title="需要记的几个信号"></a>需要记的几个信号</h6><ul><li>（<strong>但除以0可能发生的情况有 显示除法溢出退出 不提示任何错误 用户程序决定处理办法</strong>）</li></ul><div class="table-container"><table><thead><tr><th>信号量</th><th>默认行为</th><th style="text-align:left">事件</th><th>何时考核</th></tr></thead><tbody><tr><td>SIGFPE</td><td>终止并转储内存</td><td style="text-align:left">进程试图除以0                                                                                                    但除以0可能发生的情况有 显示除法溢出退出 不提示任何错误 用户程序决定处理办法</td><td>2017A</td></tr><tr><td>SIGCHLD</td><td>忽略</td><td style="text-align:left">子进程终止或者停止时发送给父进程</td><td>2017B，2018B</td></tr><tr><td>SIGCONT</td><td>忽略</td><td style="text-align:left">继续进程如果该进程停止（预定义默认行为）</td><td>2017A</td></tr><tr><td>SIGINT</td><td>终止</td><td style="text-align:left">来自键盘的中断（ctrl+C）</td></tr></tbody></table></div><h4 id="第九章-—-虚拟内存"><a href="#第九章-—-虚拟内存" class="headerlink" title="第九章 — 虚拟内存"></a>第九章 — 虚拟内存</h4><p>CPU生成虚拟地址(VA)访问主存，虚拟地址被送到内存之前先转化成合适的物理地址。——地址翻译</p><p>虚拟页面的集合分为三个不相交的子集</p><ul><li>未分配</li><li>缓存的</li><li>未缓存的</li></ul><p><strong>页表条目的大小是n，也就是地址位数。</strong></p><h5 id="1-地址翻译过程："><a href="#1-地址翻译过程：" class="headerlink" title="1.地址翻译过程："></a>1.地址翻译过程：</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205163159359.png" alt="image-20201205163159359"></p><ul><li>第一步：处理器生成VA并发送到MMU</li><li>第二步：MMU生成PTE地址并从高速缓存/主存请求它</li><li>第三步：CACHE/主存向MMU返回PTE</li><li>第4步:PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第5步:缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第6步:缺页处理程序页面调入新的页面，并更新内存中的PTE。</li></ul><h5 id="2-地址翻译带CACHE与内存的过程"><a href="#2-地址翻译带CACHE与内存的过程" class="headerlink" title="2.地址翻译带CACHE与内存的过程"></a>2.地址翻译带CACHE与内存的过程</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205170317747.png" alt="image-20201205170317747"></p><h5 id="3-地址翻译中的地址结构变换"><a href="#3-地址翻译中的地址结构变换" class="headerlink" title="3.地址翻译中的地址结构变换"></a>3.地址翻译中的地址结构变换</h5><p><img src="/2020/12/01/CSAPP-summarize/image-20201205170418497.png" alt="image-20201205170418497"></p><p>这里默认 <strong>虚拟地址空间48位，物理地址空间52位，CACHE 块大小为64字节，L1、L2 8路组相联。L3 16路组相联。页大小为4KB</strong></p><p><img src="/2020/12/01/CSAPP-summarize/image-20201205172024421.png" alt="image-20201205172024421"></p><p>其中各种地址变化如下</p><p>CPU  产生<code>VA</code> ，形式为 </p><div class="table-container"><table><thead><tr><th style="text-align:center">VPN(虚拟页号)</th><th style="text-align:center">VPO（虚拟页偏移）</th></tr></thead><tbody><tr><td style="text-align:center">36位（页表号）</td><td style="text-align:center">12位（块大小$2^{12}$）</td></tr></tbody></table></div><p><code>VA</code>发送给MMU，MMU生成<code>PTE</code>发送给块表 产生的块表地址<code>LTBA</code>  形式为</p><div class="table-container"><table><thead><tr><th style="text-align:center">LTBT（LTB标记）</th><th style="text-align:center">LTBI（LTB索引）</th></tr></thead><tbody><tr><td style="text-align:center">32位（VPN的前32位）</td><td style="text-align:center">4位（组数量$2^{4}$）</td></tr></tbody></table></div><p>中间的不命中过程省略，主要看命中过程。<code>LTBA</code> 命中后返回一个 <code>PPO</code>，MMU将<code>VPO</code>与<code>PPO</code>组合形成<code>PA</code>形式为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">PPN（物理页号）</th><th style="text-align:center">PPO（物理页偏移）= VPO</th></tr></thead><tbody><tr><td style="text-align:center">40位</td><td style="text-align:center">12位</td></tr></tbody></table></div><p>MMU将<code>PA</code>传送给CACHE，变化为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">CT</th><th style="text-align:center">CI</th><th style="text-align:center">CO</th></tr></thead><tbody><tr><td style="text-align:center">40</td><td style="text-align:center">6（$2^6$组）</td><td style="text-align:center">6</td></tr></tbody></table></div><h5 id="4-分配器"><a href="#4-分配器" class="headerlink" title="4.分配器"></a>4.分配器</h5><h6 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206212526290.png" alt="image-20201206212526290"></p><p>块大小为8的倍数，并且头部占据4个字节</p><p>例如 malloc(13) = 4+13=17 -&gt; 24 头部是 0001 1001 也就是0x19（后三位一定是0因为盘块大小是8的整数）</p><p><strong>当分配器合并的时候会在尾部设置一个和头部一样的脚部</strong></p><h6 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206213231762.png" alt="image-20201206213231762"></p><p><strong>简单分离存储：</strong>链表包含大小相同的块</p><p><strong>分离适配：</strong>块用链表连接</p><p><strong>伙伴系统：</strong>每个类大小都是2的幂</p><h6 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h6><p><img src="/2020/12/01/CSAPP-summarize/image-20201206215004182.png" alt="image-20201206215004182"></p><h4 id="第十章-—-系统级IO"><a href="#第十章-—-系统级IO" class="headerlink" title="第十章 — 系统级IO"></a>第十章 — 系统级IO</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSAPP重要知识点总结&quot;&gt;&lt;a href=&quot;#CSAPP重要知识点总结&quot; class=&quot;headerlink&quot; title=&quot;CSAPP重要知识点总结&quot;&gt;&lt;/a&gt;CSAPP重要知识点总结&lt;/h2&gt;&lt;h4 id=&quot;第一章-—-计算机系统漫游&quot;&gt;&lt;a href=&quot;#第一章-—-计算机系统漫游&quot; class=&quot;headerlink&quot; title=&quot;第一章 — 计算机系统漫游&quot;&gt;&lt;/a&gt;第一章 — 计算机系统漫游&lt;/h4&gt;&lt;h5 id=&quot;1-Hello-world的生命周期&quot;&gt;&lt;a href=&quot;#1-Hello-world的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1.Hello world的生命周期&quot;&gt;&lt;/a&gt;1.Hello world的生命周期&lt;/h5&gt;&lt;h6 id=&quot;1-进程创建&quot;&gt;&lt;a href=&quot;#1-进程创建&quot; class=&quot;headerlink&quot; title=&quot;1.进程创建&quot;&gt;&lt;/a&gt;1.进程创建&lt;/h6&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ComNet2</title>
    <link href="http://yokeso.top/2020/10/05/ComNet2/"/>
    <id>http://yokeso.top/2020/10/05/ComNet2/</id>
    <published>2020-10-05T12:34:36.000Z</published>
    <updated>2021-03-09T12:04:29.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自顶向下计算机网络-2-应用层"><a href="#自顶向下计算机网络-2-应用层" class="headerlink" title="自顶向下计算机网络 2    应用层"></a>自顶向下计算机网络 2    应用层</h2><h3 id="客户-服务器应用模型与P2P应用模型"><a href="#客户-服务器应用模型与P2P应用模型" class="headerlink" title="客户/服务器应用模型与P2P应用模型"></a>客户/服务器应用模型与P2P应用模型</h3><h4 id="客户-服务器应用模型"><a href="#客户-服务器应用模型" class="headerlink" title="客户/服务器应用模型"></a>客户/服务器应用模型</h4><span id="more"></span><p>一个总是打开的主机被称为服务器，它要服务于许多来自于其他称为客户机的主机请求，其工作流程如下：</p><p>1）服务器处于接收请求的状态</p><p>2）客户机发出服务请求并等待接收结果</p><p>3）服务器接收到请求后分析请求，进行必要的处理，得到结果并发送给客户机</p><p>客户机必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。而服务器要运行专门用来提供某种服务的程序，可以同时处理多个远程或者本地客户的要求。系统启动后自动调用并执行。因此服务器程序不需要知道客户机的地址。</p><p>客户/服务器最主要的特征是：客户是服务的请求方，服务器是服务的提供方</p><p>其他主要特点还有：</p><p>1）网络中各个计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的。使它们不能进行随意的增添删除数据或其他受限的网络活动。整个网络的管理工作由少部分服务器担当，因此整个网络的管理十分方便。</p><p>2）客户机之间不会直接通信</p><p>3）可扩展性不佳。收服务器硬件和网络带宽的限制。服务器支持的客户机数量有限。</p><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p>P2P模型的主要思想是在真个网络中传输的内容不再被保存在中心服务器上。每个节点都同时具有上传和下载的功能。其权力和义务是大体对等的。在P2P模型中，计算机没有固定的客户机与服务器的分别，，任意一对计算机都可以互相通信，每一台电脑既可以作为客户机访问其他节点的资源，也作为服务器提供资源给其他节点访问。</p><p>与客户机/服务器模型相比，P2P模型的优点主要体现如下：<br>1）减轻服务器的计算压力，消除了对于服务器的完全依赖。可以将任务分配到各个节点上。提高了系统效率和资源的利用率；</p><p>2）多个客户机之间直接进行文档共享。</p><p>3）可拓展性好，传统服务器有响应和带宽的限制，因此只能接收一定节点的请求。</p><p>4）网络健壮性强。单个节点的失效不会影响其他节点。</p><p>P2P的缺点也很明显。在获取服务的同时，还要给其他节点提供服务。这样会占据很多内存，影响整机速度。经常进行p2p下载还会对硬盘造成较大损伤。</p><h4 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h4><p>Napster文件传输使用P2P结构,文件的搜索采用C/S模式—-集中式</p><hr><h3 id="网络应用通信原理"><a href="#网络应用通信原理" class="headerlink" title="网络应用通信原理"></a>网络应用通信原理</h3><p>进程：主机上运行的程序</p><p>同一主机之间运行的进程如何通信？</p><ul><li>进程间的通信机制</li><li>操作系统提供</li></ul><p>不同主机之间的进程如何通信？</p><ul><li>信息交换</li></ul><p>进程间利用Socket接收/发送消息。</p><ul><li><p>发送方将消息送到门外邮箱</p></li><li><p>发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外</p></li><li><p>接收方从门外获取消息</p></li></ul><p><img src="/2020/10/05/ComNet2/Socket.jpg" alt></p><p>为了在不同主机之间通信，每个进程必须要拥有<font color="red">标识符</font></p><p>如何寻址主机——IP地址</p><p>但是在有了主机IP地址后，由于同一主机上可能有多个进程需要通信，所以要在每个需要通信的进程上分配一个端口号。</p><p>进程的标识符：<font color="red">IP地址+端口号</font></p><p>应用层协议：网络应用应该遵循应用层协议。</p><ul><li><p>分类</p><ul><li>公开协议：RFC协议-&gt;允许互操作：<strong>HTTP SMTP</strong></li><li>私有协议：多数P2P文件共享应用。</li></ul></li><li><p>内容</p><ul><li>消息的类型（type） <ul><li>请求消息</li><li>响应消息</li></ul></li><li>消息的语法（syntax）/格式</li><li>字段的语义（semantics）</li><li>规则（rules）  </li></ul></li></ul><hr><h3 id="DNS系统（层次域名空间，域名服务器，域名解析过程）"><a href="#DNS系统（层次域名空间，域名服务器，域名解析过程）" class="headerlink" title="DNS系统（层次域名空间，域名服务器，域名解析过程）"></a>DNS系统（层次域名空间，域名服务器，域名解析过程）</h3><p>域名系统（Domain Name System，DNS）是因特网使用的域名系统。用来便于把人们记忆的具有特定含义的主机名转换为便于机器处理的IP地址，相对于IP地址，人们更喜欢使用具有特定含义的字符串来标识因特网上的主机。<strong>DSN系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口</strong>。是一个多层命名服务器构成的分布式数据库。</p><p>应用层协议：完成名字的解析</p><ul><li>Internet核心功能，用应用层协议实现。</li><li>网络边界复杂</li></ul><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><p>因特网采用层次树状结构的命名方法，采用这种命名方法，任何一个具有连接到因特网的主机或路由器都有一个唯一的层次结构名称，即域名。域是名字空间中一个可被管理的划分。域可以分为子域，子域还可以继续划分为子域的子域。这样就形成了顶级域，二级域，三级域等。每个域名都由标号序列组成，个标号之间都用<code>.</code>间隔开。</p><p>需要注意以下几点：</p><ul><li>标号中的英文不区分大小写</li><li>标号中除连词符之外不能用其他的标点符号。</li><li>每个标号不超过63个字符多标号组成的完整域名不能超过255字符。</li><li>级别最低的域名写在最左边，级别最高的域名写在最右边。</li></ul><p>DNS服务</p><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：Web服务器</li></ul><p>DNS服务器不使用集中式的原因：</p><ul><li>单点失败问题</li><li>流量问题</li><li>距离问题</li><li>维护性问题</li></ul><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>分布式层次数据库</p><ul><li><font color="red">根服务器</font> (ROOT DNS Sever)：这是最高层次的域名服务器，所有根域名服务器都知道所有的顶级域名服务器的IP地址，本地域名服务器只要有自己无法解析的域名时都会求助根域名服务器。共有13个根域名服务器。<strong>需要注意，根域名服务器不把直接待查询的地址直接转化为IP，而是告诉本地域名服务器下一步找哪个顶级域名服务器查询</strong></li><li><font color="red">顶级域名服务器（TLD Top-Level Domain）</font>：服务com  .edu等顶级域名以及.uk .cn等国际顶级域名。负责管理该顶级服务器管理下的所有二级域名，并在DNS请求时返回响应的回答（最后结果或下一步应该查找的域名服务器）</li><li><font color="red">授权域名服务器</font>:组织的域名解析服务器，提供组织内部的域名解析。将管辖内的主机名转换为IP地址。</li><li>本地域名服务器：每个因特网服务提供者（ISP）大学或者大学的系都可以拥有本地域名服务器.当主机发出DNS请求时，查询请求报文就发送给本地域名服务器</li></ul><p><strong>本地域名解析服务器不严格属于层级体系</strong></p><p><img src="/2020/10/05/ComNet2/Dns.jpg" alt="DNS的层次结构"></p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>域名解析是指把域名映射成IP地址或者把IP地址映射成域名的过程.前者称为<code>正向解析</code>,后者称为<code>反向解析</code>.当客户端需要域名解析时,通过本机的DNS客户端构造一个DNS请求报文.利用UDP数据报的方式发往本地域名服务器.域名解析有两种方式，<font color="red">递归查询和迭代查询</font>。其效果如下：</p><p><img src="/2020/10/05/ComNet2/DNSFind1.jpg" alt="迭代查询"></p><p><img src="/2020/10/05/ComNet2/DNSFind2.jpg" alt="递归查询"></p><p><strong>由于递归查询对根域名的负担较大，现在大多采用迭代查询的方式</strong>。该方式分为两个部分：</p><p><strong>1）主机向本地域名服务器的查询采用的是递归查询</strong></p><ul><li>如果主机询问的本地域名服务器不知道被查询的IP地址，那么本地域名服务器就以DNS客户的身份向根域名服务器发出查询请求报文（替该主机查询而非让主机自己进行下一步的查询）</li><li>本地域名服务器只需要向根域名服务器查询一个，后面的几次查询都是递归的在其他几个域名服务器之间进行的。</li></ul><p>2）本地服务器向根域名服务器的查询是迭代查询。（参照上图进行对比）</p><ul><li>当根服务器从本地域名服务器收到请求后，要么给出要查询的IP地址，要么告诉本地域名服务器下一步应该到哪个顶级域名服务器查询</li><li>同样顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应该像哪个权限域名服务器查询。最后知道所要解析的IP地址后，把这个结果返回给发起查询的主机。</li></ul><p>DNS记录的缓存与更新</p><p>只要域名解析服务器获得域名——IP映射，即缓存这一映射</p><ul><li>一段时间过后，缓存条目失效（删除）</li><li>本地域名服务器一般或缓存顶级域名服务器的映射<ul><li>因此根域名服务器不经常被访问</li></ul></li></ul><p>DNS的记录和报文考纲未做要求，故未整理。</p><hr><h3 id="FTP（FTP协议的工作原理，控制连接与数据连接）"><a href="#FTP（FTP协议的工作原理，控制连接与数据连接）" class="headerlink" title="FTP（FTP协议的工作原理，控制连接与数据连接）"></a>FTP（FTP协议的工作原理，控制连接与数据连接）</h3><p>交互传输协议（FTP）是因特网上使用最广泛的文件传输协议。FTP提供交互式访问。允许客户指明文件的类型与格式。并允许文件拥有存取权限。它屏蔽了计算机的各种细节，适合于在异构的网络中的任意计算机之间传输文件。</p><p>FTP提供一下功能：</p><ul><li>提供不同主机系统之间的文件传输能力。</li><li>以用户权限的方式提供用户对远程FTP服务器上的文件管理能力。</li><li>以匿名FTP提供公用文件共享的能力</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>FTP采用客户机/服务器的模式，利用TCP可靠传输服务。一个FTP服务器进程可以同时为多个客户机提供服务。FTP服务器由两大部分构成：<strong>一个主进程，负责接收新的请求，另外有若干从属进程，负责处理单个请求</strong>。工作步骤如下：</p><ul><li>打开控制端口21，使客户进程能连接上</li><li>等待客户发起请求</li><li>启动从属进程处理客户进程发起的请求，主进程与从属进程并发执行，从属进程对于客户进程的请求处理完毕后即终止。</li><li>回到等待状态，继续处理其他客户请求。</li></ul><p>FTP服务器必须在整个会话过程中保存客户的状态信息。特别使服务器必须把指定的用户账户和控制联系起来，服务器必须追踪用户在远程目录树上的当前位置。</p><h4 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h4><p>FTP在工作时使用两个并行的TCP连接，一个是控制连接（21端口）一个是数据连接（20端口）使用两个不同的端口号可以使协议更加简单和容易实现。</p><h5 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h5><p>服务器监听21端口，等待客户连接，建立在这个端口上的连接称为<code>控制连接</code>，控制连接用来传输控制信息（连接请求，传送请求等）并且控制信息都以7位ASCii码发送。FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程。但控制连接并不用来传送文件，传输文件时还可以使用控制连接（如客户在中途发送终止传输命令），因此控制连接在整个会话期间一直保持打开状态。</p><h5 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h5><p>服务端的控制进程在接收到FTP客户端发送来的文件传输请求后，就创建数据“传输进程”和“数据连接”。数据连接用来连接客户端和服务器端的数据传输进程，数据传送进程实际完成文件的传送。在传送完毕后关闭<code>数据传送连接</code>并结束运行。</p><p>因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息时带外（Out-of-band）传送的。使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器。网络文件系统（NFS）允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><hr><h3 id="电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）"><a href="#电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）" class="headerlink" title="电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）"></a>电子邮件系统（组成结构，邮件格式与MIME，SMTP与POP3）</h3><h4 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h4><p>电子邮件是一种异步通讯方式，允许通信时的双方不同时在场。电子邮件将邮件放在收件人使用的邮箱服务器中，收件人可以随时上网到自己使用的邮件服务器中进行读取。</p><p>一个邮件系统应该具有三部分组成，用户代理，邮件服务器和电子邮件使用协议（SMTP，POP3，IMAP等）</p><ul><li><font color="red">用户代理（UA）</font>用户与电子邮件的接口，用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应该具备撰写，显示和邮件处理的功能。通常情况下，用户代理就是一个运行再PC上的程序。</li><li><font color="red">邮件服务器</font>：组成邮件系统的核心，邮件服务器的功能是发送和接收邮件。同时还要向发信人报告邮件的传送状况（已交付，被拒绝，被丢失等）邮件服务器采用的客户/服务器模式工作。但其能同时担当客户和服务器。</li><li><font color="red">邮件发送协议和读取协议</font>：邮件发送协议用于用户代理向邮件服务器发送邮件或者再邮件服务器之间发送邮件。通常使用的是SMTP，邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3，注意：SMTP采用的是推的方式，即再用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件推送到SMTP服务器端，而POP3采用的是拉的模式，即用户读取邮件时，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件</li></ul><p>电子邮件的发送接收过程如下：</p><ul><li>发信人调用用户代理来撰写编辑要发送的邮件，用户代理用SMTP把邮件传送给发送方服务器。</li><li>发送方邮件服务器将邮件放入缓存队列中，等待发送</li><li>邮件服务器中的SMTP客户进程发现有邮件待发送，向运行在接收方邮件服务器的SMTP服务器发起建立TCP连接</li><li>建立连接后开始向远方发送邮件，发送完成后关闭TCP连接</li><li>接收方邮件服务器接收到邮件后，将邮件放到收信人的用户邮箱，等待收信人方便的时候读取</li><li>收信人打算收信时，调用用户代理，使用POP3或者IMAP将自己的邮件从接收方邮件服务器的用户邮箱中取回</li></ul><h4 id="邮件格式与MME"><a href="#邮件格式与MME" class="headerlink" title="邮件格式与MME"></a>邮件格式与MME</h4><h5 id="１-电子邮件格式"><a href="#１-电子邮件格式" class="headerlink" title="１.电子邮件格式"></a>１.电子邮件格式</h5><p>一个电子邮件格式分为<code>信封</code>与<code>内容</code>两部分，邮件内容又分为首部和主题两部分。<code>RFC 822</code>规定了邮件首部的格式，主体可以由用户自由撰写。用户写好首部后，邮件系统自动的将信封所需要的信息提取出来填写到信封上，用户不需要亲自填写信封上的信息。</p><p>邮件首部包括的最重要的内容有：To:和Subject:</p><ul><li>To后面加一个或者多个收件人的电子邮件地址（邮箱名@主机域名）</li><li>Subject时可选关键字，反应邮件的主要内容</li><li>From，邮件自动填入</li></ul><h5 id="2-多用途网际邮件扩充（MIME）"><a href="#2-多用途网际邮件扩充（MIME）" class="headerlink" title="2.多用途网际邮件扩充（MIME）"></a>2.多用途网际邮件扩充（MIME）</h5><p>由于用户的语言不一致性，为了传送非英语文字，使用了MIME。MIME未改变SMTP，指示增加了邮件的主体结构，定义了传送非ASCii码的编码规则。</p><p>包括以下三部分内容：</p><ul><li>5个新的邮件首部字段，MIME版本，内容描述，内容标识，内容传送码，内容类型</li><li>定义邮件内容格式，对多媒体电子邮件标识方法做了标准化</li><li>定义传送编码，可对内容格式进行转换并不会被邮件系统改变</li></ul><h4 id="SMTP与POP3"><a href="#SMTP与POP3" class="headerlink" title="SMTP与POP3"></a>SMTP与POP3</h4><h5 id="1-SMTP（Simple-Mail-Transfer-Protocol）"><a href="#1-SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="1.SMTP（Simple Mail Transfer Protocol）"></a>1.SMTP（Simple Mail Transfer Protocol）</h5><p>SMTP运用TCP连接，端口号为25，通信过程为三个阶段</p><ul><li>建立连接：SMTP客户每隔一定时间对邮箱缓存扫描，若发现邮件，则使用25端口与接收方的SMTP建立TCP连接，连接建立后接收方发送220 Service ready。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li><li></li></ul><hr><h3 id="WWW（WWW的概念与组成结构，HTTP协议）"><a href="#WWW（WWW的概念与组成结构，HTTP协议）" class="headerlink" title="WWW（WWW的概念与组成结构，HTTP协议）"></a>WWW（WWW的概念与组成结构，HTTP协议）</h3><hr><h3 id="P2P应用分发原理"><a href="#P2P应用分发原理" class="headerlink" title="P2P应用分发原理"></a>P2P应用分发原理</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自顶向下计算机网络-2-应用层&quot;&gt;&lt;a href=&quot;#自顶向下计算机网络-2-应用层&quot; class=&quot;headerlink&quot; title=&quot;自顶向下计算机网络 2    应用层&quot;&gt;&lt;/a&gt;自顶向下计算机网络 2    应用层&lt;/h2&gt;&lt;h3 id=&quot;客户-服务器应用模型与P2P应用模型&quot;&gt;&lt;a href=&quot;#客户-服务器应用模型与P2P应用模型&quot; class=&quot;headerlink&quot; title=&quot;客户/服务器应用模型与P2P应用模型&quot;&gt;&lt;/a&gt;客户/服务器应用模型与P2P应用模型&lt;/h3&gt;&lt;h4 id=&quot;客户-服务器应用模型&quot;&gt;&lt;a href=&quot;#客户-服务器应用模型&quot; class=&quot;headerlink&quot; title=&quot;客户/服务器应用模型&quot;&gt;&lt;/a&gt;客户/服务器应用模型&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yokeso.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ComNet</title>
    <link href="http://yokeso.top/2020/09/27/ComNet/"/>
    <id>http://yokeso.top/2020/09/27/ComNet/</id>
    <published>2020-09-27T12:07:35.000Z</published>
    <updated>2021-03-09T12:03:56.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络自顶向下方法"><a href="#计算机网络自顶向下方法" class="headerlink" title="计算机网络自顶向下方法"></a>计算机网络自顶向下方法</h1><h2 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h2><h3 id="计算机网络的基本概念，组成，功能与分类"><a href="#计算机网络的基本概念，组成，功能与分类" class="headerlink" title="计算机网络的基本概念，组成，功能与分类"></a>计算机网络的基本概念，组成，功能与分类</h3><h4 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h4><span id="more"></span><ul><li>利用通信设备和线路将分散在不同地点的具有独立功能的多个计算机系统互相连接起来，并按照网络协议进行数据通信实现资源共享的计算机集合</li><li>计算机网络就是一些互联的，自治的计算机集合。</li></ul><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><h5 id="1-从组成部分上看"><a href="#1-从组成部分上看" class="headerlink" title="1.从组成部分上看"></a>1.从组成部分上看</h5><p>一个完整的计算机网络由硬件 软件以及协议构成。</p><p><strong>硬件主要包括</strong>：主机(端系统)、通信链路(双绞线、光纤)、交换设备(路由器、交换机)、和通信处理机(网卡)构成</p><p><strong>软件主要包括</strong>：各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分主要处于应用层</p><p><strong>协议</strong>：协议是计算机网络的核心，协议总是指某一层的协议。准确的说是对等实体之间的通信定制的有关通信规则约定的集合。</p><h5 id="2-从工作方式上看"><a href="#2-从工作方式上看" class="headerlink" title="2.从工作方式上看"></a>2.从工作方式上看</h5><p>计算机网络分为<code>边缘部分</code>和<code>核心部分</code>。</p><p><strong>边缘部分</strong>：由所有连接到因特网上，供用户直接使用的主机组成。用来进行通信和资源共享</p><p><strong>核心部分</strong>：核心部分由大量的网络和连接这些网络的路由器构成，为边缘部分提供连通性和交换服务。</p><h5 id="3-从功能组成上看"><a href="#3-从功能组成上看" class="headerlink" title="3.从功能组成上看"></a>3.从功能组成上看</h5><p>计算机网络=资源子网+通信子网</p><p>通信子网：由传输介质通信设备和相应的网络协议组成。<br>资源子网：实现资源共享的设备及其软件的集合，为多个计算机为用户提供服务</p><h4 id="什么是因特网："><a href="#什么是因特网：" class="headerlink" title="什么是因特网："></a>什么是因特网：</h4><p>具体构成：遍及全世界数以百万的计算设备，网络的网络</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><h5 id="数据通信："><a href="#数据通信：" class="headerlink" title="数据通信："></a>数据通信：</h5><p>最基本重要的功能，实现联网计算机之间的各种信息传输，将分散在不同地理位置的计算机联系起来。进行统一的调配，控制和管理。</p><h5 id="资源共享："><a href="#资源共享：" class="headerlink" title="资源共享："></a>资源共享：</h5><p>资源共享可以是软件共享，数据共享也可以是硬件共享，使计算机网络中的设备互通有无，分工协作来提高硬件、软件。数据资源的利用率。</p><h5 id="分布式处理："><a href="#分布式处理：" class="headerlink" title="分布式处理："></a>分布式处理：</h5><p>计算机网络中某个计算机系统载荷过重时，可以将复杂的处理任务分配给网络中的其他计算机系统，利用空闲的资源提高整个系统的利用率。</p><h5 id="提高可靠性："><a href="#提高可靠性：" class="headerlink" title="提高可靠性："></a>提高可靠性：</h5><p>计算机网络中的各台计算机可以通过网络互为代替机。</p><h5 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h5><p>将工作任务均衡的分给计算机网络中的各台计算机。</p><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h4 id="1-按分布范围："><a href="#1-按分布范围：" class="headerlink" title="1.按分布范围："></a>1.按分布范围：</h4><p><strong>1）广域网（WAN）：</strong>广域网的任务是提供长距离通信，覆盖范围为 <code>几十千米</code>到<code>几千千米</code>是因特网的核心部分。</p><p><strong>2）城域网（MAN）：</strong>城域网的覆盖范围可以跨越几个街区或者整个城市，覆盖范围约为<code>5~50km</code>。大多采用以太网技术。</p><p><strong>3）局域网（LAN）：</strong>局域网通过微机或者工作站与高速链路相连，覆盖范围为<code>几十米到几千米</code>，在计算机配置数量上没有太多限制。</p><p><strong>4）个人区域网（PAN）：</strong>将个人的电子设备通过无线技术连接起来，范围覆盖直径通常为<code>10m</code>。</p><h4 id="2-按传输技术分："><a href="#2-按传输技术分：" class="headerlink" title="2.按传输技术分："></a>2.按传输技术分：</h4><p><strong>1）广播式网络：</strong>所有联网计算机共享一个公共通信通道，一台计算机发送，其他计算机都能收听到这个分组，接收到分组的计算机通过检查目的地址确定自己是否接受。</p><p><strong>2）点对点网络：</strong>每条物理线路连接一对计算机。如果两台主机中间没有专有线路就啊哟通过中间节点接收、存储和转发达到目的节点。（广域网基本属于点对点网络）。</p><h4 id="3-按拓扑结构分："><a href="#3-按拓扑结构分：" class="headerlink" title="3.按拓扑结构分："></a>3.按拓扑结构分：</h4><p>网络拓扑结构指的是由网中节点与通信线路之间的几何关系来表示的网络结构，主要指通信子网的拓扑结构。分为星型、总线型、环形和网络型等。</p><h4 id="4-按使用者分："><a href="#4-按使用者分：" class="headerlink" title="4.按使用者分："></a>4.按使用者分：</h4><p><strong>1）公用网（Public Network）</strong>指电信公司出资建造的大型网络，所有按规定交费的人都可以用。</p><p><strong>2）专用网（Private Network）</strong>指某个部门为了特殊的事物业务需要而建造的网络。不像本单位以外的人提供服务。</p><h4 id="5-按交换技术分："><a href="#5-按交换技术分：" class="headerlink" title="5.按交换技术分："></a>5.按交换技术分：</h4><h5 id="1）电路交换网络"><a href="#1）电路交换网络" class="headerlink" title="1）电路交换网络"></a>1）电路交换网络</h5><p>​    在源节点和目的节点之间建立一条专门用来传输数据的通路，包括建立连接、传输数据和断开连接三个部分。（电话）</p><p>​    <strong>特点：</strong>报文的比特流连续的从原点直达终点。</p><p>​    <strong>优点：</strong>数据直接传送，延时小，有序传输，适用范围广，控制简单。</p><p>​    <strong>缺点：</strong>建立时间长，线路利用率低，不能充分利用线路容量，不利于进行差错控制</p><h5 id="2）报文交换网络（存储-转发网络）"><a href="#2）报文交换网络（存储-转发网络）" class="headerlink" title="2）报文交换网络（存储-转发网络）"></a>2）报文交换网络（存储-转发网络）</h5><p>​    用户数据加上源地址，目的地址，校验码等辅助信息，封装成报文，存储转发传输到下一个节点，下一个节点全部存储转发之后再传输到下一个直到目的节点为止。每个报文可以单独选择传输的路径。</p><p>存储转发传输：在传输该分组的第一个bit之前必须接收到整个分组。</p><p>​    <strong>特点：</strong>整个报文先传输到相邻节点，相邻节点全部接受存储后查找转发表，再转发给下一节点。</p><p>​    <strong>优点：</strong>无需建立连接，可以较为充分的利用线路容量，可以实现不同链路之间不同速率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。</p><p>​    <strong>缺点：</strong>增大资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文顺序不乱。缓冲区难以管理。</p><h5 id="3）分组交换网络"><a href="#3）分组交换网络" class="headerlink" title="3）分组交换网络"></a>3）分组交换网络</h5><p>也称包交换网络，原理是将数据分为较短的固定大小块，在每个块中加入源地址，目的地址，校验码等辅助信息，封装成分组（包），以存储转发方式传输。</p><p>​    <strong>特点：</strong>单个分组传送到临近节点，存储后查找转发表并传送到下一节点直到传送到目的节点为止</p><p>​    <strong>优点：</strong>报文交换网络优点+ 缓冲易于管理，包平均时延更小。网络占用的平均缓冲区更少。易于标准化易于使用</p><p>​    现在主流网络基本都可视为分组网络。</p><p>​    <strong>缺点：</strong>存在传输时延，需要传输额外的信息量，采用数据报服务时可能出现失序，丢失分组或者重复分组。</p><h4 id="6-按传输介质分"><a href="#6-按传输介质分" class="headerlink" title="6.按传输介质分"></a>6.按传输介质分</h4><p>​    有线：双绞线网络，同轴电缆等。无线：蓝牙、微波、无线电等。</p><hr><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><p><strong>多路复用：</strong>在一条传输链路上同时建立多条连接分别传输数据。</p><p><strong>电路交换</strong>中的多路复用主要分为频分多路复用（Frequency-Division Multiplexing FDM）和时分多路复用。</p><p><strong>频分多路复用（FDM）：</strong> 按频率划分若干个频段，每个频段专用于一个连接</p><p><strong>时分多路复用（TDM）：</strong> 时间划分为固定区间的帧，每帧划为固定数量的时隙每个时隙专用于一个连接用于传输该链接的数据。</p><p><strong>波分多路复用 WDM(Wavelength Division Multiplexing)：</strong>是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器(亦称分波器或称去复用器，Demultiplexer)将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。这种在同一根光纤中同时传输两个或众多不同波长光信号的技术，称为波分复用。</p><p><strong>码分多路复用（code division multiplexing）：</strong>是指利用各路信号码型结构正交性而实现多路复用的通信方式</p><hr><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p><strong>速率</strong>：网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率</p><p><strong>带宽：</strong>频分多路复用中的一个频段的宽度</p><p><strong>时延：</strong>指数据（一个报文或者分组）</p><pre><code> **处理时延：**决定将分组导向何处，检查比特差错，决定输出链路</code></pre><p>​    <strong>排队时延：</strong>分组等待在链路上传输的排队时间。排队时延的长短取决于先期到达的正在排队等待的分组数量。</p><p>​    <strong>传输时延：</strong>将分组的所有比特推向链路所需要的时间：（比特分组长度/传输速率）</p><pre><code> **传播时延：**一个比特从链路的起点到下一节点（路由器）传播所需要的时间。（两台路由器之间额距离/传输速率）</code></pre><p>​    <strong>丢包</strong>：如果到达的分组发现一个满的队列，没有地方存储这个分组，那么路由器将丢弃这个分组，这个分组就会丢失。</p><p>​    <font color="red">注意传输时延和传播时延的区别</font></p><p><strong>流量强度（traffic intensity）：</strong>比特到达队列的平均速率（pkt/s）与比特从队列中推出的速率（bps）之比</p><p><em>设计系统时流量强度不能大于1</em></p><p><strong>时延带宽积：</strong>指发送的第一个比特即将到达终点时发送端发送了多少个比特。因此又称为以比特为单位的链路长度。即</p><script type="math/tex; mode=display">延带宽积=传播时延\times信道带宽</script><p><strong>吞吐量 （throughput）：</strong> 单位时间通过某个网络（信道或端口）的比特的数量，吞吐量受到网络带宽或者网络定额数据的限制。</p><p>​        （考虑从主机A到主机B发送一个大文件）</p><ul><li><p>平均吞吐量 ：主机B接收到的文件的速率（bps）</p></li><li><p>顺时吞吐量：若该文件为F比特，主机B接受到所有比特用了T秒，平均吞吐量为F/T bps</p></li></ul><hr><h2 id="计算机网络分层体系结构"><a href="#计算机网络分层体系结构" class="headerlink" title="计算机网络分层体系结构"></a>计算机网络分层体系结构</h2><p>我们把计算机网络的各层及其协议的集合称为网络的体系结构。也就是这个计算机网络及其完成功能的精确定义。计算机网络的体系结构通常有可分层性，将大系统分为若干较容易实现的系统层次。</p><p>在计算机的分层活动中，第n层活动的元素称为n层实体。具体来说实体指任何可发送或接收信息的硬件或软件过程。</p><p>计算机网络中的每一层通过在该层中执行某些动作或使用直接下层的服务来提供服务。例如：第n层提供的服务可能包括保温从网络的一边到另一边的可靠传送。这可能是通过使用第n+1层的边缘到到边缘的不可靠报文传送服务，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>因特网的协议栈由五个层次组成：物理层，链路层，网络层，运输层，应用层。</p><p>七层ISO OSI参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。</p><div class="table-container"><table><thead><tr><th>层名称</th><th>作用</th><th>信息分组</th></tr></thead><tbody><tr><td>应用层</td><td>网络应用程序以及他们的应用层协议存留的地方</td><td>报文</td></tr><tr><td>运输层</td><td>应用成熟端点之间传输应用层报文（TCP/UDP）</td><td>报文段</td></tr><tr><td>网络层</td><td>将数据报的网络层分组从一台主机移动到另一台主机</td><td>数据报</td></tr><tr><td>链路层</td><td>为了将分组从一个节点移动到另一个节点，网络层必须依靠链路层的服务</td><td>帧</td></tr><tr><td>物理层</td><td>将帧一个比特一个比特的移动到下一个节点</td></tr></tbody></table></div><hr><h2 id="计算机网络协议、接口、服务等概念"><a href="#计算机网络协议、接口、服务等概念" class="headerlink" title="计算机网络协议、接口、服务等概念"></a>计算机网络协议、接口、服务等概念</h2><h3 id="1-协议"><a href="#1-协议" class="headerlink" title="1.协议"></a>1.协议</h3><p>协议就是规则的集合。在网络中想要有条不紊的交换数据就要遵守事先约定好的规则。这些规则明确规定了所交换的数据的格式，以及有关的同步问题。这些为网络中数据交换而建立的准则标准或约定称为网络协议。<strong>它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的</strong>。不对等实体之间是没有协议的，</p><p>​        协议由语法，语义和同步三部分构成，其中，语法规定了传输数据的格式，语义规定了所要完成的功能。即需要发出何种控制信息，完成何种控制动作以及做出何种应答；同步规定了执行各种操作的条件，时序关系等，即事件实现顺序的详细说明。一个完整的协议通常应具有链路管理（建立，释放连接），差错控制，数据转换等功能。</p><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>接口是统一节点内相邻两层间交换信息的节点。是一个系统的内部规定。接口只能在相邻的层次之间定义，不能跨层定义。在典型的接口上，同一节点相邻的两层的实体通过服务访问点(Service Acceess Point SAP)进行交互。服务通过SAP提供给上层使用。第n层的SAP就是第n+1层可以访问第n层服务的地方。每个SAP都有一个能标识他的地址。SAP是一个抽象的概念。实际上是一个逻辑接口，与硬件接口不同。</p><h4 id="3-服务"><a href="#3-服务" class="headerlink" title="3.服务"></a>3.服务</h4><p>服务是指下层为紧邻的上层提供的功能调用。是垂直的。在对等实体的控制下，使得本层只能为上一层提供服务。但要实现本层协议还需要使用下一层所提供的服务。上层使用下层服务时要与下层交换服务原语。OSI将原语划分为四类：</p><ul><li>请求：由用户发往提供者，请求完成某项工作。</li><li>指示：由服务者发往用户，指示用户做某样事情。</li><li>响应：由用户发往服务提供者，表示对于指示的响应</li><li>证实：由服务提供者发往用户，表示对请求的证实。</li></ul><p>注意协议和服务概念上的区别，只有本层协议实现才能向上一层提供服务。本层的服务用户只能看到服务而不能看到协议。即下面的协议对上面的服务用户是透明的。其次，协议是水平的，面向对等实体，但是服务是垂直的，从下层向上层传播。</p><p>计算机网络提供的服务分为三类：</p><p><strong>（1）面向连接服务和无连接服务：</strong>面向连接需要建立连接，传输数据，链接释放三个步骤。而在无连接服务中，通信双方不需要建立连接，需要发送数据时可以直接进行发送。把目的地址的包发送到链路上，由系统选取路线发送。这种服务被描述为“尽最大努力交付”。并不保证通信的可靠性。</p><p><strong>（2）可靠服务和不可靠服务：</strong>可靠服务要求网络具有纠错，验错，应答机制。可以保证数据正确可靠的传输到目的地。不可靠服务只是尽力而为的传送，但不能保证数据正确可靠的传输到目的地。对于提供不可靠服务的网络，可靠性要通过用户程序来进行保障。用户发现不正确的信息后报告给发送者，由发送者采取措施，从而使不可靠的服务变为可靠的服务。</p><p><strong>（3）有应答服务和无应答服务：</strong>有应答服务需要在接收方接收到数据后向发送方给出响应应答。这个应答应该由传输系统实现而非用户实现。发送的应答既可以是肯定应答，也可以是否定应答。无应答服务是指接收方在接收到数据后不自动给出应答。若要给应答，则由高层实现。</p><hr><h2 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h2><h3 id="1-ISO-OSI模型"><a href="#1-ISO-OSI模型" class="headerlink" title="1.ISO/OSI模型"></a>1.ISO/OSI模型</h3><p>国际标准化组织（ISO）提出的网络体系结构模型，称为<code>开放系统互连参考模型（OSI）</code>OSI有七层，自上而下为应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。其中高三层称为资源子网，相当于计算机系统，完成数据处理的功能。低三层称为通信子网，是为了联网附加的通信设备。传输层在中间承上启下。</p><p>具体各层描述见王道17-19页</p><h3 id="2-TCP-IP模型"><a href="#2-TCP-IP模型" class="headerlink" title="2.TCP/IP模型"></a>2.TCP/IP模型</h3><p>模型从低到高依次为网络接口层（对应OSI的物理层和数据链路层），网际层，传输层和应用层（对应OSI的表示层和应用层）王道20-21页。。懒得打了，之后整理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络自顶向下方法&quot;&gt;&lt;a href=&quot;#计算机网络自顶向下方法&quot; class=&quot;headerlink&quot; title=&quot;计算机网络自顶向下方法&quot;&gt;&lt;/a&gt;计算机网络自顶向下方法&lt;/h1&gt;&lt;h2 id=&quot;一、计算机网络概述&quot;&gt;&lt;a href=&quot;#一、计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络概述&quot;&gt;&lt;/a&gt;一、计算机网络概述&lt;/h2&gt;&lt;h3 id=&quot;计算机网络的基本概念，组成，功能与分类&quot;&gt;&lt;a href=&quot;#计算机网络的基本概念，组成，功能与分类&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的基本概念，组成，功能与分类&quot;&gt;&lt;/a&gt;计算机网络的基本概念，组成，功能与分类&lt;/h3&gt;&lt;h4 id=&quot;计算机网络概念&quot;&gt;&lt;a href=&quot;#计算机网络概念&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概念&quot;&gt;&lt;/a&gt;计算机网络概念&lt;/h4&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CCFtab</title>
    <link href="http://yokeso.top/2020/08/28/CCFtab/"/>
    <id>http://yokeso.top/2020/08/28/CCFtab/</id>
    <published>2020-08-28T07:11:22.000Z</published>
    <updated>2021-03-09T12:04:52.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.常用注意要点</p><p>2.常用stl详解以及使用方式简述</p><span id="more"></span><ul><li>2.1 map</li><li>2.2 unordered_map</li><li>2.3 vector</li><li>2.4 queue</li><li>2.5 stack</li><li>2.6 set</li></ul><p>3.常用函数原型以及解释（随时添加）</p><p>​    <code>#includ&lt;ctype.h&gt;</code></p><p>​    <code>#include&lt;algorithm&gt;</code></p><p>​    <code>#include&lt;string&gt;</code></p><p>4.运用文件读写加快测试速度的代码</p><hr><h3 id="常用注意要点"><a href="#常用注意要点" class="headerlink" title="常用注意要点"></a>常用注意要点</h3><h4 id="1-include"><a href="#1-include" class="headerlink" title="1.#include"></a>1.#include<bits stdc++.h></bits></h4><p>万能头文件，包含了所有的已知常用库</p><h4 id="2-ios-sync-with-stdio-false"><a href="#2-ios-sync-with-stdio-false" class="headerlink" title="2.ios::sync_with_stdio(false);"></a>2.ios::sync_with_stdio(false);</h4><p>为了防止因为cin以及cout产生超时，将cin以及cout的缓冲区置为false</p><h4 id="3-cin-tie-0"><a href="#3-cin-tie-0" class="headerlink" title="3.cin.tie(0);"></a>3.cin.tie(0);</h4><p>接触cin与cout的绑定，加快执行效率</p><h3 id="常用stl详解以及使用方式"><a href="#常用stl详解以及使用方式" class="headerlink" title="常用stl详解以及使用方式"></a>常用stl详解以及使用方式</h3><p>stl中很常用的一个东西就是迭代器iterator，但是注意，iterator相当于是指向节点的指针，所以在整个stl发生改变或者删除时会出现迭代器产生空指针的情况，所以要牢记一点：不要用过期的iterator!!!</p><p>如果希望将一个结构体作为几种stl的键值时需要将struct中的某一个值作为键值对<code>&lt;</code>进行重载，具体方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">float</span> score;  </span><br><span class="line">    <span class="comment">//重载“&lt;”操作符，自定义排序规则  </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Info &amp;a) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//按score从大到小排列  </span></span><br><span class="line">        <span class="keyword">return</span> a.score&lt;score;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt; s;  </span><br><span class="line">......  </span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt;::iterator it;  </span><br></pre></td></tr></table></figure><h4 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h4><p>map是键-值对的组合，有以下的一些定义的方法：</p><ul><li><code>map&lt;k, v&gt; m;</code></li><li><code>map&lt;k, v&gt; m(m2);</code></li><li><code>map&lt;k, v&gt; m(b, e);</code></li></ul><p>上述第一种方法定义了一个名为m的空的map对象；第二种方法创建了m2的副本m；第三种方法创建了map对象m，并且存储迭代器b和e范围内的所有元素的副本。</p><p>map的value_type是存储元素的键以及值的pair类型，键为const。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>insert函数的插入方法主要有如下：</p><ul><li><code>m.insert(e)</code></li><li><code>m.insert(beg, end)</code></li><li><code>m.insert(iter, e)</code></li></ul><p>上述的e一个value_type类型的值。beg和end标记的是迭代器的开始和结束。</p><p>两种插入方法如下面的例子所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">                mp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">                mp.insert(<span class="built_in">make_pair</span>(i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;%d\n&quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map中可以利用结构体作为key值，但是要对小于号进行符号重载</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll x;</span><br><span class="line">ll y;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp; a) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;a.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>上述采用下标的方法读取map中元素时，若map中不存在该元素，则会在map容器中插入一个新的元素。</p><p>因此，若只是查找该元素是否存在，可以使用函数<code>count(k)</code>，该函数返回的是k出现的次数；若是想取得key对应的值，可以使用函数<code>find(k)</code>，该函数返回的是指向该元素的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it_find;</span><br><span class="line">it_find = mp.find(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (it_find != mp.end())&#123;</span><br><span class="line">      it_find-&gt;second = <span class="number">20</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;no!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find一定会使用迭代器，所以要学会对迭代器进行初始化</p><p><code>map&lt;int, int&gt;::iterator it_find;</code></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>从map中删除元素的函数是<code>erase()</code>，该函数有如下的三种形式：</p><ul><li><code>m.erase(k)</code></li><li><code>m.erase(p)</code></li><li><code>m.erase(b, e)</code></li></ul><p>第一种方法删除的是m中键为k的元素，返回的是删除的元素的个数；第二种方法删除的是迭代器p指向的元素，返回的是void；第三种方法删除的是迭代器b和迭代器e范围内的元素，返回void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">        mp.insert(<span class="built_in">make_pair</span>(i, i));</span><br><span class="line">   &#125;</span><br><span class="line">   mp.erase(<span class="number">0</span>);</span><br><span class="line">   mp.erase(mp.begin());</span><br></pre></td></tr></table></figure><h5 id="map常用函数"><a href="#map常用函数" class="headerlink" title="map常用函数"></a>map常用函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">mymap.insert(<span class="built_in">make_pair</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">mymap[<span class="string">&#x27;b&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">mymap.insert(<span class="built_in">pair</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>,<span class="number">300</span>));</span><br><span class="line"><span class="comment">//返回迭代器到开始(公共成员函数)</span></span><br><span class="line">mymap.begin() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回迭代器到末尾(公共成员函数)</span></span><br><span class="line">mymap.end()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回反向迭代器到反向开始(公共成员函数)</span></span><br><span class="line">mymap.rbegin() </span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回反向迭代器到反向端(公共成员函数)</span></span><br><span class="line">mymap.rend()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将const_iterator返回到开始(公共成员函数)    </span></span><br><span class="line">mymap.cbegin()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回const_iterator末尾(公共成员函数)</span></span><br><span class="line">mymap.cend()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const_reverse_iterator到反向开始(公共成员函数)    </span></span><br><span class="line">mymap.crbegin()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回const_reverse_iterator到reverse end(公共成员函数)</span></span><br><span class="line">mymap.crend()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回映射中是否为空    </span></span><br><span class="line">mymap.empty()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回映射容器可以容纳的元素的最大数量    </span></span><br><span class="line">mymap.max_size()</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问元素(公共成员函数)    </span></span><br><span class="line">mymap[<span class="string">&#x27;a&#x27;</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">//修改Key值的引用值    </span></span><br><span class="line">mymap.at(<span class="string">&#x27;a&#x27;</span>)=<span class="number">10</span>;        </span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入元素(公共成员函数)   </span></span><br><span class="line">mymap.insert()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除元素(公共成员函数)    </span></span><br><span class="line">mymap.erase()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//交换内容(公共成员函数)，将两个map中的内容完全交换   </span></span><br><span class="line">mymap.swap(mymap2)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//从map容器中删除所有元素，使容器的大小为0   </span></span><br><span class="line">mymap.clear()    </span><br></pre></td></tr></table></figure><h4 id="2-unordered-map"><a href="#2-unordered-map" class="headerlink" title="2.unordered_map"></a>2.unordered_map</h4><p>map内部实现的是一个黑红树，具有自动排序功能，因此map所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p><p>unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p><p>在有对于顺序要求的问题中，map会更高效，但是map的每个节点占用空间更大。</p><p>而对于查找问题来说，unordered_map会更加高效，因为哈希表查找速度非常快，但是哈希表建立比较消耗时间。</p><p>其操作与map相同。</p><h4 id="3-vector"><a href="#3-vector" class="headerlink" title="3.vector"></a>3.vector</h4><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器，</p><h5 id="vector初始化："><a href="#vector初始化：" class="headerlink" title="vector初始化："></a>vector初始化：</h5><p><strong>方式1.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式2.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义具有10个整型元素的向量，且给出的每个元素初值为1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式3.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用向量b给向量a赋值，a的值完全等价于b的值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式4</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;a(b.begin(),b.begin+<span class="number">3</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>方式5.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从数组中获得初值</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure><h5 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.assign(b.begin(),b.begin()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.assign(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.erase(a.begin()+<span class="number">1</span>,a.begin()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.push_back(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.insert(a.begin()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.insert(a.begin()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.insert(a.begin()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.capacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.resize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.resize(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.swap(b);</span><br><span class="line">下标访问是之恶能访问</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>通过下标访问时只能访问存在的元素，</p><h5 id="几个常用的算法"><a href="#几个常用的算法" class="headerlink" title="几个常用的算法"></a>几个常用的算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line"> sort(a.begin(),a.end());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line"> reverse(a.begin(),a.end());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span></span><br><span class="line"> copy(a.begin(),a.end(),b.begin()+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br><span class="line">  find(a.begin(),a.end(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="4-queue"><a href="#4-queue" class="headerlink" title="4.queue"></a>4.queue</h4><p>只能访问queue<T>容器适配器的第一个和最后一个元素，只能在容器的末尾添加新元素，只能从头部移除元素。</T></p><p>queue的基本操作如下图：</p><p><img src="/2020/08/28/CCFtab/queue.jpg" alt></p><p>queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;q;</span><br><span class="line"><span class="comment">//返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span></span><br><span class="line">q.front()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</span></span><br><span class="line">q.back()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。    </span></span><br><span class="line">q.push(<span class="keyword">const</span> T&amp; obj)：</span><br><span class="line"></span><br><span class="line"><span class="comment">//以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。    </span></span><br><span class="line">q.push(T&amp;&amp; obj)：</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 queue 中的第一个元素。</span></span><br><span class="line">q.pop()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 queue 中元素的个数。</span></span><br><span class="line">q.size()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 queue 中没有元素的话，返回 true。</span></span><br><span class="line">q.empty()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</span></span><br><span class="line">emplace()：</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</span></span><br><span class="line">swap(<span class="built_in">queue</span>&lt;T&gt; &amp;other_q)：</span><br></pre></td></tr></table></figure><h4 id="5-stack"><a href="#5-stack" class="headerlink" title="5.stack"></a>5.stack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s1;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//堆栈为空则返回真</span></span><br><span class="line">s1.empty() </span><br><span class="line"></span><br><span class="line"><span class="comment">//移除栈顶元素</span></span><br><span class="line">s1.pop() </span><br><span class="line"></span><br><span class="line"><span class="comment">//在栈顶增加元素a</span></span><br><span class="line">s1.push(a) </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈中元素数目</span></span><br><span class="line">s1.size() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line">s1.top() </span><br></pre></td></tr></table></figure><h4 id="6-set"><a href="#6-set" class="headerlink" title="6.set"></a>6.set</h4><p>set容器是用来存储同一数据类型的数据类型，并能从一个数据集合取出数据，在set中每个元素的值都唯一，系统能根据元素的值自动排序，应注意set中的每个值都不能直接被改变。与map相同，set的内部同样实现的是黑红树。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key_value插入到set中 ，返回值是pair&lt;set&lt;int&gt;::iterator,bool&gt;，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置。</span></span><br><span class="line">insert(key_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将定位器first到second之间的元素插入到set中，返回值是void.</span></span><br><span class="line">inset(first,second);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器的第一个元素</span></span><br><span class="line">begin()     　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器的最后一个元素</span></span><br><span class="line">end() 　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除set容器中的所有的元素</span></span><br><span class="line">clear()   　　     </span><br><span class="line"></span><br><span class="line"><span class="comment">//判断set容器是否为空</span></span><br><span class="line">empty() 　　　</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回set容器可能包含的元素最大个数</span></span><br><span class="line">max_size() 　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前set容器中的元素个数</span></span><br><span class="line">size() 　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的值和end()相同</span></span><br><span class="line">rbegin　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的值和rbegin()相同</span></span><br><span class="line">rend()　　　　 </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一对定位器，分别表示第一个大于或等于给定关键值的元素和 第一个大于给定关键值的元素，这个返回值是一个pair类型    </span></span><br><span class="line">equal_range() </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定位器iterator指向的值</span></span><br><span class="line">erase(iterator)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定位器first和second之间的值</span></span><br><span class="line">erase(first,second)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除键值key_value的值</span></span><br><span class="line">erase(key_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给定值值得定位器，如果没找到则返回end()。</span></span><br><span class="line">find() </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个大于等于key_value的定位器</span></span><br><span class="line">lower_bound(key_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最后一个大于key_value的定位器</span></span><br><span class="line">upper_bound(key_value)</span><br></pre></td></tr></table></figure><h3 id="常用函数原型以及解释"><a href="#常用函数原型以及解释" class="headerlink" title="常用函数原型以及解释"></a>常用函数原型以及解释</h3><p>以下函数以及头文件均包含在bits/stdc++.h中，无需特殊声明。</p><h4 id="include-lt-ctype-h-gt"><a href="#include-lt-ctype-h-gt" class="headerlink" title="#include&lt;ctype.h&gt;"></a><code>#include&lt;ctype.h&gt;</code></h4><p>这几个都是返回非0表示正确，返回0表示错误</p><p>1.<code>isalnum(int c);</code></p><p>​    用来判断一个字符是否是字母或者十进制数字。其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>2.<code>islower(int c);</code></p><p>​    用来检测一个字符是不是小写字母，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>3.<code>isalpha(int c);</code></p><p>​    用来检测一个字符是不是字母，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>4.<code>isdigit(int c);</code></p><p>​    用来检测一个字符是不是数字，其中c表示要检测的字符，（被转化为int类型，可以直接输入char）也可以是EOF </p><p>5.<code>isblank(int c);</code></p><p>​    用来检测一个字符是不是空白符，其中c表示要检测的字符，这个函数仅检测<code>空格‘’</code>,<code>水平制表符‘/t’</code>，如果想检测更多的话需要用函数<code>isspace()</code>;</p><p>6.<code>iscntrl(int c);</code></p><p>​    iscntrl() 函数用来检测一个字符是否是控制字符（Control Character）。控制字符的范围是<code>0x00 (NUL) ~ 0x1f (US)</code>，再加上一个<code>0x7f (DEL)</code>字符。</p><p>7.<code>isgraph(int c);</code></p><p>​    isgraph() 函数用来检测一个字符是否是图形字符。</p><p>8.<code>ispunct(int c);</code></p><p>​    ispunct() 函数用来检测一个字符是否是标点符号。</p><p>9.<code>isupper ( int c );</code></p><p>​    isupper() 函数用来检测一个字符是否是大写字母。</p><p>10.<code>isxdigit ( int c );</code></p><p>​    isxdigit() 用来检测一个字符是否是十六进制数字。</p><p>11.<code>tolower ( int c );</code></p><p>​    tolower() 函数用来将大写字母转换为小写字母。</p><p>12.toupper ( int c );</p><p>​    toupper() 函数用来将小写字母转换为大写字母。</p><h4 id="include-lt-algorithm-gt"><a href="#include-lt-algorithm-gt" class="headerlink" title="#include&lt;algorithm&gt;"></a><code>#include&lt;algorithm&gt;</code></h4><p>1.<code>reverse(it,it2)</code></p><p>​    <strong>将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)范围内的元素进行反转。string也可以。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]= &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;; </span><br><span class="line">reverse(a, a+<span class="number">4</span>);<span class="comment">//a[0]~a[3]反转</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">reverse(str.begin()+<span class="number">2</span>, str.begin()+<span class="number">6</span>);<span class="comment">//对a[2]~a[5]逆转*左闭右开* </span></span><br></pre></td></tr></table></figure><p>2.<code>sort(a,a+k,cmp)</code></p><p>​    <strong>sort(首元素地址(必填), 尾元素地址的下一个地址(必填), 比较函数(非必填));不填写时默认为递增序列。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//将a[0]~a[3]从小到大排序</span></span><br><span class="line">sort(a, a+<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cmp函数用法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;  <span class="comment">//可以理解为当a&gt;b时把a放在b前面 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="#include&lt;string&gt;"></a><code>#include&lt;string&gt;</code></h4><p>1.<code>void *memchr(const void *str, int c, size_t n)</code></p><p>在参数str指向的字符串的前n个字节中搜索第一次出现字符c（无符号字符）的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> ch = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">   <span class="keyword">char</span> *ret;</span><br><span class="line"> </span><br><span class="line">   ret = (<span class="keyword">char</span>*)<span class="built_in">memchr</span>(str, ch, <span class="built_in">strlen</span>(str));</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;|%c| 之后的字符串是 - |%s|\n&quot;</span>, ch, ret);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>int memcmp(const void*str1,const void*str2,size_t n);</code></p><p>将str1和str2的前n个字节进行比较</p><p>字符串相等返回0，字符串前大于后返回1否则返回0</p><p>3.<code>void *memcpy(void *dest, const void *src, size_t n)</code><br>从 src 复制 n 个字符到 dest。</p><p>4.<code>void *memmove(void *dest, const void *src, size_t n)</code><br>另一个用于从 src 复制 n 个字符到 dest 的函数。</p><p>5.<code>void *memset(void *str, int c, size_t n)</code><br>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</p><p>6.<code>char *strcat(char *dest, const char *src)</code><br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</p><p>该函数返回一个指向最终的目标字符串 dest 的指针。</p><p>7.<code>char *strncat(char *dest, const char *src, size_t n)</code><br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</p><p>8.<code>char *strchr(const char *str, int c)</code><br>在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</p><p>9.<code>int strcmp(const char *str1, const char *str2)</code><br>把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</p><p>该函数返回值如下：</p><ul><li>如果返回值小于 0，则表示 str1 小于 str2。</li><li>如果返回值大于 0，则表示 str1 大于 str2。</li><li>如果返回值等于 0，则表示 str1 等于 str2。</li></ul><p>10.<code>int strncmp(const char *str1, const char *str2, size_t n)</code><br>把 str1 和 str2 进行比较，最多比较前 n 个字节。</p><p>11.<code>int strcoll(const char *str1, const char *str2)</code><br>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</p><p>12.<code>char *strcpy(char *dest, const char *src)</code></p><p>把 src 所指向的字符串复制到 dest。</p><p>13.<code>char *strncpy(char *dest, const char *src, size_t n)</code><br>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</p><p>14.<code>size_t strcspn(const char *str1, const char *str2)</code><br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</p><p>该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。</p><p>以匹配到第一个字符为准。</p><p>15.<code>char *strerror(int errnum)</code><br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror生成的错误字符串取决于开发平台和编译器。</p><p>16.<code>size_t strlen(const char *str)</code><br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p><p>17.<code>char *strpbrk(const char *str1, const char *str2)</code><br>检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。</p><p>该函数返回 str1 中第一个匹配字符串 str2 中字符的字符数，如果未找到字符则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str1[] = <span class="string">&quot;abcde2fghi3jk4l&quot;</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> str2[] = <span class="string">&quot;34&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> *ret;</span><br><span class="line"> </span><br><span class="line">   ret = <span class="built_in">strpbrk</span>(str1, str2);</span><br><span class="line">   <span class="keyword">if</span>(ret) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;第一个匹配的字符是： %c\n&quot;</span>, *ret);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;未找到字符&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//返回3</span></span><br></pre></td></tr></table></figure><p>18.<code>char *strrchr(const char *str, int c)</code><br>在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</p><p>19.<code>size_t strspn(const char *str1, const char *str2)</code><br>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</p><p>20.<code>char *strstr(const char *haystack, const char *needle)</code><br>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</p><p>21.<code>char *strtok(char *str, const char *delim)</code><br>分解字符串 str 为一组字符串，delim 为分隔符。</p><p>22.<code>size_t strxfrm(char *dest, const char *src, size_t n)</code><br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</p><h3 id="运用文件读写加快测试速度的代码"><a href="#运用文件读写加快测试速度的代码" class="headerlink" title="运用文件读写加快测试速度的代码"></a>运用文件读写加快测试速度的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin)==NULL)</span></span><br><span class="line"><span class="comment">    fprintf(stderr,&quot;errorredirecting stdout\n&quot;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建.cpp文件的地方创建in.txt文件和out.txt文件</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;1.常用注意要点&lt;/p&gt;
&lt;p&gt;2.常用stl详解以及使用方式简述&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="-CCF" scheme="http://yokeso.top/tags/CCF/"/>
    
  </entry>
  
  <entry>
    <title>DSPtopic</title>
    <link href="http://yokeso.top/2020/08/25/DSPtopic/"/>
    <id>http://yokeso.top/2020/08/25/DSPtopic/</id>
    <published>2020-08-25T06:52:08.000Z</published>
    <updated>2021-03-09T12:05:16.534Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="/2020/08/25/DSPtopic/3.3.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.3.1-3.png" style="zoom:108%;"></p><p><img src="/2020/08/25/DSPtopic/3.3.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/4.1.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/4.1.1-2.png" style="zoom:80%;"></p><p><img src="/2020/08/25/DSPtopic/5.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.4.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2-3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1-3.png&quot; style=&quot;zoom:108
      
    
    </summary>
    
    
    
      <category term="-DSP -2020 -lunboli" scheme="http://yokeso.top/tags/DSP-2020-lunboli/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-4</title>
    <link href="http://yokeso.top/2020/08/18/OS-ch-4/"/>
    <id>http://yokeso.top/2020/08/18/OS-ch-4/</id>
    <published>2020-08-18T00:13:09.000Z</published>
    <updated>2021-03-09T13:04:51.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p>用户程序的主要处理阶段</p><span id="more"></span><p>连续分配方式</p><p>离散分配方式</p><p>虚拟存储器的基本特征</p><h3 id="存储器的管理功能"><a href="#存储器的管理功能" class="headerlink" title="存储器的管理功能"></a>存储器的管理功能</h3><ol><li>存储分配和回收（主要内容，讨论算法和相应的数据结构）</li><li>地址变换（文件生成的连接技术，加载的重定位技术，运行时的地址变换）</li><li>存储共享和保护（代码数据的共享，对地址空间的访问权限）</li><li>存储器扩充（存储器的逻辑组织和物理知识）<ol><li>由应用程序控制：覆盖</li><li>由OS控制：交换（整个进程）请求调入和预调入（部分进程）</li></ol></li></ol><h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><ul><li><p>逻辑地址，也称虚地址，相对地址</p><ul><li>由CPU执行指令时生成的地址（本条指令所需数据的地址或下一条指令地址）</li></ul></li><li><p>物理地址，也称绝对地址，实地址</p><ul><li>实际的内存单元地址</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-1.jpg" alt></p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p><img src="/2020/08/18/OS-ch-4/4.1-2.jpg" alt></p><h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><ul><li>将逻辑地址和物理地址分离，是内存管理的核心</li><li><p>逻辑地址与物理地址相同</p><ul><li>地址映像工作在编译阶段或加载阶段完成</li></ul></li><li><p>重定位</p><ul><li>进程的逻辑地址空间不同于物理地址空间，所以存储管理模块要解决逻辑地址到物理地址的映射问题。</li><li>也称地址映射，地址映像</li><li>在执行阶段完成</li></ul></li></ul><h3 id="4-1程序的装入和链接"><a href="#4-1程序的装入和链接" class="headerlink" title="4.1程序的装入和链接"></a>4.1程序的装入和链接</h3><p>编程可得到执行文件的步骤：编译（obj文件），链接（EXE文件或动态链接库dll），装入</p><p><img src="/2020/08/18/OS-ch-4/4.1-3.jpg" alt></p><h4 id="4-1-1-程序的装入"><a href="#4-1-1-程序的装入" class="headerlink" title="4.1-1 程序的装入"></a>4.1-1 程序的装入</h4><ol><li><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5></li></ol><ul><li>编译程序知道程序在内存中的地址，并产生绝对地址的目标代码</li><li>绝对装入模块装入时直接定位在上述内存地址，不修改程序和地址的数据</li><li>优点：装入过程简单，</li><li>缺点：过于依赖硬件结构，不适用于多道程序系统</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-4.jpg" alt></p><h5 id="2-可重定位装入"><a href="#2-可重定位装入" class="headerlink" title="2.可重定位装入"></a>2.可重定位装入</h5><ul><li>在多道程序下，目标的起始地址通常从0开始，程序其他地址也相对于起始地址计算，装入时可采用可重定位装入</li><li>在可执行文件中，列出需要重定位的地址单元和相对地址值（表）最后根据定位的内存地址修改重定位地址项，添加偏移量。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-5.jpg" alt></p><p>优点</p><ul><li>不需要硬件支持，可以装入有限多道程序</li></ul><p>缺点：</p><ul><li>一个程序需要连续的地址空间，程序装入后不能移动，不易共享</li></ul><p>地址变换是由装入程序在装入目标模块时一次完成，装入后内存不能移动，故称为静态重定位。</p><h5 id="3-动态运行时装入"><a href="#3-动态运行时装入" class="headerlink" title="3.动态运行时装入"></a>3.动态运行时装入</h5><ul><li>程序开始执行时未全部装入内存，而是部分装入，运行时需要什么模块再装什么模块</li><li>程序装入内存后不直接将相对地址转换为直接地址，等到真正执行是再转换，即动态重定位</li><li><font color="red">装入内存的所有地址都是相对的</font></li></ul><p>优点：</p><ul><li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利于实现共享。</li><li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）</li></ul><p>缺点：</p><ul><li>需要硬件支持（通常是CPU），OS实现较复杂－－是虚拟存储的基础</li></ul><h4 id="4-1-2-程序的链接"><a href="#4-1-2-程序的链接" class="headerlink" title="4.1.2 程序的链接"></a>4.1.2 程序的链接</h4><p>根据链接时间不同，分为三种</p><p>静态链接</p><ul><li>在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。要解决两个问题：<ul><li>修改相对地址</li><li>变换外部调用符号</li></ul></li><li>对多用户、多任务系统显然有冗余，比如多个用户调用了sin(x)，则每个目标代码中都有这部分代码，装入到内存则也都有这部分代码。</li></ul><p>装入时动态链接</p><ul><li>源程序编译得到的目标模块是在装入内存时，边装入边链接的，即在装入一个目标模块时，若发现一个外部模块调用事件，装入程序去找出相应的外部目标模块，并将它装入内存，同时修改相对地址。</li><li>优点<ul><li>共享：多个进程可以共用一个目标模块，节省内存，减少文件交换。</li><li>便于修改和更新。各目标模块是分开存放的，便于修改。</li></ul></li></ul><p>运行时动态链接</p><ul><li>应用程序运行时，每次运行的模块可能不同。但事先又无法知道，运行时动态链接是将某些模块的链接推迟到执行时。即，执行时发现调用的模块未被装入，由OS找到该模块并装入，并将其链接到调用者模块上。</li><li>优点：<ul><li>部分装入：一个进程只将与当前操作相对应的DLL装入内存。</li><li>便于局部代码修改：即便于代码升级和代码重用；只要函数的接口参数（输入和输出）不变，则修改函数及其DLL，无需对可执行文件重新编译或链接。</li><li>便于适应运行环境：调用不同的DLL，就可以适应多种使用环境和提供不同功能。如：不同的显示卡只需厂商为其提供特定的DLL，而OS和应用程序不必修改。</li></ul></li><li>缺点：<ul><li>链接开销：增加了程序执行时的链接开销；</li><li>管理开销：程序由多个文件组成，增加管理复杂度。 </li></ul></li></ul><h5 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h5><p><img src="/2020/08/18/OS-ch-4/4.1-6.jpg" alt></p><h5 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h5><p>在<font color="red">用户模式</font>中验证产生的地址，如果发现不好的地址，中断进入内核</p><h3 id="4-2-连续分配存储管理方式"><a href="#4-2-连续分配存储管理方式" class="headerlink" title="4.2 连续分配存储管理方式"></a>4.2 连续分配存储管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul><li>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。未采取存储保护措施。</li><li>最简单，适用于单用户、单任务的OS。CP/M和MS-DOS </li><li>优点：<ul><li>易于管理。</li></ul></li><li>缺点：<ul><li>对要求内存空间少的程序，造成内存浪费；</li><li>程序全部装入，很少使用的程序部分也占用内存固定分区分配</li></ul></li></ul><h5 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h5><p>为了支持多道程序系统和分时系统，支持多个程序并发执行</p><p>吧内存分为大小相等或不等的区，操作系统占用一个，其余给应用程序，应用程序占用一个或几个</p><h5 id="内碎片和外碎片"><a href="#内碎片和外碎片" class="headerlink" title="内碎片和外碎片"></a>内碎片和外碎片</h5><p>内：占用分区内未被利用的空间</p><p>外：占用分区之间难以利用的小空闲分区</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul><li>最简单的一种运行多道程序的存储管理方式</li><li>把内存划分为若干个固定大小的连续分区，每个分区只装入一个作业。</li><li>划分分区的方法<ul><li>分区大小相等：只适合于多个相同进程的并发执行（处理多个类型相同的对象）。</li><li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-1.jpg" alt></p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><img src="/2020/08/18/OS-ch-4/4.2-2.jpg" alt></p><ul><li><p>动态分区分配是指OS根据进程的实际需要为各进程分配连续的物理内存。</p><ul><li>分区分配中的数据结构</li><li>为了管理内存空闲分区建立了空闲分区表或空闲分区链表。</li><li>表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。  </li><li>分区表中，表项数目随着内存的分配和释放而动态改变，可以规定最大表项数目。</li><li>分区表可以划分为两个表格：空闲分区表和占用分区表。从而减小每个表格长度。空闲分区表中按不同分配算法对表项排序。</li></ul></li><li><p>分区分配算法：</p><ul><li>某个新作业装入内存，需寻找一个空闲分区，其大小需大于或等于进程的要求。</li><li>若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。</li></ul></li></ul><h5 id="首次适应算法："><a href="#首次适应算法：" class="headerlink" title="首次适应算法："></a>首次适应算法：</h5><ul><li>按分区的先后次序，从头查找，找到符合要求的第一个分区。</li><li>该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。</li><li>但随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。</li></ul><h5 id="循环适应算法："><a href="#循环适应算法：" class="headerlink" title="循环适应算法："></a>循环适应算法：</h5><ul><li>按分区的先后次序，从上次分配的分区的下一个位置开始查找（到最后一个分区时再回到开头），找到符合要求的第一个分区。</li><li>实现算法，要设置起始查询指针。</li><li>该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。</li></ul><h5 id="最佳适应法-best-fit"><a href="#最佳适应法-best-fit" class="headerlink" title="最佳适应法(best-fit)"></a>最佳适应法(best-fit)</h5><ul><li>找到其大小与要求相差最小的空闲分区。</li><li>为了加速寻找，该算法要求空闲分区表将空闲分区按容量由小到大排序。</li><li>从个别来看，外碎片较小，但从整体来看，会形成较多外碎片。较大的空闲分区可以被保留。 </li></ul><h5 id="最坏适应法-worst-fit"><a href="#最坏适应法-worst-fit" class="headerlink" title="最坏适应法(worst-fit)"></a>最坏适应法(worst-fit)</h5><ul><li>找到最大的空闲分区。</li><li>算法要求空闲分区表将空闲分区按容量由大到小排序。</li><li>基本不留下小空闲分区，但较大的空闲分区不被保留。 </li></ul><h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><ul><li>又称分类搜索法。</li><li>将空闲分区根据容量大小分类，每类分区容量相同。为每类分区</li><li>设立一个空闲分区链表。系统中设立一张管理索引表，每个表项</li><li>记录的是每类空闲分区链表的表头。</li><li>优点：<ul><li>查找空闲分区效率高。</li><li>能保留大分区。</li></ul></li><li>缺点：<ul><li>回收分区时，系统开销大。</li><li>空闲分区划分越细，浪费则越严重。</li></ul></li></ul><h4 id="动态重定位分区分配"><a href="#动态重定位分区分配" class="headerlink" title="动态重定位分区分配"></a>动态重定位分区分配</h4><h4 id="4-2-3-动态分区分配"><a href="#4-2-3-动态分区分配" class="headerlink" title="4.2.3 动态分区分配"></a>4.2.3 动态分区分配</h4><p>分区分配操作 </p><ul><li>分配内存<ul><li>利用某种分配算法，从空闲分区表（链）中找到所需大小的分区</li></ul></li><li>回收内存，有以下四种情况：<ul><li>与前一个空闲分区相邻</li><li>与后一个空闲分区相邻</li><li>与前、后空闲分区都相邻</li><li>不与任何空闲分区相邻</li></ul></li></ul><h4 id="4-2-4-伙伴系统"><a href="#4-2-4-伙伴系统" class="headerlink" title="4.2.4 伙伴系统"></a>4.2.4 伙伴系统</h4><p>伙伴系统方式是动态分区分配和固定分区分配的一种折中方案。</p><p>伙伴系统规定，分区分配大小都是$2^k$ k为整数，1&lt;=k&lt;=m 2^m可以是整个内存的大小。系统中也要建立一个索引管理表，指明每个链表表头。</p><h5 id="分区分配方法："><a href="#分区分配方法：" class="headerlink" title="分区分配方法："></a>分区分配方法：</h5><ul><li>开始时，整个分区是2m，在系统运行过程中，由于不断划分，可能会形成若干不连续的空闲分区，将它们分类，每一类具有相同大小，且每类建立一个空闲分区双向链表，系统中有若干个双向链表。</li><li>当需要为进程分配大小为n的区块时，首先计算一个i，使2i-1≤n ≤2i，然后在大小为2i的空闲分区链表中查找。</li></ul><h5 id="分区回收："><a href="#分区回收：" class="headerlink" title="分区回收："></a>分区回收：</h5><ul><li>若回收大小为2i的分区，若有伙伴分区，则合并为2i+1的分区，进而可能需要合并为2i+2的分区……</li><li>算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-3.jpg" alt></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>快速搜索合并</li><li>低外部碎片</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>内部碎片。</li><li>因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。 </li></ul><h4 id="4-2-5-可重定位分区分配"><a href="#4-2-5-可重定位分区分配" class="headerlink" title="4.2.5 可重定位分区分配"></a>4.2.5 可重定位分区分配</h4><p>当内存驻留多个进程时，分配一个区后大部分情况下都是有剩余零头的，因此在一个新作业到达时，就有可能零头分区的总和超过新作业要求的分区，但每一个空闲分区的容量都不够。</p><p>1.紧凑</p><ul><li><p>将各个占用分区向内存一段移动，使各个空闲分区聚集在另一端，合并为一个较大的空闲分区。</p></li><li><p>对占用分区进行内存数据搬移占用CPU时间，如果对占用分区中的程序进行浮动，则其重定位需要硬件支持。</p></li><li><font color="red">何时执行</font>：每个分区释放后或内存找不到满足条件的空闲分区。</li></ul><h5 id="动态重定位分区分配算法"><a href="#动态重定位分区分配算法" class="headerlink" title="动态重定位分区分配算法"></a>动态重定位分区分配算法</h5><p><img src="/2020/08/18/OS-ch-4/4.2-4.jpg" alt></p><h4 id="4-2-6-覆盖"><a href="#4-2-6-覆盖" class="headerlink" title="4.2.6 覆盖"></a>4.2.6 覆盖</h4><p>为了在较小的可用内存中运行较大的程序</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>程序必要部分常驻内存</li><li>不常用功能用其余模块实现，不使用时放外存，使用时放内存</li><li>不存在调用关系的模块不封装到内存，从而实现互相覆盖。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>程序员需要给程序分块并确定覆盖关系，增加复杂度</li><li>进程在执行过程中要从外存装入，速度慢，用时间换空间</li></ul><h4 id="4-2-7-对换"><a href="#4-2-7-对换" class="headerlink" title="4.2.7 对换"></a>4.2.7 对换</h4><ul><li>内存中有进程处于堵塞态，另一方面有就绪进程在外存等待</li><li>对换将暂时不能执行的程序或数据送到外存中，获得空闲内存来装入具备运行条件的进程或所需要的程序和数据</li><li><p>进程暂时不能执行原因</p><ul><li>阻塞态</li><li>低优先级</li></ul></li><li><p>交换单位为整个进程的地址空间</p></li><li><p>小型系统中与可重定位分区分配存储管理配合使用，称作roll in/roll out</p></li><li><p>加快进程换入，换出速度，因此采用连续分配，较少考虑碎片问题</p></li><li>建立磁盘的对换区，内存有空时找出就绪且换出时间最久的进程换入内存</li><li><p>优点</p><ul><li>增加并行进程数目，给用户适当响应时间，提高吞吐率</li></ul></li><li><p>缺点</p><ul><li>对换入换出的控制增加处理机开销，没有考虑执行过程中地址访问的统计特性</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-5.jpg" alt></p><h3 id="4-3-基本分页存储管理方式"><a href="#4-3-基本分页存储管理方式" class="headerlink" title="4.3 基本分页存储管理方式"></a>4.3 基本分页存储管理方式</h3><h4 id="连续分配问题"><a href="#连续分配问题" class="headerlink" title="连续分配问题"></a>连续分配问题</h4><ul><li>形成外碎片和内碎片</li><li>近凑带来开销</li></ul><h4 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h4><ul><li>基本单位是页：分页存储管理</li><li>是段：分段存储管理</li><li>分页存储管理不支持虚存技术，要求吧整个作业装入内存才能运行。</li></ul><h4 id="在页式管理中："><a href="#在页式管理中：" class="headerlink" title="在页式管理中："></a>在页式管理中：</h4><ul><li>内存化为固定大小的页框，也叫页帧，物理页框</li><li>进程的逻辑地址页分为同样大小的页，程序加载时需要分配所需全部页，这些页不必连续</li><li>固定：计算机系统的内存容量固定，一个页容量也是固定的</li></ul><h4 id="进程装载："><a href="#进程装载：" class="headerlink" title="进程装载："></a>进程装载：</h4><ul><li><p>装入进程时，找空闲页框，OS将页框分配给装入过程，每个页占用一个页框，进程占用的所有页框不要求连续</p></li><li><p>要解决逻辑地址到物理地址的映像需要硬件支持。</p></li></ul><h4 id="基本分页管理中的数据结构"><a href="#基本分页管理中的数据结构" class="headerlink" title="基本分页管理中的数据结构"></a>基本分页管理中的数据结构</h4><ul><li>进程页表：每个进程有一个页表，描述该进程的每个逻辑页占用的物理页框号。</li><li>物理页面表：整个系统有一个物理页面表，描述所有物理页框的分配使用状况。数据结构：位示图，空闲页面链表；</li><li>请求表：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换；</li><li>请求表也可以结合到各进程的PCB里，此时在PCB中记录本进程页表所在的物理页框号。上下文切换时，由OS将其加载到页表寄存器中。</li></ul><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p><img src="/2020/08/18/OS-ch-4/4.3-1.jpg" alt></p><h4 id="页面大小的选择"><a href="#页面大小的选择" class="headerlink" title="页面大小的选择"></a>页面大小的选择</h4><ul><li>和目前计算机的物理内存大小有关：2n。</li><li>较小的页面，减小内碎片，但加大页表的长度，从而形成新的开销并增加换入、换出的开销；</li><li>较大的页面，减小页表的长度，加大内碎片；管理开销小，交换时对外存I/O效率高。</li><li>两者的折中。</li></ul><h4 id="页式管理的优缺点"><a href="#页式管理的优缺点" class="headerlink" title="页式管理的优缺点"></a>页式管理的优缺点</h4><p>优点：</p><ul><li>没有外碎片，每个内碎片不超过页大小。</li><li>一个程序不必连续存放。便于改变程序占用空间的大小（主要指随着程序运行而动态生成的数据增多，要求地址空间相应增大，通常由系统调用完成而不是操作系统自动完成）。</li></ul><p>缺点：</p><ul><li>程序全部装入内存。</li></ul><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>逻辑上连续的目标程序在物理内存中已经不能保证连续存放，支持页式管理的机器硬件上都有一套地址变换机构完成逻辑地址到物理地址的变换。<br>逻辑地址分为两部分：逻辑页号，页内偏移地址；<br>通过查进程页表，得物理页号，从而形成物理地址。</p><h4 id="4-3-2快表"><a href="#4-3-2快表" class="headerlink" title="4.3.2快表"></a>4.3.2快表</h4><h4 id="4-3-3-两级和多级页表"><a href="#4-3-3-两级和多级页表" class="headerlink" title="4.3.3 两级和多级页表"></a>4.3.3 两级和多级页表</h4><h3 id="4-4-基本分段存储管理"><a href="#4-4-基本分段存储管理" class="headerlink" title="4.4 基本分段存储管理"></a>4.4 基本分段存储管理</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理&lt;/h2&gt;&lt;p&gt;用户程序的主要处理阶段&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="-OS -操作系统 -ch3" scheme="http://yokeso.top/tags/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-ch3/"/>
    
  </entry>
  
</feed>
