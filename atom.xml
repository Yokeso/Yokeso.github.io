<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yokeso.top/"/>
  <updated>2020-08-25T07:17:20.452Z</updated>
  <id>http://yokeso.top/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DSPtopic</title>
    <link href="http://yokeso.top/2020/08/25/DSPtopic/"/>
    <id>http://yokeso.top/2020/08/25/DSPtopic/</id>
    <published>2020-08-25T06:52:08.000Z</published>
    <updated>2020-08-25T07:17:20.452Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/08/25/DSPtopic/3.3.1.png" alt></p><img src="/2020/08/25/DSPtopic/3.3.1-3.png" style="zoom:108%;"><p><img src="/2020/08/25/DSPtopic/3.3.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/3.4.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/4.1.1.png" alt></p><img src="/2020/08/25/DSPtopic/4.1.1-2.png" style="zoom:80%;"><p><img src="/2020/08/25/DSPtopic/5.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7.png" alt></p><p><img src="/2020/08/25/DSPtopic/5.7-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.4.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/6.5-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-1.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.1-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.2-3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.3-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-2.png" alt></p><p><img src="/2020/08/25/DSPtopic/7.5-3.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1.png&quot; alt&gt;&lt;/p&gt;
&lt;img src=&quot;/2020/08/25/DSPtopic/3.3.1-3.png&quot; style=&quot;zoom:108%;&quot;&gt;

&lt;p&gt;&lt;img src=&quot;/2020/08
      
    
    </summary>
    
    
    
      <category term="-DSP -2020 -lunboli" scheme="http://yokeso.top/tags/DSP-2020-lunboli/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-4</title>
    <link href="http://yokeso.top/2020/08/18/OS-ch-4/"/>
    <id>http://yokeso.top/2020/08/18/OS-ch-4/</id>
    <published>2020-08-18T00:13:09.000Z</published>
    <updated>2020-08-18T14:22:23.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p>用户程序的主要处理阶段</p><p>连续分配方式</p><p>离散分配方式</p><p>虚拟存储器的基本特征</p><h3 id="存储器的管理功能"><a href="#存储器的管理功能" class="headerlink" title="存储器的管理功能"></a>存储器的管理功能</h3><ol><li>存储分配和回收（主要内容，讨论算法和相应的数据结构）</li><li>地址变换（文件生成的连接技术，加载的重定位技术，运行时的地址变换）</li><li>存储共享和保护（代码数据的共享，对地址空间的访问权限）</li><li>存储器扩充（存储器的逻辑组织和物理知识）<ol><li>由应用程序控制：覆盖</li><li>由OS控制：交换（整个进程）请求调入和预调入（部分进程）</li></ol></li></ol><h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><ul><li><p>逻辑地址，也称虚地址，相对地址</p><ul><li>由CPU执行指令时生成的地址（本条指令所需数据的地址或下一条指令地址）</li></ul></li><li><p>物理地址，也称绝对地址，实地址</p><ul><li>实际的内存单元地址</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-1.jpg" alt></p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p><img src="/2020/08/18/OS-ch-4/4.1-2.jpg" alt></p><h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><ul><li><p>将逻辑地址和物理地址分离，是内存管理的核心</p></li><li><p>逻辑地址与物理地址相同</p><ul><li>地址映像工作在编译阶段或加载阶段完成</li></ul></li><li><p>重定位</p><ul><li>进程的逻辑地址空间不同于物理地址空间，所以存储管理模块要解决逻辑地址到物理地址的映射问题。</li><li>也称地址映射，地址映像</li><li>在执行阶段完成</li></ul></li></ul><h3 id="4-1程序的装入和链接"><a href="#4-1程序的装入和链接" class="headerlink" title="4.1程序的装入和链接"></a>4.1程序的装入和链接</h3><p>编程可得到执行文件的步骤：编译（obj文件），链接（EXE文件或动态链接库dll），装入</p><p><img src="/2020/08/18/OS-ch-4/4.1-3.jpg" alt></p><h4 id="4-1-1-程序的装入"><a href="#4-1-1-程序的装入" class="headerlink" title="4.1-1 程序的装入"></a>4.1-1 程序的装入</h4><ol><li><h5 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h5></li></ol><ul><li>编译程序知道程序在内存中的地址，并产生绝对地址的目标代码</li><li>绝对装入模块装入时直接定位在上述内存地址，不修改程序和地址的数据</li><li>优点：装入过程简单，</li><li>缺点：过于依赖硬件结构，不适用于多道程序系统</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-4.jpg" alt></p><h5 id="2-可重定位装入"><a href="#2-可重定位装入" class="headerlink" title="2.可重定位装入"></a>2.可重定位装入</h5><ul><li>在多道程序下，目标的起始地址通常从0开始，程序其他地址也相对于起始地址计算，装入时可采用可重定位装入</li><li>在可执行文件中，列出需要重定位的地址单元和相对地址值（表）最后根据定位的内存地址修改重定位地址项，添加偏移量。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.1-5.jpg" alt></p><p>优点</p><ul><li>不需要硬件支持，可以装入有限多道程序</li></ul><p>缺点：</p><ul><li>一个程序需要连续的地址空间，程序装入后不能移动，不易共享</li></ul><p>地址变换是由装入程序在装入目标模块时一次完成，装入后内存不能移动，故称为静态重定位。</p><h5 id="3-动态运行时装入"><a href="#3-动态运行时装入" class="headerlink" title="3.动态运行时装入"></a>3.动态运行时装入</h5><ul><li>程序开始执行时未全部装入内存，而是部分装入，运行时需要什么模块再装什么模块</li><li>程序装入内存后不直接将相对地址转换为直接地址，等到真正执行是再转换，即动态重定位</li><li><font color="red">装入内存的所有地址都是相对的</font></li></ul><p>优点：</p><ul><li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利于实现共享。</li><li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）</li></ul><p>缺点：</p><ul><li>需要硬件支持（通常是CPU），OS实现较复杂－－是虚拟存储的基础</li></ul><h4 id="4-1-2-程序的链接"><a href="#4-1-2-程序的链接" class="headerlink" title="4.1.2 程序的链接"></a>4.1.2 程序的链接</h4><p>根据链接时间不同，分为三种</p><p>静态链接</p><ul><li>在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。要解决两个问题：<ul><li>修改相对地址</li><li>变换外部调用符号</li></ul></li><li>对多用户、多任务系统显然有冗余，比如多个用户调用了sin(x)，则每个目标代码中都有这部分代码，装入到内存则也都有这部分代码。</li></ul><p>装入时动态链接</p><ul><li>源程序编译得到的目标模块是在装入内存时，边装入边链接的，即在装入一个目标模块时，若发现一个外部模块调用事件，装入程序去找出相应的外部目标模块，并将它装入内存，同时修改相对地址。</li><li>优点<ul><li>共享：多个进程可以共用一个目标模块，节省内存，减少文件交换。</li><li>便于修改和更新。各目标模块是分开存放的，便于修改。</li></ul></li></ul><p>运行时动态链接</p><ul><li>应用程序运行时，每次运行的模块可能不同。但事先又无法知道，运行时动态链接是将某些模块的链接推迟到执行时。即，执行时发现调用的模块未被装入，由OS找到该模块并装入，并将其链接到调用者模块上。</li><li>优点：<ul><li>部分装入：一个进程只将与当前操作相对应的DLL装入内存。</li><li>便于局部代码修改：即便于代码升级和代码重用；只要函数的接口参数（输入和输出）不变，则修改函数及其DLL，无需对可执行文件重新编译或链接。</li><li>便于适应运行环境：调用不同的DLL，就可以适应多种使用环境和提供不同功能。如：不同的显示卡只需厂商为其提供特定的DLL，而OS和应用程序不必修改。</li></ul></li><li>缺点：<ul><li>链接开销：增加了程序执行时的链接开销；</li><li>管理开销：程序由多个文件组成，增加管理复杂度。 </li></ul></li></ul><h5 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h5><p><img src="/2020/08/18/OS-ch-4/4.1-6.jpg" alt></p><h5 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h5><p>在<font color="red">用户模式</font>中验证产生的地址，如果发现不好的地址，中断进入内核</p><h3 id="4-2-连续分配存储管理方式"><a href="#4-2-连续分配存储管理方式" class="headerlink" title="4.2 连续分配存储管理方式"></a>4.2 连续分配存储管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul><li>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。未采取存储保护措施。</li><li>最简单，适用于单用户、单任务的OS。CP/M和MS-DOS </li><li>优点：<ul><li>易于管理。</li></ul></li><li>缺点：<ul><li>对要求内存空间少的程序，造成内存浪费；</li><li>程序全部装入，很少使用的程序部分也占用内存固定分区分配</li></ul></li></ul><h5 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h5><p>为了支持多道程序系统和分时系统，支持多个程序并发执行</p><p>吧内存分为大小相等或不等的区，操作系统占用一个，其余给应用程序，应用程序占用一个或几个</p><h5 id="内碎片和外碎片"><a href="#内碎片和外碎片" class="headerlink" title="内碎片和外碎片"></a>内碎片和外碎片</h5><p>内：占用分区内未被利用的空间</p><p>外：占用分区之间难以利用的小空闲分区</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul><li>最简单的一种运行多道程序的存储管理方式</li><li>把内存划分为若干个固定大小的连续分区，每个分区只装入一个作业。</li><li>划分分区的方法<ul><li>分区大小相等：只适合于多个相同进程的并发执行（处理多个类型相同的对象）。</li><li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-1.jpg" alt></p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><img src="/2020/08/18/OS-ch-4/4.2-2.jpg" alt></p><ul><li><p>动态分区分配是指OS根据进程的实际需要为各进程分配连续的物理内存。</p><ul><li>分区分配中的数据结构</li><li>为了管理内存空闲分区建立了空闲分区表或空闲分区链表。</li><li>表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。  </li><li>分区表中，表项数目随着内存的分配和释放而动态改变，可以规定最大表项数目。</li><li>分区表可以划分为两个表格：空闲分区表和占用分区表。从而减小每个表格长度。空闲分区表中按不同分配算法对表项排序。</li></ul></li><li><p>分区分配算法：</p><ul><li>某个新作业装入内存，需寻找一个空闲分区，其大小需大于或等于进程的要求。</li><li>若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。</li></ul></li></ul><h5 id="首次适应算法："><a href="#首次适应算法：" class="headerlink" title="首次适应算法："></a>首次适应算法：</h5><ul><li>按分区的先后次序，从头查找，找到符合要求的第一个分区。</li><li>该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。</li><li>但随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。</li></ul><h5 id="循环适应算法："><a href="#循环适应算法：" class="headerlink" title="循环适应算法："></a>循环适应算法：</h5><ul><li>按分区的先后次序，从上次分配的分区的下一个位置开始查找（到最后一个分区时再回到开头），找到符合要求的第一个分区。</li><li>实现算法，要设置起始查询指针。</li><li>该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大的空闲分区不易保留。</li></ul><h5 id="最佳适应法-best-fit"><a href="#最佳适应法-best-fit" class="headerlink" title="最佳适应法(best-fit)"></a>最佳适应法(best-fit)</h5><ul><li>找到其大小与要求相差最小的空闲分区。</li><li>为了加速寻找，该算法要求空闲分区表将空闲分区按容量由小到大排序。</li><li>从个别来看，外碎片较小，但从整体来看，会形成较多外碎片。较大的空闲分区可以被保留。 </li></ul><h5 id="最坏适应法-worst-fit"><a href="#最坏适应法-worst-fit" class="headerlink" title="最坏适应法(worst-fit)"></a>最坏适应法(worst-fit)</h5><ul><li>找到最大的空闲分区。</li><li>算法要求空闲分区表将空闲分区按容量由大到小排序。</li><li>基本不留下小空闲分区，但较大的空闲分区不被保留。 </li></ul><h5 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h5><ul><li>又称分类搜索法。</li><li>将空闲分区根据容量大小分类，每类分区容量相同。为每类分区</li><li>设立一个空闲分区链表。系统中设立一张管理索引表，每个表项</li><li>记录的是每类空闲分区链表的表头。</li><li>优点：<ul><li>查找空闲分区效率高。</li><li>能保留大分区。</li></ul></li><li>缺点：<ul><li>回收分区时，系统开销大。</li><li>空闲分区划分越细，浪费则越严重。</li></ul></li></ul><h4 id="动态重定位分区分配"><a href="#动态重定位分区分配" class="headerlink" title="动态重定位分区分配"></a>动态重定位分区分配</h4><h4 id="4-2-3-动态分区分配"><a href="#4-2-3-动态分区分配" class="headerlink" title="4.2.3 动态分区分配"></a>4.2.3 动态分区分配</h4><p>分区分配操作 </p><ul><li>分配内存<ul><li>利用某种分配算法，从空闲分区表（链）中找到所需大小的分区</li></ul></li><li>回收内存，有以下四种情况：<ul><li>与前一个空闲分区相邻</li><li>与后一个空闲分区相邻</li><li>与前、后空闲分区都相邻</li><li>不与任何空闲分区相邻</li></ul></li></ul><h4 id="4-2-4-伙伴系统"><a href="#4-2-4-伙伴系统" class="headerlink" title="4.2.4 伙伴系统"></a>4.2.4 伙伴系统</h4><p>伙伴系统方式是动态分区分配和固定分区分配的一种折中方案。</p><p>伙伴系统规定，分区分配大小都是$2^k$ k为整数，1&lt;=k&lt;=m 2^m可以是整个内存的大小。系统中也要建立一个索引管理表，指明每个链表表头。</p><h5 id="分区分配方法："><a href="#分区分配方法：" class="headerlink" title="分区分配方法："></a>分区分配方法：</h5><ul><li>开始时，整个分区是2m，在系统运行过程中，由于不断划分，可能会形成若干不连续的空闲分区，将它们分类，每一类具有相同大小，且每类建立一个空闲分区双向链表，系统中有若干个双向链表。</li><li>当需要为进程分配大小为n的区块时，首先计算一个i，使2i-1≤n ≤2i，然后在大小为2i的空闲分区链表中查找。</li></ul><h5 id="分区回收："><a href="#分区回收：" class="headerlink" title="分区回收："></a>分区回收：</h5><ul><li>若回收大小为2i的分区，若有伙伴分区，则合并为2i+1的分区，进而可能需要合并为2i+2的分区……</li><li>算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间。</li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-3.jpg" alt></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>快速搜索合并</li><li>低外部碎片</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>内部碎片。</li><li>因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。 </li></ul><h4 id="4-2-5-可重定位分区分配"><a href="#4-2-5-可重定位分区分配" class="headerlink" title="4.2.5 可重定位分区分配"></a>4.2.5 可重定位分区分配</h4><p>当内存驻留多个进程时，分配一个区后大部分情况下都是有剩余零头的，因此在一个新作业到达时，就有可能零头分区的总和超过新作业要求的分区，但每一个空闲分区的容量都不够。</p><p>1.紧凑</p><ul><li><p>将各个占用分区向内存一段移动，使各个空闲分区聚集在另一端，合并为一个较大的空闲分区。</p></li><li><p>对占用分区进行内存数据搬移占用CPU时间，如果对占用分区中的程序进行浮动，则其重定位需要硬件支持。</p></li><li><p><font color="red">何时执行</font>：每个分区释放后或内存找不到满足条件的空闲分区。</p></li></ul><h5 id="动态重定位分区分配算法"><a href="#动态重定位分区分配算法" class="headerlink" title="动态重定位分区分配算法"></a>动态重定位分区分配算法</h5><p><img src="/2020/08/18/OS-ch-4/4.2-4.jpg" alt></p><h4 id="4-2-6-覆盖"><a href="#4-2-6-覆盖" class="headerlink" title="4.2.6 覆盖"></a>4.2.6 覆盖</h4><p>为了在较小的可用内存中运行较大的程序</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>程序必要部分常驻内存</li><li>不常用功能用其余模块实现，不使用时放外存，使用时放内存</li><li>不存在调用关系的模块不封装到内存，从而实现互相覆盖。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>程序员需要给程序分块并确定覆盖关系，增加复杂度</li><li>进程在执行过程中要从外存装入，速度慢，用时间换空间</li></ul><h4 id="4-2-7-对换"><a href="#4-2-7-对换" class="headerlink" title="4.2.7 对换"></a>4.2.7 对换</h4><ul><li><p>内存中有进程处于堵塞态，另一方面有就绪进程在外存等待</p></li><li><p>对换将暂时不能执行的程序或数据送到外存中，获得空闲内存来装入具备运行条件的进程或所需要的程序和数据</p></li><li><p>进程暂时不能执行原因</p><ul><li>阻塞态</li><li>低优先级</li></ul></li><li><p>交换单位为整个进程的地址空间</p></li><li><p>小型系统中与可重定位分区分配存储管理配合使用，称作roll in/roll out</p></li><li><p>加快进程换入，换出速度，因此采用连续分配，较少考虑碎片问题</p></li><li><p>建立磁盘的对换区，内存有空时找出就绪且换出时间最久的进程换入内存</p></li><li><p>优点</p><ul><li>增加并行进程数目，给用户适当响应时间，提高吞吐率</li></ul></li><li><p>缺点</p><ul><li>对换入换出的控制增加处理机开销，没有考虑执行过程中地址访问的统计特性</li></ul></li></ul><p><img src="/2020/08/18/OS-ch-4/4.2-5.jpg" alt></p><h3 id="4-3-基本分页存储管理方式"><a href="#4-3-基本分页存储管理方式" class="headerlink" title="4.3 基本分页存储管理方式"></a>4.3 基本分页存储管理方式</h3><h4 id="连续分配问题"><a href="#连续分配问题" class="headerlink" title="连续分配问题"></a>连续分配问题</h4><ul><li>形成外碎片和内碎片</li><li>近凑带来开销</li></ul><h4 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h4><ul><li>基本单位是页：分页存储管理</li><li>是段：分段存储管理</li><li>分页存储管理不支持虚存技术，要求吧整个作业装入内存才能运行。</li></ul><h4 id="在页式管理中："><a href="#在页式管理中：" class="headerlink" title="在页式管理中："></a>在页式管理中：</h4><ul><li>内存化为固定大小的页框，也叫页帧，物理页框</li><li>进程的逻辑地址页分为同样大小的页，程序加载时需要分配所需全部页，这些页不必连续</li><li>固定：计算机系统的内存容量固定，一个页容量也是固定的</li></ul><h4 id="进程装载："><a href="#进程装载：" class="headerlink" title="进程装载："></a>进程装载：</h4><ul><li><p>装入进程时，找空闲页框，OS将页框分配给装入过程，每个页占用一个页框，进程占用的所有页框不要求连续</p></li><li><p>要解决逻辑地址到物理地址的映像需要硬件支持。</p></li></ul><h4 id="基本分页管理中的数据结构"><a href="#基本分页管理中的数据结构" class="headerlink" title="基本分页管理中的数据结构"></a>基本分页管理中的数据结构</h4><ul><li>进程页表：每个进程有一个页表，描述该进程的每个逻辑页占用的物理页框号。</li><li>物理页面表：整个系统有一个物理页面表，描述所有物理页框的分配使用状况。数据结构：位示图，空闲页面链表；</li><li>请求表：整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换；</li><li>请求表也可以结合到各进程的PCB里，此时在PCB中记录本进程页表所在的物理页框号。上下文切换时，由OS将其加载到页表寄存器中。</li></ul><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p><img src="/2020/08/18/OS-ch-4/4.3-1.jpg" alt></p><h4 id="页面大小的选择"><a href="#页面大小的选择" class="headerlink" title="页面大小的选择"></a>页面大小的选择</h4><ul><li>和目前计算机的物理内存大小有关：2n。</li><li>较小的页面，减小内碎片，但加大页表的长度，从而形成新的开销并增加换入、换出的开销；</li><li>较大的页面，减小页表的长度，加大内碎片；管理开销小，交换时对外存I/O效率高。</li><li>两者的折中。</li></ul><h4 id="页式管理的优缺点"><a href="#页式管理的优缺点" class="headerlink" title="页式管理的优缺点"></a>页式管理的优缺点</h4><p>优点：</p><ul><li>没有外碎片，每个内碎片不超过页大小。</li><li>一个程序不必连续存放。便于改变程序占用空间的大小（主要指随着程序运行而动态生成的数据增多，要求地址空间相应增大，通常由系统调用完成而不是操作系统自动完成）。</li></ul><p>缺点：</p><ul><li>程序全部装入内存。</li></ul><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>逻辑上连续的目标程序在物理内存中已经不能保证连续存放，支持页式管理的机器硬件上都有一套地址变换机构完成逻辑地址到物理地址的变换。<br>逻辑地址分为两部分：逻辑页号，页内偏移地址；<br>通过查进程页表，得物理页号，从而形成物理地址。</p><h4 id="4-3-2快表"><a href="#4-3-2快表" class="headerlink" title="4.3.2快表"></a>4.3.2快表</h4><h4 id="4-3-3-两级和多级页表"><a href="#4-3-3-两级和多级页表" class="headerlink" title="4.3.3 两级和多级页表"></a>4.3.3 两级和多级页表</h4><h3 id="4-4-基本分段存储管理"><a href="#4-4-基本分段存储管理" class="headerlink" title="4.4 基本分段存储管理"></a>4.4 基本分段存储管理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理&lt;/h2&gt;&lt;p&gt;用户程序的主要处理阶段&lt;/p&gt;
&lt;p&gt;连续分配方式&lt;/p&gt;
&lt;p&gt;离散分配方式&lt;/p&gt;
&lt;p&gt;虚拟存储器的基本特征&lt;
      
    
    </summary>
    
    
    
      <category term="-OS -操作系统 -ch3" scheme="http://yokeso.top/tags/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-ch3/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-3</title>
    <link href="http://yokeso.top/2020/08/17/OS-ch-3/"/>
    <id>http://yokeso.top/2020/08/17/OS-ch-3/</id>
    <published>2020-08-17T08:25:30.000Z</published>
    <updated>2020-08-17T17:06:58.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><p>多道程序下，进程数目往往多于处理机数目。需要系统按某种算法动态将处理机分配给就绪队列中的进程，使之执行。</p><h3 id="3-1-处理机调度层次"><a href="#3-1-处理机调度层次" class="headerlink" title="3.1 处理机调度层次"></a>3.1 处理机调度层次</h3><h5 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h5><ul><li>又称作业调度或长期调度，根据某种算法决定将处于外存上后备队列的哪些作业调入内存</li><li>作业：利用计算机进行一次运行所需工作的集合，要完成一个工作要先提交一次作业。一个作业可能由多个程序构成。</li><li>PC机或者普通工作站和服务器上几乎没有作业的概念。</li></ul><h5 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h5><ul><li>也称进程调度或短期调度，用于决定就绪队列中哪个进程获得处理机，之后派发程序将处理机分配给进程。</li></ul><h5 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h5><p>1）非抢占式调度</p><ul><li>一旦把处理机分配给某进程后，便让进程一直执行，直到进程阻塞，再把处理机分配给其他进程</li></ul><p>2）抢占式调度</p><ul><li>允许暂停一个正在执行的进程，将处理机分配给另一进程。<ul><li>时间片轮转分给进程的时间片用完</li><li>按照优先级调度，更高级优先权就绪</li><li>短作业优先原则</li></ul></li></ul><h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><ul><li>条件允许的情况下，在外存挂起的进程集合中选择哪些进程激活并调回内存。</li><li>提高效率，加快运行，调节复合，提高吞吐量。</li><li>有时需要选择内存或者就绪的进程放在外存中，叫做挂起</li><li>这些进程具备运行条件，内存稍有空闲时，中级调度把这些放入就绪队列，叫做对换。</li></ul><h5 id="三种调度之间的关系"><a href="#三种调度之间的关系" class="headerlink" title="三种调度之间的关系"></a>三种调度之间的关系</h5><p><img src="/2020/08/17/OS-ch-3/3.1-1.jpg" alt></p><h4 id="3-1-2-调度队列模型"><a href="#3-1-2-调度队列模型" class="headerlink" title="3.1.2 调度队列模型"></a>3.1.2 调度队列模型</h4><h5 id="1-仅有进程调度"><a href="#1-仅有进程调度" class="headerlink" title="1.仅有进程调度"></a>1.仅有进程调度</h5><p><img src="/2020/08/17/OS-ch-3/3.1-2.jpg" alt></p><h5 id="2-具有高级和低级的调度队列模型"><a href="#2-具有高级和低级的调度队列模型" class="headerlink" title="2.具有高级和低级的调度队列模型"></a>2.具有高级和低级的调度队列模型</h5><p><img src="/2020/08/17/OS-ch-3/3.1-3.jpg" alt></p><h5 id="3-同时具有三级调度的模型"><a href="#3-同时具有三级调度的模型" class="headerlink" title="3.同时具有三级调度的模型"></a>3.同时具有三级调度的模型</h5><p><img src="/2020/08/17/OS-ch-3/3.1-4.jpg" alt></p><h4 id="3-1-3-选择调度方式和算法的若干法则"><a href="#3-1-3-选择调度方式和算法的若干法则" class="headerlink" title="3.1.3 选择调度方式和算法的若干法则"></a>3.1.3 选择调度方式和算法的若干法则</h4><p>处理机调度算法的性能可以从不同角度去看，所以是一个综合的判断结果。</p><h5 id="面向用户"><a href="#面向用户" class="headerlink" title="面向用户"></a>面向用户</h5><ul><li>周转时间短</li><li>响应时间快</li><li>截至时间保证</li><li>优先权准则</li></ul><h5 id="面向系统"><a href="#面向系统" class="headerlink" title="面向系统"></a>面向系统</h5><ul><li>吞吐量高</li><li>处理机利用率好</li><li>资源平衡利用</li></ul><h5 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h5><p>作业从提交到完成所经历的时间（后备队列等待，CPU执行，就绪队列，阻塞队列等待，结果输出）</p><p>平均周转时间：<br>$$<br>T=\frac{1}{n}\sum_{i=1}^{n}T_i<br>$$<br>带权周转时间<br>$$<br>W=\frac{1}{n}\sum_{i=1}^{n}\frac{T_i}{T_{si}}<br>$$<br>例：下面三道作业的平均周转时间和平均带权周转时间</p><table><thead><tr><th align="center">作业</th><th align="center">提交时间/时</th><th align="center">运行时间/h</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">10.00</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">10.10</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">10.25</td><td align="center">0.25</td></tr></tbody></table><p><img src="/2020/08/17/OS-ch-3/3.1-5.jpg" alt></p><p>平均周转时间：<br>$$<br>T=\frac{2+2.9+3}{3}=2.63h<br>$$<br>平均带权周转时间：<br>$$<br>W=\frac{2+2.9+12}{3}=5.3h<br>$$</p><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><ul><li>分时系统的重要指标</li><li>用户输入一个请求到系统首次响应的时间</li></ul><h5 id="截至时间"><a href="#截至时间" class="headerlink" title="截至时间"></a>截至时间</h5><ul><li>实时系统重要指标</li><li>分为开始截至时间和完成截至时间</li><li>某任务必须<font color="red">开始执行的最迟时间</font>或者<font color="red">必须完成的最迟时间</font></li></ul><h5 id="优先权原则"><a href="#优先权原则" class="headerlink" title="优先权原则"></a>优先权原则</h5><ul><li>批处理，分时，实时系统都可遵循</li><li>可以使关键人物达到最好目标</li><li>公平性：不会因为进程本身的特性使上述指标过分恶化</li></ul><h5 id="面向系统准则"><a href="#面向系统准则" class="headerlink" title="面向系统准则"></a>面向系统准则</h5><ul><li><p>吞吐量</p><ul><li>批处理系统的重要指标</li><li>吞吐量指时间内完成的作业数，和作业本身特性或者调度算法都有关系</li></ul></li><li><p>处理及利用率高</p><ul><li>大中型主机多用户系统指标，PC一般不考虑</li></ul></li><li><p>各种资源平衡利用</p><ul><li>大中型多用户系统性能指标。如CPU繁忙的作业和I/O繁忙</li></ul></li></ul><h5 id="调度算法本身的调度性能准则"><a href="#调度算法本身的调度性能准则" class="headerlink" title="调度算法本身的调度性能准则"></a>调度算法本身的调度性能准则</h5><ul><li>易于实现</li><li>执行开销比</li></ul><h3 id="3-2-调度算法"><a href="#3-2-调度算法" class="headerlink" title="3.2 调度算法"></a>3.2 调度算法</h3><p>OS中的调度实质时一种资源分配</p><p>有的调度算法使用于作业调度，有的算法适用与作业调度，有的两者都适应。</p><h4 id="3-2-1-先来先服务和短作业优先算法"><a href="#3-2-1-先来先服务和短作业优先算法" class="headerlink" title="3.2.1 先来先服务和短作业优先算法"></a>3.2.1 先来先服务和短作业优先算法</h4><h5 id="FCFS算法"><a href="#FCFS算法" class="headerlink" title="FCFS算法"></a>FCFS算法</h5><ul><li><p>算法描述</p><ul><li>按照作业或者进程变为就绪态的先后顺序，分派CPU，当前作业或进程占用CPU，直到执行完或阻塞才让出（非抢占）</li><li>在作业或进程唤醒后，不立即恢复执行，而是排队，</li><li>是最简单的算法</li></ul></li><li><p>FCFS的特点</p><ul><li>有利长作业，不利短作业</li><li>有利于CPU繁忙，不利于IO繁忙</li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.2-1.jpg" alt></p><h5 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h5><ul><li><p>算法描述</p><ul><li>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业</li><li>是对FCFS算法的改进，目标是减少平均周转时间</li></ul></li><li><p>SJF的特点</p><ul><li>优点<ul><li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业等待时间</li><li>提高系统吞吐量</li></ul></li><li>缺点<ul><li>对长作业不利，可能长时间得不到执行</li><li>未能依据作业的紧迫程度来划分优先级</li><li>难以准确估计作业（进程）的执行时间，从而影响调度性能</li></ul></li></ul></li></ul><p>SJF的变形：<br>最短剩余时间优先 SRT（允许比当前进程剩余时间更短的进程来抢占）</p><p>最高相应比优先 HRRN （相应比R=（等待时间+要求执行时间）/要求执行时间，FCFS和SJF的折中）</p><h4 id="3-2-2优先权调度算法"><a href="#3-2-2优先权调度算法" class="headerlink" title="3.2.2优先权调度算法"></a>3.2.2优先权调度算法</h4><p>本算法适用于祖业调度和进程调度</p><p>算法用于作业调度时，系统从后备队列中选择优先权最高的作业装入内存</p><p>用于进程调度，系统吧处理机派发给就绪队列中优先权的最高进程</p><ul><li><p>抢占式：当前进程时间片未用完时就可被优先级更高的进程抢占CPU</p></li><li><p>非抢占式：除非自愿或时间片到，当前进程不可被优先级更高的进程抢用CPU</p></li><li><p>可抢占程度越高，对实时系统满足越好</p></li></ul><p><img src="/2020/08/17/OS-ch-3/3.2-2.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.2-3.jpg" alt></p><p>优先权的类型</p><p>静态优先级</p><ul><li><p>创建进程时就确定，直到进程终止前都不改变。通常是一个整数。</p></li><li><p>依据：</p><ul><li>进程类型（系统进程优先级较高）</li><li>对资源的需求（对CPU和内存需求较少的进程，优先级较高）</li><li>用户要求（紧迫程度和付费多少） </li></ul></li><li><p>特点：</p><ul><li>简单，系统开销小</li><li>不精确，仅在要求不高的系统中使用</li></ul></li><li><p>动态优先级</p></li><li><p>在创建进程时赋予的优先级，在进程运行过程中可以自动改变，以便获得更好的调度性能。</p></li><li><p>如：</p><ul><li>在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待足够的时间后，其优先级提高到可被调度执行；</li><li>进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU。 </li></ul></li></ul><h5 id="高响应比优先调度算法-HRRN-HRN"><a href="#高响应比优先调度算法-HRRN-HRN" class="headerlink" title="高响应比优先调度算法(HRRN,HRN)"></a>高响应比优先调度算法(HRRN,HRN)</h5><ul><li><p>响应比R<br>   = (等待时间 + 要求执行时间) / 要求执行时间<br>   ＝1＋等待时间/要求执行时间</p></li><li><p>是FCFS和SJF的折衷：</p><ul><li>作业等待时间相同，服务时间越短，优先权越高–SJF；</li><li>要求服务时间相同，等待时间越长，优先权越高–FCFS；长作业随着等待时间的增加，优先权增加。 </li></ul></li><li><p>缺点：</p><ul><li>响应比的计算增加系统开销</li></ul></li></ul><h4 id="3-2-3基于时间片的轮转调度算法"><a href="#3-2-3基于时间片的轮转调度算法" class="headerlink" title="3.2.3基于时间片的轮转调度算法"></a>3.2.3基于时间片的轮转调度算法</h4><p>时间片轮转法（Round Robin, RR)</p><ul><li>本算法主要用于微观调度（进程调度）</li><li>设计目标是提高资源利用率</li><li>基本思路是通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率 </li></ul><p>算法描述</p><ul><li>将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li><li>每次调度时将CPU分派给队首进程，让其执行一个时间片。在一个时间片结束时，发生时钟中断。调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</li><li>时间片的长度从几个ms到几百ms。</li><li>进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li></ul><p>时间片长度的确定</p><ul><li>时间片长度变化的影响<ul><li>过长－&gt;退化为FCFS算法</li><li>过短－&gt;用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长。</li></ul></li><li>就绪进程的数目：数目越多，时间片越小</li><li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li></ul><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p><p>1) 算法描述</p><ul><li>设置多个就绪队列，分别赋予不同的优先级，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长。</li><li>假设有三个就绪队列：<ul><li>Q1－－时间片为8</li><li>Q2－－时间片为16</li><li>Q3－－FCFS</li></ul></li><li>新进程进入内存后，先投入队列1的末尾，若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，若仍未完成，降低到最后的队列，按FCFS算法调度直到完成。</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。</li></ul><p>2）算法性能</p><ul><li>终端型进程：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，可处理完一次I/O请求的数据，然后转入到阻塞队列。</li><li>计算型进程（长批处理作业）：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。<br>短批处理作业：  先放入第1级，一般经过1，2级即可完成。</li></ul><p>3）优点：</p><ul><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li><li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li><li>不必估计进程的执行时间，动态调节</li></ul><h3 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h3><h4 id="3-4-1实现实时调度的基本条件"><a href="#3-4-1实现实时调度的基本条件" class="headerlink" title="3.4.1实现实时调度的基本条件"></a>3.4.1实现实时调度的基本条件</h4><ul><li>提供必要信息（就绪时间，开始截至时间，资源要求，优先级）</li><li>系统处理能力强:    单处理机： $\sum_{i=1}^{m}\frac{C_i}{P_i}&lt;=1$，多处理机： $\sum_{i=1}^{m}\frac{C_i}{P_i}&lt;=N$</li><li>采用抢占式调度机制</li><li>具有快速切换机制 （快速响应中断，快速任务分派）</li></ul><h4 id="3-4-2-实时调度算法分类"><a href="#3-4-2-实时调度算法分类" class="headerlink" title="3.4.2 实时调度算法分类"></a>3.4.2 实时调度算法分类</h4><h5 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h5><p>1） 基于时钟中断的抢占式优先权调度算法</p><ul><li>在某实时任务到达后，若其优先级高于占有处理机的进程优先级，并不抢占，等到时钟中断到达时再抢占。<br>调度延迟可降为几十至几毫秒。</li></ul><p>2）立即抢占</p><ul><li>操作系统具有快速响应外部中断的能力。一旦出现外部中断，只要当前进程未处于临界区，立即抢占CPU。</li></ul><h5 id="非抢占式优先调度算法"><a href="#非抢占式优先调度算法" class="headerlink" title="非抢占式优先调度算法"></a>非抢占式优先调度算法</h5><ul><li>要求严格的任务赋予高优先级，执行后其他任务才能调度执行</li></ul><h4 id="3-4-3-常用的几种实时调度算法"><a href="#3-4-3-常用的几种实时调度算法" class="headerlink" title="3.4.3 常用的几种实时调度算法"></a>3.4.3 常用的几种实时调度算法</h4><ol><li>最早截止时间优先 EDF（Earliest Deadline First）</li></ol><ul><li>根据任务的开始截止时间确定任务的优先级。具有最早截止时间的任务排在队列的最前面。</li><li>即可用于抢占式调度，又可用于非抢占式调度。</li></ul><ol start="2"><li>最低松弛度优先LLF（Least Laxity First）算法</li></ol><ul><li>任务的紧急程度愈高，该任务的优先级愈高。</li><li>松弛度 = 必须完成时间-本身运行时间-当前时间</li><li>如，t=0时，某任务在200ms时必须完成，他本身执行的时间是100ms，则其松弛度为100ms。</li><li>LLF算法按松弛度排就绪队列，松弛度最低的排在队列最前面，优先被调度执行。</li><li>LLF主要用于可抢占调度方式中。</li></ul><h3 id="3-5-死锁产生的原因和必要条件"><a href="#3-5-死锁产生的原因和必要条件" class="headerlink" title="3.5 死锁产生的原因和必要条件"></a>3.5 死锁产生的原因和必要条件</h3><p>死锁：多个进程争夺共享资源出现的僵局。</p><p>产生原因：</p><ul><li>竞争资源(不可剥夺资源)<ul><li>资源数目不能满足进程需要</li><li>双方都有部分资源，同时请求对方已占有的资源</li><li>硬件中的中断，信号，消息，缓冲区数据</li></ul></li><li>顺序不当<ul><li>进程运行过程中，请求和释放资源顺序不当</li><li>多个进程并发执行，相互的推进顺序不确定，可能会导致两种结果：不出现死锁和出现死锁。</li></ul></li></ul><h4 id="3-5-2-产生死锁的必要条件"><a href="#3-5-2-产生死锁的必要条件" class="headerlink" title="3.5.2 产生死锁的必要条件"></a>3.5.2 产生死锁的必要条件</h4><p>只有4个条件都满足时，才会出现死锁。</p><ul><li>互斥：任一时刻只允许一个进程使用资源</li><li>请求和保持：进程保持了至少一个资源，但又提出了新的资源请求，该资源又被其他进程占用。</li><li>不剥夺：进程已经占用的资源，未使用完，不能被剥夺。</li><li>环路等待：存在进程－资源环形链，即有进程集合{P0, P1, P2,….Pn},P0等待P1占用的资源，P1等待P2占用的资源…..Pn等待P0占用的资源。    </li></ul><h4 id="3-5-3-处理死锁办法"><a href="#3-5-3-处理死锁办法" class="headerlink" title="3.5.3 处理死锁办法"></a>3.5.3 处理死锁办法</h4><ul><li>预防死锁<ul><li>采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不同时满足死锁的四个必要条件</li></ul></li><li>避免死锁<ul><li>在资源的动态分配过程中，防止系统进入不安全状态。</li></ul></li><li>检测死锁<ul><li>允许系统进入死锁，但系统及时检测，并采取措施。</li></ul></li><li>解除死锁<ul><li>当检测到系统进入了死锁，采取措施解除。</li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.6-1.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.6-2.jpg" alt></p><p><img src="/2020/08/17/OS-ch-3/3.6-3.jpg" alt></p><h4 id="3-6-2-系统的安全状态"><a href="#3-6-2-系统的安全状态" class="headerlink" title="3.6.2 系统的安全状态"></a>3.6.2 系统的安全状态</h4><p>系统按某种进程顺序为进程分配资源，直至达到进程的最大需求，使每个进程都可以顺利完成。</p><p>无法找到安全序列则称系统处于不安全状态</p><h4 id="3-6-3-避免死锁-银行家算法"><a href="#3-6-3-避免死锁-银行家算法" class="headerlink" title="3.6.3 避免死锁-银行家算法"></a>3.6.3 避免死锁-银行家算法</h4><p>银行家算法（Dijkstra, 1965）问题</p><ul><li>在银行中，客户申请贷款的数量是有限的。银行家应尽量满足所有客户的贷款需求。</li><li>银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</li></ul><p>为保证资金的安全，银行家规定：</p><ul><li>当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客(试探性分配) </li><li>顾客可以分期贷款，但贷款的总数不能超过最大需求量(可能一次并不能满足所需要的全部资源) </li><li>当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款(不存在死锁) </li><li>当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金(运行后释放) </li></ul><h5 id="1-银行家算法中的数据结构"><a href="#1-银行家算法中的数据结构" class="headerlink" title="1.银行家算法中的数据结构"></a>1.银行家算法中的数据结构</h5><p>设系统中共有n个进程，m类资源<br>(1) 可利用资源向量Available[m]。<br>       若Available[i]＝k，表示系统中Ri类资源有k个。<br>(2) 最大需求矩阵Max[n,m]<br>       若Max[i,j]=k，表示进程 i 需要Rj类资源k个。<br>(3) 分配矩阵Allocation[n,m]<br>       若Allocation[i,j] = k，表示进程 Pi 现在拥有 Rj 类型的资源k个。<br>(4)需求矩阵Need[n,m]<br>       若 Need[i,j] = k，表示进程 Pi 最多还需要Rj类型的资源k个，它才能完成任务<br>       Need[i,j]=Max[i,j]– Allocation[i,j]</p><ol start="2"><li><h5 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h5></li></ol><p>Requesti为进程 Pi 的请求向量。如果 Requesti [j] = k ，表示进程 Pi 需要Rj类型资源k个。</p><ol><li><p>如果 Requesti  Needi ，转去执行第2步。否则产生错误，因为进程对资源的请求已经超过它事先声明的最大数量。</p></li><li><p>如果 Requesti  Available，转去执行第3步。 否则进程Pi必须等待，因为现有资源不够分配。</p></li><li><p>假设将进程 Pi 请求的资源分配给它，并按如下方式修改状态<br>Available = Available – Requesti<br>Allocationi = Allocationi + Requesti<br>Needi = Needi – Requesti<br>则系统进入新状态，用安全算法验证新状态是安全的。<br>如果安全 -&gt;  将资源分配给进程 Pi，系统进入新状态。<br>如果不安全 -&gt;  进程 Pi必须等待，系统保持原状态。</p></li><li><h5 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h5><p>(1)Work 和 Finish 分别是长度为m 和 n 的向量， 分别初始化为：</p><pre><code>Work = AvailableFinish[i]=false (i = 1,3, …, n)</code></pre><p>(2)查找这样的 i 使其满足：</p><pre><code>(a) Finish [i] = false(b) Needi  Work如果没有这样的 i 存在就转去执行第4步</code></pre><p>(3)Work = Work + Allocationi</p><p>​    Finish[i] = true  </p><p>​    转去执行第2步<br>(4)如果对所有的i，Finish[i]==true ，那么系统是安全的。否则，系统处于不安全状态。</p></li></ol><p><strong>例子详见PPT</strong></p><ol start="4"><li><h5 id="银行家算法特点"><a href="#银行家算法特点" class="headerlink" title="银行家算法特点"></a>银行家算法特点</h5></li></ol><ul><li>允许互斥、部分分配和不可抢占，可提高资源利用率；</li><li>要求事先说明最大资源要求，在现实中很困难。</li></ul><h3 id="3-7-死锁的检测和解除"><a href="#3-7-死锁的检测和解除" class="headerlink" title="3.7 死锁的检测和解除"></a>3.7 死锁的检测和解除</h3><p>系统为进程分配资源时，若未采取避免和预防死锁的措施，系统必须提供检测和解除死锁的手段。即：</p><ul><li>保存资源的请求和分配信息</li><li>利用某种算法对这些信息加以检查，以判断是否存在死锁。</li></ul><h5 id="1-资源分配图"><a href="#1-资源分配图" class="headerlink" title="1. 资源分配图"></a>1. 资源分配图</h5><p><img src="/2020/08/17/OS-ch-3/3.7-1.jpg" alt></p><h5 id="2-死锁定理"><a href="#2-死锁定理" class="headerlink" title="2. 死锁定理"></a>2. 死锁定理</h5><p>资源分配图的化简方法：</p><ul><li>删除既不处于等待状态又不独立的进程的所有弧（包括请求边和分配边），该点变为孤立点。</li><li>重复上述过程，若最后所有进程结点是孤立点，则称该资源图是完全可简化的，否则是不可完全简化的</li></ul><p>死锁定理：S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化。其中的有边进程为死锁进程。</p><h5 id="3-死锁检测算法"><a href="#3-死锁检测算法" class="headerlink" title="3. 死锁检测算法"></a>3. 死锁检测算法</h5><p>1）检测算法中的数据结构<br>    设系统中有n个进程，m类资源<br>    Available:长度为 m 的向量，表示各种类型资源的可用实例数<br>    Allocation:为 n  m 矩阵，表示目前已分配给各个进程的各种资源的数量<br>    Request:为 n  m 矩阵，表示目前各个进程请求资源的情况。若Request[i,j] = k, 表示进程 Pi 正在请求 k 个类型为Rj的资源。</p><p>2）算法描述<br>    (1)设Work 和 Finish 分别是长度为m 和 n 的向量，各自初始化为：<br>        (a) Work = Available<br>        (b) 对于i = 1,2, …, n，如果 Allocationi  0, 那么Finish[i] = false；否则 Finish[i] = true.<br>    (2) 查找这样的下标 i ，使其满足：<br>        (a) Finish[i] == false</p><p>(3) Work = Work + AllocationiFinish[i] = true转去执行第2步 。<br>(4) 如果对某个i （ 1 &lt;= i &lt;=  n ），若Finish[i] == false，那么系统死锁。 而且，如果 Finish[i] == false，那么进程 Pi 正处于死锁状态。</p><p>该算法需要O(m x n2) 操作来检查系统是否处于死锁状态</p><h5 id="4-死锁检测算法的应用"><a href="#4-死锁检测算法的应用" class="headerlink" title="4.死锁检测算法的应用"></a>4.死锁检测算法的应用</h5><ul><li>何时、以什么样的频率调用检测算法，取决于以下两个因素：<ul><li>可能发生死锁的频率是多少?</li><li>将影响多少进程（重新执行全部或部分代码）?</li></ul></li><li>一旦资源请求不能立刻响应，调用检测算法（开销大）</li><li>固定间隔调用检测算法，例如每小时1次或CPU利用率&lt;40%。</li></ul><h5 id="解除死锁的方法："><a href="#解除死锁的方法：" class="headerlink" title="解除死锁的方法："></a>解除死锁的方法：</h5><ul><li>终止进程<ul><li>代价大，易实现</li><li>一次仅终止一个进程，直到消除环路为止（观察资源执行时间，使用资源数目，以及剩余时间，需求资源数目评断）</li></ul></li><li>剥夺资源<ul><li>选择一个牺牲者<ul><li>代价最小</li></ul></li><li>回退（后退）<ul><li>退回安全状态，在此重新启动进程</li><li>完全回滚：进程终止后重新开始</li></ul></li><li>饿死<ul><li>如果仅仅是基于代价来选择进程的话，某些进程可能会饿死。因此“代价”还应增加一个因素：做牺牲品的次数。</li></ul></li></ul></li></ul><p><img src="/2020/08/17/OS-ch-3/3.7-3.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章-处理机调度与死锁&quot;&gt;&lt;a href=&quot;#第三章-处理机调度与死锁&quot; class=&quot;headerlink&quot; title=&quot;第三章 处理机调度与死锁&quot;&gt;&lt;/a&gt;第三章 处理机调度与死锁&lt;/h2&gt;&lt;p&gt;多道程序下，进程数目往往多于处理机数目。需要系统按某种算法动
      
    
    </summary>
    
    
    
      <category term="-操作系统 -OS -ch3" scheme="http://yokeso.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-ch3/"/>
    
  </entry>
  
  <entry>
    <title>OS-ch-2</title>
    <link href="http://yokeso.top/2020/08/14/OS-ch-2/"/>
    <id>http://yokeso.top/2020/08/14/OS-ch-2/</id>
    <published>2020-08-14T13:47:57.000Z</published>
    <updated>2020-08-17T08:18:25.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h2><p>为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进程或线程。</p><h3 id="2-1-进程的基本概念"><a href="#2-1-进程的基本概念" class="headerlink" title="2.1 进程的基本概念"></a>2.1 进程的基本概念</h3><h4 id="2-1-1-程序的基本特征"><a href="#2-1-1-程序的基本特征" class="headerlink" title="2.1.1 程序的基本特征"></a>2.1.1 程序的基本特征</h4><p>程序执行的两种方式：<font color="red">顺序执行</font>和<font color="red">并发执行</font></p><p>(1)顺序执行：单道批处理系统的执行方式：<br><strong>特征</strong>：</p><ul><li><strong>顺序性</strong>：按照程序结构所指定的次序执行。</li><li><strong>封闭性</strong>：独占全部资源，计算机的状态只由于该程序的控制逻辑所决定，结果不受外界因素的影响。</li><li><strong>可再现性</strong>：初始条件相同则结果相同</li></ul><p>(2)为了提高资源利用率并发执行</p><p>特征：</p><ul><li>间断性：程序中途停下来失去原有时序的联系。</li><li>失去封闭性：共享资源受到其他程序控制影响</li><li>失去可再现性：外界环境在程序两次执行期间发生变化</li></ul><p>并发执行条件：达到封闭性和可再现性。</p><h4 id="2-1-2-进程的定义与特征"><a href="#2-1-2-进程的定义与特征" class="headerlink" title="2.1.2 进程的定义与特征"></a>2.1.2 进程的定义与特征</h4><p>进程：一个具有一定独立功能的程序在一个数据集合上一次动态执行的一个过程。</p><p>​            处理机、存储器和外设等资源的分配和回收的基本单位</p><p>一个进程应该包括：</p><ul><li>程序代码</li><li>程序处理的数据，堆栈</li><li>程序计数器中的值，指示下一条将运行的指令</li><li>一组通用的寄存器当前值</li><li>一组系统资源</li></ul><p>进程包括了正在运行的一个程序的所有状态信息。</p><h5 id="进程与程序的关系"><a href="#进程与程序的关系" class="headerlink" title="进程与程序的关系"></a>进程与程序的关系</h5><ul><li><p><strong>程序是产生进程的基础；进程是程序功能的体现。</strong></p></li><li><p><strong>程序是</strong><font color="red">静态</font>实体；进程是<font color="red">动态</font>过程。</p></li><li><p><strong>程序是指令、数据及其组织形式的描述；进程是程序（那些指令和数据）的真正运行实例。</strong></p></li><li><p><strong>进程是暂时的</strong>，是一个状态变化的过程；程序是永久的，可长久保存。</p></li><li><p><strong>通过多次执行，</strong>一个程序可产生多个进程；<strong>通过调用关系</strong>，一个进程可包括多个程序。</p></li><li><p><strong>进程需要一些资源才能完成工作，如</strong>CPU使用时间、存储器、文件以及I/O设备。</p></li></ul><h5 id="进程特征："><a href="#进程特征：" class="headerlink" title="进程特征："></a>进程特征：</h5><ul><li><p>动态性：创建产生，调度执行，受制于资源，撤销消亡。</p></li><li><p>进程具有动态的地址空间（数量和内容），地址空间上包括：代码、数据、进程控制块（PCB）</p></li><li><p>并发性：多个进程同时存在于内存，宏观上同时运行。</p></li><li><p>独立性：资源分配的单位。</p></li><li><p>各进程的地址空间相互独立，除非采用进程间通信手段</p></li><li><p>异步性：进程按各自独立的、不可预知的速度向前推进。</p></li><li><p>结构化：进程实体由代码段，数据段和进程控制块(PCB) 组成。</p><ul><li><p>进程控制块包含在核心区。内存核心段通常存放OS核心部分，由各个进程共享，包括各进程的PCB。</p></li><li><p>程序文件中通常划分为代码段和数据段</p></li></ul></li></ul><h4 id="2-1-3-进程控制块"><a href="#2-1-3-进程控制块" class="headerlink" title="2.1.3 进程控制块"></a>2.1.3 进程控制块</h4><p>描述进程的数据结构：进程控制块（PCB）</p><p>操作系统为每个进程都维护了一个PCB，用来保存与该进程有关的各种状态信息。</p><p><img src="/2020/08/14/OS-ch-2/2.1-1.jpg" alt></p><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB:"></a><strong>PCB</strong>:</h5><ul><li>OS中最重要的结构类型，记录描述进程执行情况以及控制进程运行的全部信息</li><li>进程存在的唯一标志，每个进程在OS中登记的表项，OS通过对PCB的组织管理来对进程进行控制管理。</li><li>进程创建时生成PCB，终止时回收PCB</li><li>PCB常驻于由OS维护的内存核心区，不能由应用程序自身的代码来直接访问，而要通过系统调用间接访问。</li><li>OS专门开辟PCB区将所有的PCB组织成若干个链表或队列。</li></ul><h5 id="PCB中信息："><a href="#PCB中信息：" class="headerlink" title="PCB中信息："></a><strong>PCB中信息</strong>：</h5><ul><li><p>程序描述信息：进程标识符，唯一内部标识符；进程名，外部标识符；本进程的产生者标识(父进程标识)； 用户标识符，以指示拥有该进程的用户。<br>处理机状态信息，保存进程运行现场信息。</p></li><li><p>通用寄存器  8-32个，用户程序可使用的数据、地址等寄存器</p></li><li><p>指令计数器  要访问的下一条指令地址</p></li><li><p>程序状态字PSW  条件码、执行方式、中断屏蔽标志 </p></li><li><p>用户栈指针  用户进程拥有的系统栈，存放过程和系统调用参数及调用地址</p></li><li><p>进程调度信息, 用于操作系统调度进程并占用处理机： </p><ul><li>进程的当前状态； </li><li>优先级(priority)； </li><li>运行统计信息（执行时间、页面调度）； </li><li>事件：阻塞原因等。</li></ul></li><li><p>进程控制信息： </p><ul><li>程序段和数据段的地址；  </li><li>进程间同步和通信； </li><li>资源占用信息：除CPU外的进程所需的全部资源及已分配资源清单</li><li>链接指针：本进程所在队列的下一个进程的PCB首地址。</li></ul></li></ul><h5 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h5><p><img src="/2020/08/14/OS-ch-2/2.1-2.jpg" alt></p><h5 id="进程调度队列："><a href="#进程调度队列：" class="headerlink" title="进程调度队列："></a>进程调度队列：</h5><ul><li><p>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态。</p></li><li><p>不同的状态分别用不同的队列来表示（就绪队列，各种类型的堵塞队列）</p><ul><li>作业队列：系统中所有进程的集合</li><li>就绪队列：驻留主存的所有就绪态进程集合</li><li>设备队列：等待I/O设备的进程集合</li></ul></li><li><p>队列在各种队列中的迁移：</p><ul><li>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</li></ul></li></ul><p><img src="/2020/08/14/OS-ch-2/2.1-3.jpg" alt="就绪队列和各种IO队列"></p><h5 id="PCB组织方式（两种）"><a href="#PCB组织方式（两种）" class="headerlink" title="PCB组织方式（两种）"></a>PCB组织方式（两种）</h5><p>链表：同一状态的进程其PCB构成一个链表，多个状态对应多个不同的链表</p><p><img src="/2020/08/14/OS-ch-2/2.1-4.jpg" alt="链表方式"></p><p>索引表：同一状态的进程归入一个Index表，（由index指向PCB）多个状态对应多个不同的PCB表</p><p><img src="/2020/08/14/OS-ch-2/2.1-5.jpg" alt="链表方式"></p><h5 id="利用PCB完成进程切换"><a href="#利用PCB完成进程切换" class="headerlink" title="利用PCB完成进程切换"></a>利用PCB完成进程切换</h5><p><img src="/2020/08/14/OS-ch-2/2.1-6.jpg" alt></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>进程管理中最基本的功能是<font color="red">进程控制</font></p><p>进程的生命周期：</p><ul><li>进程创建</li><li>进程运行</li><li>进程等待</li><li>进程唤醒</li><li>进程终止</li></ul><p>进程控制任务</p><ul><li>进程的创建，终止，进程状态的转变等</li></ul><p>进程控制一般由OS内核的原语来实现</p><ul><li>原语：由若干指令构成的原子操作</li><li>许多系统调用是原语，但不是所有的系统调用都是原语</li></ul><h4 id="2-2-1-进程的创建"><a href="#2-2-1-进程的创建" class="headerlink" title="2.2.1 进程的创建"></a>2.2.1 进程的创建</h4><h5 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h5><ul><li>树状结构，父子进程关系</li><li>子进程可以继承父进程的所有资源，如打开文件，缓冲区等。当子进程被撤销，应将继承的资源还给父进程。撤销父进程也必须同时撤销所有的子进程。</li><li>PCB中设置了家族关系表项。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-1.jpg" alt="进程图"></p><p>$$<br>引起进程创建的事件\<br>\begin{equation}<br>由操作系统内核创建\begin{cases}<br>1.操作系统初始化\<br>-分时系统中用户登录\<br>-批处理中作业调度\<br>2.提供服务\<br>-用户请求创建进程\<br>\end{cases}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>由应用程序自身创建\begin{cases}<br>3.应用请求\<br>-正在运行的进程执行了\创建进程的系统调用<br>\end{cases}<br>\end{equation}<br>$$</p><p>原语CREAT（）按下述步骤创建一个新进程:</p><ul><li>申请空白PCB。</li><li>为新进程分配资源：为代码、数据、用户栈分配空间。</li><li>初始化PCB：初始化标识信息、处理机状态（PC、SP)、处理机控制信息（进程状态、优先级）。 </li><li>将新进程插入就绪队列 。 </li></ul><h4 id="2-2-2-进程的终止"><a href="#2-2-2-进程的终止" class="headerlink" title="2.2.2 进程的终止"></a>2.2.2 进程的终止</h4><p><img src="/2020/08/14/OS-ch-2/2.2-2.jpg" alt></p><h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><ul><li>从PCB集合中检索出该进程的PCB，从中读出该进程的状态。</li><li>若处于执行状态，终止该进程的执行，并置调度标志为真，重新调度。</li><li>若有子孙进程，将所有子孙进程终止。</li><li>将进程全部资源归还其父进程或系统：释放内外存空间、关闭所有打开文件、释放当前</li><li>目录、释放共享内存段和各种锁定lock。</li><li>将其PCB从所在队列（或链表）中移出 </li></ul><h5 id="unix进程终止过程"><a href="#unix进程终止过程" class="headerlink" title="unix进程终止过程"></a>unix进程终止过程</h5><ul><li><p>进程执行完最后一条语句，请求操作系统删除进程(通过执行exit系统调用)。</p><ul><li>将子进程运行数据传递给父进程（通过 wait系统调用)。</li><li>回收的系统资源由操作系统再另行分配</li></ul></li><li><p>父进程也可以终止子进程的执行（通过abort系统调用)。原因：</p><ul><li>子进程超额使用资源.</li><li>分配给子进程执行的任务不再需要执行.</li><li>父进程退出。<ul><li>如果父进程终止，操作系统不再允许子进程继续执行。</li></ul></li></ul></li></ul><h4 id="2-2-3-进程的阻塞与唤醒"><a href="#2-2-3-进程的阻塞与唤醒" class="headerlink" title="2.2.3 进程的阻塞与唤醒"></a>2.2.3 进程的阻塞与唤醒</h4><p>$$<br>\begin{equation}<br>引起阻塞和唤醒的事件\begin{cases}<br>请求系统服务\<br>启动某种操作\<br>新数据尚未到\<br>无新工作可做<br>\end{cases}<br>\end{equation}<br>$$</p><h5 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h5><ul><li>正在执行的进程，发生上述事件时，自身调用有关阻塞原语，进入等待队列。进程的主动性行为。</li><li>进程由运行态变为阻塞态</li><li>引起处理机调度。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-3.jpg" alt></p><h5 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h5><ul><li>唤醒原因：等待的事件到达。</li><li>由阻塞队列转入就绪队列。进程由阻塞态变为就绪态.</li><li>方法：其他有关进程（例如用完并释放了该I/O设备的进程）发送信号到某个或一组进程。</li></ul><p><img src="/2020/08/14/OS-ch-2/2.2-4.jpg" alt></p><p><strong>BLOCK和WAKEUP是一队作用相反的原语。</strong><br>如果在某进程中调用了<font color="red">阻塞原语</font>，则必须在与之相合作的另一进程中或其他相关的进程中，安排<font color="red">唤醒原语</font>，以能唤醒阻塞进程；否则，被阻塞进程将会因不能被唤醒而长久地处于阻塞状态，从而再无机会继续运行。</p><h4 id="2-2-4-进程的挂起与激活"><a href="#2-2-4-进程的挂起与激活" class="headerlink" title="2.2.4 进程的挂起与激活"></a>2.2.4 进程的挂起与激活</h4><h5 id="挂起引入原因："><a href="#挂起引入原因：" class="headerlink" title="挂起引入原因："></a>挂起引入原因：</h5><ul><li><p><font color="red">终端用户请求</font></p><ul><li>终端用户发现自己运行的程序有问题，希望暂停自己程序的执行</li></ul></li><li><p><font color="red">父进程请求</font></p><ul><li>父进程希望挂起自己的某个子进程，以便考察和修改该子进程</li></ul></li><li><p><font color="red">负荷调节需要</font></p><ul><li>高优先级的进程要执行，而内存不空，系统将低优先级进程对换至外存。</li><li>提高处理机效率：就绪进程表为空时，要提交新进程，而此时内存不空，需挂起阻塞态的进程</li><li>为运行进程提供足够内存（对换及调整负荷）：资源紧张时，暂停某些进程，如：实时任务执行，而内存紧张。</li></ul></li><li><p><font color="red">操作系统的需要</font></p><ul><li>操作系统需要挂起某些进程以便检查运行中的资源使用情况或进行记账</li></ul></li></ul><h5 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h5><ul><li>目的：合理且充分地利用系统资源。进程在挂起状态时，进程没有占用内存空间，仅映像在磁盘上。</li><li>执行过程：挂起原语：SUSPEND（）</li><li>挂起原语的执行过程：<ul><li>从内存调到外存，改变进程的状态。</li><li>若处于活动就绪状态，改为静止就绪；</li><li>若处于活动阻塞状态，则改为静止阻塞；</li><li>若正在执行，则转向调度程序重新调度。</li></ul></li></ul><h5 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h5><ul><li>原因：父进程或用户进程请求，或内存已有足够空间</li><li>执行过程：从外存调入内存，改变进程的状态</li><li>可能也会引起处理机调度</li></ul><h5 id="挂起引起的状态转变"><a href="#挂起引起的状态转变" class="headerlink" title="挂起引起的状态转变"></a>挂起引起的状态转变</h5><p><img src="/2020/08/14/OS-ch-2/2.2-5.jpg" alt></p><ul><li>引入的新状态<ul><li>就绪挂起（静止就绪）：进程在外存，但只要进入内存，即可运行；</li><li>阻塞挂起状态（静止阻塞）：进程在外存并等待某事件的出现。</li></ul></li></ul><h5 id="有挂起状态的进程状态图"><a href="#有挂起状态的进程状态图" class="headerlink" title="有挂起状态的进程状态图"></a>有挂起状态的进程状态图</h5><p><img src="/2020/08/14/OS-ch-2/2.2-6.jpg" alt></p><h5 id="创建和终止状态"><a href="#创建和终止状态" class="headerlink" title="创建和终止状态"></a>创建和终止状态</h5><p><img src="/2020/08/14/OS-ch-2/2.2-7.jpg" alt></p><h5 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h5><p>由于多进程在系统中的并发执行，进程之间存在2种制约关系：<br><font color="red">间接制约</font>:进程间由于共享某种系统资源，而形成的相互制约。</p><p><code>进程A-&gt;资源-&gt;进程B</code></p><p><font color="red">直接制约</font>：进程间由于合作而形成的相互制约</p><p><code>进程A------&gt;进程B</code></p><h5 id="进程的两大关系"><a href="#进程的两大关系" class="headerlink" title="进程的两大关系"></a>进程的两大关系</h5><h6 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h6><p><strong>由于共享资源所要求的排他性，进程间要相互竞争，以获得这些资源的使用权。</strong></p><h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p><strong>多个进程中发生的事件存在某种时序关系，必须协同工作、相互配合，以共同完成一项任务。</strong></p><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h3><p>进程并发地对共享数据的访问有可能引起数据的不一致性。<br>为了维持数据的一致性，必须有一种机制来保证协作进程之间按某种正确的次序执行。</p><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><ul><li>临界资源：硬件或软件（如外设、共享代码段、共享数据结构），多个进程在对其进行访问时（关键是进行写入或修改），必须互斥地进行。</li><li>有些共享资源可以同时访问，如只读数据。因而不是临界资源。</li></ul><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><ul><li><p><font color="red">临界区(critical section)</font>：在每个进程中，访问临界资源的一段代码。</p><ul><li><strong>临界区问题－－确保一个进程在执行它的临界区代码时，不允许其他进程再进入他们各自的临界区内执行代码</strong>。</li></ul></li><li><p><font color="red">进入区(entry section)</font>：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应“正在访问临界区”标志</p></li><li><p><font color="red">退出区(exit section)</font>：位于临界区的后面，用于将“正在访问临界区”标志清除。</p></li><li><p><font color="red">剩余区(remainder section)</font>：代码中的其余部分。</p></li></ul><h5 id="访问临界区的循环进程描述"><a href="#访问临界区的循环进程描述" class="headerlink" title="访问临界区的循环进程描述"></a>访问临界区的循环进程描述</h5><p><img src="/2020/08/14/OS-ch-2/2.3-1.jpg" alt></p><ul><li><p>当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理及调度的。比如，通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机是，不能处理机调度，那么系统的性能将非常低。</p></li><li><p>不适合处理机调度的情况：</p><ul><li>在处理中断的过程中</li><li>进程在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li></ul><h5 id="同步机制应遵循的准则："><a href="#同步机制应遵循的准则：" class="headerlink" title="同步机制应遵循的准则："></a>同步机制应遵循的准则：</h5><ul><li>空闲则入：其他进程均不处于临界区，应允许请求进入临界区的进程进入；</li><li>忙则等待：已有进程处于其临界区，请求进入临界区的进程应等待；</li><li>有限等待：等待进入临界区的进程不能“死等”；</li><li>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li></ul><h5 id="解决临界区问题的算法"><a href="#解决临界区问题的算法" class="headerlink" title="解决临界区问题的算法"></a>解决临界区问题的算法</h5><p><img src="/2020/08/14/OS-ch-2/2.3-2.jpg" alt></p><h4 id="2-3-3-信号量机制"><a href="#2-3-3-信号量机制" class="headerlink" title="2.3.3 信号量机制"></a>2.3.3 信号量机制</h4><ul><li>信号量是OS提供的管理公有资源的有效手段。</li><li>整型信号量或记录型信号量可以代表可用资源实体的数量。</li></ul><h5 id="1-整型信号量机制"><a href="#1-整型信号量机制" class="headerlink" title="1.整型信号量机制"></a>1.整型信号量机制</h5><ul><li>1965年，荷兰学者Dijkstra提出（所以P、V分别是荷兰语的test(proberen)和increment(verhogen)），是一种卓有成效的进程同步机制。</li><li>最初Dijkstra把信号量定义为整型量s和两个原子操作（除初始化操作）：P和V, 现又称为：wait和signal。</li></ul><h5 id="2-记录型信号量机制"><a href="#2-记录型信号量机制" class="headerlink" title="2.记录型信号量机制"></a>2.记录型信号量机制</h5><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">process</span> *<span class="title">queue</span>;</span> </span><br><span class="line">        &#125; semaphore;</span><br></pre></td></tr></table></figure><p>每个信号量s<br>一个整数值s.count：其初值表示某类资源的数目（又称为“资源信号量”)<br>一个进程等待队列s.queue，是阻塞在该信号量的各个进程的PCB链成的队列。</p><p><img src="/2020/08/14/OS-ch-2/2.3-3.jpg" alt></p><p>信号量只能通过初始化和两个标准的原语（wait、signal）来访问－－作为OS核心代码执行，不受进程调度的打断。</p><p><img src="/2020/08/14/OS-ch-2/2.3-4.jpg" alt></p><h5 id="3-AND型信号量"><a href="#3-AND型信号量" class="headerlink" title="3.AND型信号量"></a>3.AND型信号量</h5><p>基本思想：将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放。</p><p><img src="/2020/08/14/OS-ch-2/2.3-5.jpg" alt></p><h5 id="4-二进制（Binary-）信号量"><a href="#4-二进制（Binary-）信号量" class="headerlink" title="4.二进制（Binary ）信号量"></a>4.二进制（Binary ）信号量</h5><ul><li>其值只能是 0和 1；易于实现。</li><li>利用二进制信号量可以实现整型信号量。</li><li>数据结构：<pre><code>二进制信号量 S1, S2;  int C:  </code></pre></li><li>初值：<pre><code>S1 = 1  S2 = 0  C = 代表共享资源的初始值</code></pre></li></ul><p><img src="/2020/08/14/OS-ch-2/2.3-6.jpg" alt></p><h4 id="2-3-4-信号量的应用"><a href="#2-3-4-信号量的应用" class="headerlink" title="2.3.4 信号量的应用"></a>2.3.4 信号量的应用</h4><ol><li><h5 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h5><ul><li>为临界资源设置一个互斥信号量mutex，其初值为1；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;   </span><br><span class="line"> …</span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">             …</span><br><span class="line">               wait ( mutex );</span><br><span class="line">               critical section</span><br><span class="line">              signal( mutex );</span><br><span class="line">              remaider section</span><br><span class="line">           &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h5></li></ol><ul><li><p>前趋关系：并发执行的进程P1和P2中，分别有代码C1和C2，要求C1在C2开始前完成；</p><ul><li><p>为每个前趋关系设置一个互斥信号量S12，其初值为0</p></li><li><p>P1:                      P2:</p><p>C1;                      wait(s12);<br>signal(s12)          C2；</p></li></ul></li></ul><h3 id="2-4-经典的进程同步问题"><a href="#2-4-经典的进程同步问题" class="headerlink" title="2.4 经典的进程同步问题"></a>2.4 经典的进程同步问题</h3><h4 id="2-4-1-生产者消费者问题"><a href="#2-4-1-生产者消费者问题" class="headerlink" title="2.4.1 生产者消费者问题"></a>2.4.1 生产者消费者问题</h4><h5 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1) 问题描述："></a>1) 问题描述：</h5><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p><h5 id="2）制约关系："><a href="#2）制约关系：" class="headerlink" title="2）制约关系："></a>2）制约关系：</h5><p>生产者与消费者之间不直接发生联系，他们通过缓冲区发生制约关系<br>生产者生产商品，若缓冲区已满生产者等待，直到缓冲区有空为止<br>消费者在缓冲区空时等待，直到生产者的商品放入。否则，取一个商品消费。<br>注意：缓冲区为循环缓冲区</p><h5 id="3）问题分析"><a href="#3）问题分析" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><p>采用信号量机制，定义两个资源信号量<br>full是缓冲池“满”数目，初值为0，empty是缓冲池“空”数目，初值为N。实际上，full和empty是同一个含义：<br>           full + empty == N<br>只要缓冲池未满empty&gt;0，生产者便可将消息送入缓冲池；<br>只要缓冲池未空full&gt;0，消费者便可从缓冲池取走一个消息。 </p><h5 id="4）问题解答"><a href="#4）问题解答" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p><img src="/2020/08/14/OS-ch-2/2.4-1.jpg" alt></p><h5 id="5）问题扩充"><a href="#5）问题扩充" class="headerlink" title="5）问题扩充"></a>5）问题扩充</h5><p>若生产者与消费者变成多对多关系，我们要做什么变动？<br>增加互斥信号量: mutex=1;</p><p><img src="/2020/08/14/OS-ch-2/2.4-2.jpg" alt></p><h5 id="6）注意："><a href="#6）注意：" class="headerlink" title="6）注意："></a>6）注意：</h5><ul><li>每个程序中互斥的wait(mutex)和signal(mutex)必须成对出现。</li><li>对资源信号量empty和full的wait 、signal操作成对出现，但它们分别处于不同的程序中。例如wait在计算进程中，而signal则在打印进程中，计算进程若因执行wait而阻塞，则以后将由打印进程将它唤醒。</li><li>每个程序中的wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。</li></ul><h4 id="2-4-2-读者写者问题"><a href="#2-4-2-读者写者问题" class="headerlink" title="2.4.2 读者写者问题"></a>2.4.2 读者写者问题</h4><h5 id="1）问题描述"><a href="#1）问题描述" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><ul><li>一个数据文件或记录可被多个进程共享。其中，有些进程要求读；而另一些进程要求行写或修改。</li><li>只要求读的进程称为“Reader进程”，其它进程称为“Writer进程”。</li></ul><h5 id="2）制约关系"><a href="#2）制约关系" class="headerlink" title="2）制约关系"></a>2）制约关系</h5><ul><li>任一时刻“写者”最多只允许一个，而“读者”则允许多个――“读－写”互斥，“写－写”互斥，“读－读”允许。</li><li>所谓读者一写者问题是指保证一个Writer进程必须与其它进程互斥地访问共享对象的同步问题。</li></ul><h5 id="3）问题分析-1"><a href="#3）问题分析-1" class="headerlink" title="3）问题分析"></a>3）问题分析</h5><ul><li><p>读者优先的解决方案：</p><ul><li>互斥信号量wrt，初值是1，代表一个共享文件。为解决“读－写”互斥，“写－写”互斥。</li><li>一个记数器，即整型变量readcount，记录读者数，初值是0。<ul><li>来一个读者， readcount加1</li><li>当readcount ＝1表示是第一个读者， 则需要执行p操作抢占文件；否则表示已有读者在安全的读数据。</li><li>走一个读者，readcount减1</li><li>当readcount ＝0表示是最后一个读者，则需要v操作释放资源；否则表示还有读者在读数据。</li></ul></li><li>readcount 为多个读者共享的变量，是临界资源。用互斥信号量mutex控制, mutex初值是1。</li></ul></li><li><p>写者优先：</p><ul><li>当一个写进程声明想写时，不允许新的读进程访问该数据区。</li></ul></li><li><p>解决方案：</p><ul><li>增加信号量r，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。</li><li>一个记数器，即整型变量writecount，记录写者数，初值是0。</li><li>writecount为多个写者共享的变量，是临界资源。用互斥信号量mutex2控制, mutex2初值是1。</li><li>增加mutex3，初值是1：在r上不允许建造长队列，否则写进程将不能跳过这个队列，因此，只允许一个读进程在r上排队，而所有其他读进程在等待r之前，在信号量mutex3上排队。</li></ul></li></ul><h5 id="4）问题解答-1"><a href="#4）问题解答-1" class="headerlink" title="4）问题解答"></a>4）问题解答</h5><p>读者优先方式：</p><p><img src="/2020/08/14/OS-ch-2/2.4-3.jpg" alt></p><p>写者优先方式：<br><img src="/2020/08/14/OS-ch-2/2.4-4.jpg" alt></p><h4 id="2-4-3-哲学家进餐问题"><a href="#2-4-3-哲学家进餐问题" class="headerlink" title="2.4.3 哲学家进餐问题"></a>2.4.3 哲学家进餐问题</h4><h5 id="1）问题描述-1"><a href="#1）问题描述-1" class="headerlink" title="1）问题描述"></a>1）问题描述</h5><p>（由Dijkstra首先提出并解决）</p><ul><li>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</li><li>哲学家的动作包括思考和进餐：<ul><li>进餐时需要同时拿起他左边和右边的两支筷子，</li><li>思考时则同时将两支筷子放回原处。</li></ul></li></ul><h5 id="2）问题分析"><a href="#2）问题分析" class="headerlink" title="2）问题分析"></a>2）问题分析</h5><ul><li>哲学家逆时针编号0-4，筷子也相应编号</li><li>定义互斥信号量数组chopstick[5], 对应5支筷子，初值均为1。</li></ul><p>死锁问题的解决方法：</p><p><img src="/2020/08/14/OS-ch-2/2.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-6.jpg" alt></p><p><img src="/2020/08/14/OS-ch-2/2.4-7.jpg" alt></p><h3 id="2-5-管程"><a href="#2-5-管程" class="headerlink" title="2.5 管程"></a>2.5 管程</h3><h4 id="2-5-1-管程的基本概念"><a href="#2-5-1-管程的基本概念" class="headerlink" title="2.5.1 管程的基本概念"></a>2.5.1 管程的基本概念</h4><ul><li>利用信号量实现进程同步，使大量的同步操作分散在各个进程中。使系统管理麻烦，同步操作使用不当会引起死锁。</li><li>引入新的进程同步工具－－－管程（Monitors)</li><li>目的：分离互斥和条件同步的关注</li></ul><h5 id="管程由四部分组成："><a href="#管程由四部分组成：" class="headerlink" title="管程由四部分组成："></a>管程由四部分组成：</h5><ul><li><p>管程的名称</p></li><li><p>局部于管程的共享变量说明</p></li><li><p>对该数据结构进行操作的一组过程</p></li><li><p>对管程中数据设置初值的语句</p></li></ul><p>任何管程外的过程都不能访问管程内的数据结构。管程相当于围墙，将共享变量和对它进行操作的若干过程围了起来，进程只要访问临界资源就必须通过管程。</p><p>管程每次只允许一个进程进入管程，实现了互斥。</p><p>使用信号量的效率比管程高。</p><p>管程结构在一些程序设计语言中得到实现。如并发Pascal和Java，C#等，它还被作为一个程序库实现。</p><h3 id="2-6-进程之间的通信"><a href="#2-6-进程之间的通信" class="headerlink" title="2.6 进程之间的通信"></a>2.6 进程之间的通信</h3><p>进程通信时指进程之间的信息交换，所交换的信息量，少者是一个状态，多者是成千上万字节。</p><h4 id="进程通信分类："><a href="#进程通信分类：" class="headerlink" title="进程通信分类："></a>进程通信分类：</h4><h5 id="低级通信："><a href="#低级通信：" class="headerlink" title="低级通信："></a>低级通信：</h5><p>只能传递状态和整数值（控制信息）包括进程互斥和同步所采用的信号量和管程机制。</p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>传送信息量小，效率低，每次通信传输的信息量固定，传递较多信息需要多次通信。</p><p>编程复杂：用户直接实现通信的细节，容易出错。</p><h5 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h5><p>利用复杂的特定数据结构进行大信息量的通信。通信效率高。包括：</p><ul><li>共享存储器系统<ul><li>互相通信的进程共享某些数据结构或存储区，进程之间通过这些空间进行通信。分两类。<ul><li>共享数据结构：如缓冲区<ul><li>公用数据结构的设置及进程间同步的处理由程序员负责，OS只提供共享存储器</li><li>通信效率低，只适合少量数据</li></ul></li><li>共享存储区：为传递大量数据在存储器中划出一片共享存储区<ul><li>进程通信前，先向系统申请获得存储区的一个分区，并指定关键字；若系统已经给其他进程分配分区，则把该分区的描述符返回给申请者，申请者将获得的共享存储区连接到本进程上；此后可像读写普通存储器一样读写公用存储区。</li></ul></li></ul></li></ul></li><li>消息传递系统<ul><li>程序员利用OS提供的系统原语进行通信。简化通信程序编制</li></ul></li><li>管道通信系统<ul><li>利用读进程写进程实现通信的共享文件–pipe文件</li><li>写进程用字符流输入大流量数据送入管道，读进程接收数据</li><li>要求：<ul><li>互斥</li><li>同步</li><li>对方存在</li></ul></li></ul></li></ul><h4 id="消息传递实现方式："><a href="#消息传递实现方式：" class="headerlink" title="消息传递实现方式："></a>消息传递实现方式：</h4><h5 id="直接通信："><a href="#直接通信：" class="headerlink" title="直接通信："></a>直接通信：</h5><ul><li><p>利用OS提供的发送命令将消息发送到目标进程</p></li><li><p>发送进程和接收进程都以显示方式提供对方标识符。</p></li></ul><h5 id="间接通信："><a href="#间接通信：" class="headerlink" title="间接通信："></a>间接通信：</h5><p>利用双方之外的共享数据结构作为通信中转。（信箱）</p><p>信箱分为3类：</p><ul><li>私用信箱：用户自己创建，其他用户只能发送信息</li><li>公用信箱：OS创建，符合要求的进程都可以发消息</li><li>共享信箱：进程创建</li></ul><h3 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h3><p>线程：更小的能独立运行的单位。是进程当中执行的一条流程</p><p>引入线程是为了提高系统内程序的并发程度，提高系统效率增大作业吞吐量。</p><p>提出原因：进程开销过大，建立销毁执行效率不高。</p><p>需要满足特性：</p><ul><li>实体之间可以并发执行</li><li>实体之间共享相同的地址空间</li></ul><h4 id="线程的属性："><a href="#线程的属性：" class="headerlink" title="线程的属性："></a>线程的属性：</h4><ul><li><p>共享进程资源：一个进程的所有线程具有相同的地址空间，可以访问进程拥有的资源</p></li><li><p>轻型实体：</p><ul><li>只有少数资源<ul><li>线程标识符</li><li>线程控制块TCB</li><li>核心栈</li><li>私有存储区</li></ul></li></ul></li><li><p>线程是处理机调度的单位</p></li><li><p>可并发执行</p></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>一个进程中可以同时存在多个线程；</li><li>各个线程之间可以并发地执行；</li><li>线程的创建和终止时间比进程短；</li><li>各个线程之间可以共享内存和文件资源，因此可进行直接通信而不需要通过OS的内核。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li></ul><h4 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h4><p><img src="/2020/08/14/OS-ch-2/2.7-1.jpg" alt></p><h4 id="OS对线程的支持"><a href="#OS对线程的支持" class="headerlink" title="OS对线程的支持"></a>OS对线程的支持</h4><p>1.用户级线程：</p><ul><li>仅存在与用户空间中，内核不了解。</li><li>用线程库函数来控制</li><li>一个线程阻塞，整个进程都要等待</li><li>时间片分配给进程，线程执行时间相对较短</li></ul><p>2.内核线程</p><ul><li>OS支持，创建撤销切换都由内核实现</li><li>创建管理慢于用户级线程</li><li>能在多处理机并行，一个线程阻塞整个进程不阻塞</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>多对一</p><ul><li>多个用户级对一个内核</li><li>线程管理在用户空间进行，效率高</li><li>一个线程阻塞，整个进程阻塞</li></ul><p>一对一</p><ul><li>每个用户级线程都对应一个内核线程。</li><li>如果一个线程执行了阻塞系统调用，能允许另一个线程继续执行</li><li>缺点：创建内核线程的开销会影响应用程序的性能，限制系统所支持的线程数量。</li></ul><p>多对多</p><ul><li>用户线程数&gt;=内核数，与特定程序机器有关</li><li>允许系统根据资源分配创建内核进程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二章-进程管理&quot;&gt;&lt;a href=&quot;#第二章-进程管理&quot; class=&quot;headerlink&quot; title=&quot;第二章 进程管理&quot;&gt;&lt;/a&gt;第二章 进程管理&lt;/h2&gt;&lt;p&gt;为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进
      
    
    </summary>
    
    
    
      <category term="-操作系统 -OS -ch2" scheme="http://yokeso.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-OS-ch2/"/>
    
  </entry>
  
  <entry>
    <title>OS_ch_1</title>
    <link href="http://yokeso.top/2020/08/14/OS-ch-1/"/>
    <id>http://yokeso.top/2020/08/14/OS-ch-1/</id>
    <published>2020-08-14T07:00:18.000Z</published>
    <updated>2020-08-14T13:15:39.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统知识点梳理"><a href="#操作系统知识点梳理" class="headerlink" title="操作系统知识点梳理"></a>操作系统知识点梳理</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/2020/08/14/OS-ch-1/1.1-1.jpg" alt="####"></p><h5 id="地位与目标："><a href="#地位与目标：" class="headerlink" title="地位与目标："></a>地位与目标：</h5><h6 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h6><p>紧贴系统硬件之上，所有其他软件之下，（是其他软件的共同环境）</p><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><ul><li><p><strong>有效性</strong>（系统管理人员的观点）：管理和分配硬件、软件资源，合理地组织计算机的工作流程</p></li><li><p><strong>方便性</strong>（用户的观点）：提供良好的、一致的用户接口，弥补硬件系统的类型和数量差别</p></li><li><p><strong>可扩充性</strong>（开放的观点）：硬件的类型和规模、操作系统本身的功能和管理策略、多个系统之间的资源共享和互操作</p></li></ul><h5 id="操作系统的定义：（没有公认的定义）"><a href="#操作系统的定义：（没有公认的定义）" class="headerlink" title="操作系统的定义：（没有公认的定义）"></a>操作系统的定义：（没有公认的定义）</h5><ul><li>是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充</li><li>是一组控制和管理计算机硬件和软件资源，方便用户使用的程序集合<ul><li>控制程序执行以防错误和不当使用</li><li>执行用户程序并提供服务</li><li>管理各种计算机资源：CPU、硬盘、内存、硬件外设等</li><li>有效解决冲突请求并确保资源公平使用</li></ul></li></ul><h5 id="几种观点"><a href="#几种观点" class="headerlink" title="几种观点"></a>几种观点</h5><ol><li>OS是计算机硬件软件的管理者</li><li>OS是用户使用系统的接口</li><li>OS是扩展机/虚拟机<ul><li>在裸机上添加：设备管理，文件管理、存储管理（外存&amp;内存）、处理机管理</li></ul></li></ol><h4 id="1-2操作系统的发展历史"><a href="#1-2操作系统的发展历史" class="headerlink" title="1.2操作系统的发展历史"></a>1.2操作系统的发展历史</h4><h5 id="人工操作系统"><a href="#人工操作系统" class="headerlink" title="人工操作系统"></a>人工操作系统</h5><p><strong>1946-50年代</strong>，（电子管）集中计算（计算中心），计算机资源昂贵</p><p>人工操作特点：</p><ul><li>用户独占全机</li><li>CPU等待人工操作</li><li>串行性</li></ul><p>缺点：</p><ul><li>昂贵组件的低利用效率</li><li>利用率 = 执行时间/（执行时间+读卡时间）</li></ul><h5 id="单道批处理系统："><a href="#单道批处理系统：" class="headerlink" title="单道批处理系统："></a>单道批处理系统：</h5><p><strong>50年代末-60年代中</strong>(晶体管)利用磁带把若干个作业分类编成作业执行序列，每个批作业由一个专门的监督程序（Monitor）自动依次处理。可使用汇编语言开发。</p><p><img src="/2020/08/14/OS-ch-1/1.2-1.jpg" alt></p><p>特征：</p><ul><li>自动性</li><li>顺序性</li><li>单道性</li></ul><p>优点：</p><ul><li>同一批内各作业的自动依次更替，改善了主机CPU和I/O设备的使用效率提高了吞吐量。</li></ul><p>缺点：</p><ul><li><p>内存中仅有一道程序运行，当该程序运行结束或出故障，由监控程序换入另一个程序。不能很好地利用系统资源。</p></li><li><p><strong>CPU</strong>和I/O设备使用忙闲不均（取决于当前作业的特性）。对计算为主的作业，外设空闲；对I/O为主的作业，CPU空闲。</p></li></ul><p><strong>单道批处理系统是最早出现的一种OS,严格来说只能算是OS的前身而不是现在理解的OS，但该系统比起人工操作的系统已经有很大的进步</strong></p><h5 id="多道批处理系统："><a href="#多道批处理系统：" class="headerlink" title="多道批处理系统："></a>多道批处理系统：</h5><p><strong>60年代中~70年代中</strong>（集成电路）利用多到批处理提高资源的利用率。</p><p><img src="/2020/08/14/OS-ch-1/1.2-2.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.2-3.jpg" alt="多道批处理特点以及优缺点"></p><p>多道程序系统的技术问题：</p><ul><li>并行程序的运行需要共享软硬件资源，需要同步和互斥机制。</li><li>多道程序需要提高内存使用效率，需要覆盖技术，交互技术，虚拟存储等技术。</li><li>多道程序在内存中要保证系统存储区和用户存储区安全可靠，需要内存保护。.   </li></ul><h5 id="分时系统："><a href="#分时系统：" class="headerlink" title="分时系统："></a>分时系统：</h5><p><strong>70年代中期至今</strong>    </p><p>多个用户分享使用同一台计算机。每个用户给一定的时间运行，然后切换到另一用户，一个轮转周期在宏观上相当短，用户感觉不到。</p><p><img src="/2020/08/14/OS-ch-1/1.2-4.jpg" alt></p><p>分时系统特征：</p><ul><li>交互性：用户与系统进行人机对话</li><li>多路性：多用户同时在各自终端上使用同一CPU</li><li>独立性：用户可彼此独立操作，互不干扰，互不混淆。</li><li>及时性：用户在短时间内可以得到系统的及时回答。</li></ul><p>影响响应时间的因素：</p><ul><li>终端数目的多少</li><li>时间片的大小</li><li>信息交换量</li><li>信息交换速度</li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理。并控制所有事实任务协调一致的运行。</p></li><li><p>保证实时性和高可靠性，对系统的效率放在第二位。</p></li></ul><p>分类：实施控制系统，实时信息处理系统。</p><h5 id="实时系统与分时系统的比较"><a href="#实时系统与分时系统的比较" class="headerlink" title="实时系统与分时系统的比较"></a>实时系统与分时系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-5.jpg" alt></p><h5 id="多处理操作系统："><a href="#多处理操作系统：" class="headerlink" title="多处理操作系统："></a>多处理操作系统：</h5><p><img src="/2020/08/14/OS-ch-1/1.2-6.jpg" alt></p><h5 id="并行系统的类型："><a href="#并行系统的类型：" class="headerlink" title="并行系统的类型："></a>并行系统的类型：</h5><p>非对称式多重处理</p><p>对称式多重处理</p><h5 id="分布式操作系统与网络操作系统的比较"><a href="#分布式操作系统与网络操作系统的比较" class="headerlink" title="分布式操作系统与网络操作系统的比较"></a>分布式操作系统与网络操作系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-7.jpg" alt></p><h4 id="1-3-操作系统的特征和服务"><a href="#1-3-操作系统的特征和服务" class="headerlink" title="1.3 操作系统的特征和服务"></a>1.3 操作系统的特征和服务</h4><h5 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h5><ul><li><p><strong>并发</strong>：多个事件在同一时间段内发生，（并行是指单处理器下宏观上并发微观上交替执行）</p></li><li><p><strong>共享</strong>：多个进程共享有限的计算机资源，操作系统要对系统资源进行合理的分配和使用，资源在一个时间段内交替被多个进程使用。</p><hr><p>并发和共享是操作系统两个最基本特征，这两者之间是互为存在条件的</p><hr></li><li><p><strong>虚拟</strong>：一个物理实体映射为若干对应逻辑实体–分时或分空间，虚拟是操作系统管理系统资源的重要手段，提高资源利用率。</p></li><li><p><strong>异步</strong>：也称不确定性，指进程的执行顺序和执行时间的不确定性</p><ul><li>进程的运行速度不可预知</li><li>判据：无论快慢，应该结果相通–通过进程互斥和同步手段来保证。</li><li>难以重现系统在某个时刻的状态（包括重现运行中的错误）</li><li>性能保证：实时系统与分时系统类似，但通过资源预留以保证性能。</li></ul></li></ul><h5 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h5><p>1 管理模块：针对不同管理对象的程序模块（操作系统核心）</p><p>2.用户接口：shell,窗口系统</p><h4 id="1-4-操作系统功能"><a href="#1-4-操作系统功能" class="headerlink" title="1.4 操作系统功能"></a>1.4 操作系统功能</h4><h5 id="1-4-1-存储管理"><a href="#1-4-1-存储管理" class="headerlink" title="1.4.1 存储管理"></a>1.4.1 存储管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-1.jpg" alt></p><h5 id="1-4-2-处理机管理"><a href="#1-4-2-处理机管理" class="headerlink" title="1.4.2 处理机管理"></a>1.4.2 处理机管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-2.jpg" alt></p><h5 id="1-4-3-设备管理"><a href="#1-4-3-设备管理" class="headerlink" title="1.4.3 设备管理"></a>1.4.3 设备管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-3.jpg" alt></p><h5 id="1-4-4-文件管理"><a href="#1-4-4-文件管理" class="headerlink" title="1.4.4 文件管理"></a>1.4.4 文件管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-4.jpg" alt></p><h5 id="1-4-5-用户接口"><a href="#1-4-5-用户接口" class="headerlink" title="1.4.5 用户接口"></a>1.4.5 用户接口</h5><p>目标：提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供给用户。</p><p>命令接口：为联机用户提供的，由一组键盘操作命令及命令解释程序所组成，又分联机和脱机用户接口。</p><p>程序接口：为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的路径。它由一组系统调用组成。</p><p>图形接口：用户可用鼠标或菜单和对话框来完成对应应用程序和文件的操作。</p><h5 id="双模式操作"><a href="#双模式操作" class="headerlink" title="双模式操作"></a>双模式操作</h5><h6 id="用户模式（目态）"><a href="#用户模式（目态）" class="headerlink" title="用户模式（目态）"></a>用户模式（目态）</h6><p>执行普通用户的应用程序</p><h6 id="系统模式（管态）"><a href="#系统模式（管态）" class="headerlink" title="系统模式（管态）"></a>系统模式（管态）</h6><p>执行操作系统核心代码</p><h6 id="分辨方式："><a href="#分辨方式：" class="headerlink" title="分辨方式："></a>分辨方式：</h6><p>在程序状态字中添加模式位指示目前所处模式：系统态(0)或用户态(1)</p><p>发生中断或故障（自陷）<font color="red">硬件</font>自动从用户态切换到系统态</p><p>当用户程序需要操作系统的服务（通过系统调用）必须由管态切换到目态。</p><p><img src="/2020/08/14/OS-ch-1/1.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.4-6.jpg" alt></p><h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex1.jpg" alt="1."></p><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex2.jpg" alt="1."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统知识点梳理&quot;&gt;&lt;a href=&quot;#操作系统知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;操作系统知识点梳理&quot;&gt;&lt;/a&gt;操作系统知识点梳理&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是操作系统&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Ch.3</title>
    <link href="http://yokeso.top/2020/07/26/CSAPP-Ch-3/"/>
    <id>http://yokeso.top/2020/07/26/CSAPP-Ch-3/</id>
    <published>2020-07-26T09:07:46.000Z</published>
    <updated>2020-08-14T13:16:51.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP第三章"><a href="#CSAPP第三章" class="headerlink" title="CSAPP第三章"></a>CSAPP第三章</h2><h3 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h3><h4 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h4><p>Intel &amp; AMD</p><h4 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>gcc</strong>： Linux上默认的编译器</p></li><li><p><strong>-Og</strong>:   编译选项，告诉编译器使用会生成符合原始C代码整体结构的机器代码编译优化等级</p></li></ul><h5 id="gcc命令调用过程"><a href="#gcc命令调用过程" class="headerlink" title="gcc命令调用过程"></a>gcc命令调用过程</h5><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgcc%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="gcc命令调用过程"></p><p>用图片的形式描述一下就是这样的：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgccppt.jpg" alt="gccppt"></p><h5 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h5><ul><li><strong>机器级编程的两种抽象</strong><ul><li>指令集体系结构或指令集架构（Instruction Set Architexture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态，指令格式以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看起来像一个非常大的数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li></ul></li></ul><h5 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h5><p>以C代码文件<code>mstore.c</code>为例，在命令行上使用<code>-S</code>选项，可以看到C语言编译产生的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure><p>这时GCC会运行编译器，产生汇编文件<code>mstore.s</code>但是不做进一步操作</p><p>如果用  <code>-c</code>命令行选项GCC会编译并汇编该代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure><p>这样就会产生目标代码文件<code>mstore.o</code>它是二进制格式的，无法直接进行查看,想要查看机器代码的内容，可以通过<code>反汇编器(disassembler)</code>进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d mstore.o</span></span><br></pre></td></tr></table></figure><p>机器代码以及反汇编表示的特性：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E7%89%B9%E6%80%A7.jpg" alt="机器代码以及反汇编表示的特性"></p><h5 id="3-2-3-关于格式的注释"><a href="#3-2-3-关于格式的注释" class="headerlink" title="3.2.3 关于格式的注释"></a>3.2.3 关于格式的注释</h5><p>以书上内容为例</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.jpg" alt="example"></p><p>所有以<font color="red"><code>.</code></font>开头的行都是指导汇编器和连接器工作的伪指令，我们通常可以忽略。</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.2.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h4><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.3.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h4><h5 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h5><p>大多数指令具有一个或者多个操作符，用于指示出执行一个操作中要用的源数据值以及放置结果的目的地址值。不同种操作数可能被分为三类：</p><ul><li>立即数        <ul><li>用来表示常数值</li><li>书写方式是<code>$+标准C表示法表示的整数</code>，例如：<code>$-577，$0x1F</code></li><li>不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码</li></ul></li><li>寄存器        <ul><li>表示某个寄存器中的内容，16个寄存器的低1字节、2字节、4字节和8字节中的一个作为操作数，分别对应8位、16位、32位以及64位。</li><li>用r<sub>a</sub>来表示任意寄存器ａ，用引用R[r<sub>a</sub>]来表示它的值，（将寄存器集看做数组R）</li></ul></li><li>内存引用<ul><li>根据计算出来的地址（有效地址）访问某个内存位置。</li><li>用M<sub>b</sub>[Addr]表示对存储在内存中地址Addr开始的b个字节进行引用,为了方便通常省略下标b</li></ul></li></ul><p>操作数格式标示图如下：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%A4%BA%E5%9B%BE.jpg" alt="机器代码以及反汇编表示的特性"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSAPP第三章&quot;&gt;&lt;a href=&quot;#CSAPP第三章&quot; class=&quot;headerlink&quot; title=&quot;CSAPP第三章&quot;&gt;&lt;/a&gt;CSAPP第三章&lt;/h2&gt;&lt;h3 id=&quot;程序的机器级表示&quot;&gt;&lt;a href=&quot;#程序的机器级表示&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Git个人博客搭建</title>
    <link href="http://yokeso.top/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yokeso.top/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-26T15:34:47.000Z</published>
    <updated>2020-06-27T06:44:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Git个人博客搭建（一）"><a href="#Hexo-Git个人博客搭建（一）" class="headerlink" title="Hexo+Git个人博客搭建（一）"></a>Hexo+Git个人博客搭建（一）</h1><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​    拥有一个私人博客一直都是每个<del>程序员</del>的理想，恰好赶上最近不想学习，用了一下午的时间搭建<del><strong>采坑</strong></del>了Hexo+Git个人博客搭建（主要是免费啊！！！免费啊！！）遇到的一些问题以及搭建过程进行一个记录，也希望能减少后来人的掉发量（笑）。那我们现在就开始愉快的脱发之旅吧！</p><hr><h3 id="二、Hexo简介"><a href="#二、Hexo简介" class="headerlink" title="二、Hexo简介"></a>二、Hexo简介</h3><p>​    关于Hexo，我觉得没有什么比他简介中的说法能更好的解释这个软件的话语了。</p><blockquote><p>快速、简洁且高效的博客框架</p></blockquote><p>​    速度快、一键部署、支持MarkDown、可扩展插件。。最重要的是<font color="red"><strong>开源免费</strong></font>! 大写加粗的重要啊朋友们！！！开发者是台湾人，所以<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>的官网对中文支持极度友好，对英语有怨念的同学可以在官网选择中文查阅文档以及API。</p><p>​    Hexo是基于<strong>Node.js</strong>的静态博客框架，依赖少安装容易，可以很方便的生成网页托管在GitHub上或者云上，是搭建博客的首要选择。本文采用的是网页托管到GitHub上来进行博客搭建。</p><hr><h3 id="三、安装过程"><a href="#三、安装过程" class="headerlink" title="三、安装过程"></a>三、安装过程</h3><h4 id="1-系统配置"><a href="#1-系统配置" class="headerlink" title="1.系统配置"></a>1.系统配置</h4><p>​    提及安装过程不提系统以及版本的都是流氓！首先放上我自己的系统配置：</p><blockquote><p>win10_64位教育版 A卡全家桶套餐（与安装无关不详细写了）</p><p>git –version 2.27.0.windows.1</p><p>npm –version 6.14.5</p></blockquote><p>​    由于我本身是Windows版本，所以以下的安装过程主要按照windows版本来描述，但是用Linux的小伙伴的安装过程也是大同小异（具体安装方法我也会在下面提及）。特别是安装git后使用的命令行基本和linux一样，所以系统版本就没有那么重要了</p><hr><h4 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2.Node.js安装"></a>2.Node.js安装</h4><p>​    在上文说道，Hexo是基于Node.js的，所以首先就要安装Node.js的依赖。这里我直接给出Node.Js的下载网址以及Git的安装网址以方便查阅。</p><p>​                                                                          <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener"> 点击这里安装Node.js</a></p><p>​    Node.js的安装极度简单，如果直接下载.msi文件的话只要一路next就可以安装成功。这里有问题的小伙伴请自行百度谷歌</p><h4 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3.Git安装"></a>3.Git安装</h4><p>​    下一步是Git的安装，这里一样给出git的下载网址以便下载。</p><p>​                                                                                 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">点击这里下载Git</a></p><p>​    Linux的安装方法则更加简单，以Ubuntu为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line"></span><br><span class="line">sudo apt-get install npm</span><br><span class="line"></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装后打开cmd(terminal)输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果出现了版本号，就证明你安装成功了，我的是这样的：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Git&npm.jpg" alt="我的配置"></p><p>在安装成功后就可以在Git里面敲命令行啦，比Windows本身带的cmd要好用许多。</p><h4 id="4-Hexo安装"><a href="#4-Hexo安装" class="headerlink" title="4.Hexo安装"></a>4.Hexo安装</h4><p>​    到了这里，恭喜你终于开始安装框架了，进入到了安装博客的第一步。</p><p>​    首先要在自己喜欢的位置创建一个文件夹来放你的博客，我选择的位置是D://Blog (路径习惯性的用英文可以减少不少莫名其妙的Bug)</p><p>​    在此处右键打开Git Bash，或者勤快的同学也可以从桌面cd进去</p><p>​    输入命令<code>npm install -g heso-cli</code></p><p>​    安装好后用<code>hexo -v</code>检查版本号</p><p>​    下面继续回到GIt中，初始化一下Hexo输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>​    在你选择的文件夹中应该能看到这样的文件结构（我的文件经过编译提交了，安装完后应该会比这个少几个文件）：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo.jpg" alt="我的文件"></p><p>​    在这个文件列表中，</p><ul><li><p>node_modeules 是用来存放依赖包的文件</p></li><li><p>public 是用来存放生成的页面的文件</p></li><li><p>scaffold 用来生成文章的一些模板</p></li><li><p>source文件夹用来存放你的博客文件</p></li><li><p>themes是博客的主题</p></li><li><p>_config.yml是配置文件，</p><p>在推送到Git上时我们都会用到。但这都是之后的事情啦</p><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>​        这样就可以在<code>localhost:4000</code>看到你的博客啦，但是现在的博客不仅主题不好看，而且还只是在你自己电脑上运行的，并没有部署到Git上托管。</p><p>​    既然提到了博客界面很丑陋，那我们为什么不换一个主题呢？Hexo显然也考虑到了这点，为我们提供了一个很好的下载主题的网站，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>你就可以找到一个你喜欢的博客模板进行下载了。把下载的主题直接解压放在theme文件夹里，命名为你下载的主题，在_config.yml 中修改<code>theme</code>为你下载的名称。</p><p>​    比如我应用的是名称是<code>clean</code>的一个主题。那我修改的方式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: clean</span><br></pre></td></tr></table></figure><h4 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h4><p>​    我默认你在看这篇文章之前已经有一个GItHub账户了，如果没有的话直接去注册一个也很方便。如果你已经配置过Git以及SSH可以直接跳过。</p><p>在网页的右上角选择<code>new respository</code>新建一个仓库</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitNewRes.jpg" alt="New repository"></p><p>​    输入仓库名称为<code>UserName/UserName.git.io</code></p><p>​    可能这么说会有人不理解，那我就放上一个更直白的方式：</p><p>​    我的用户名称为Yokeso ,那我创建的库名称就为<code>Yokeso/Yokeso.git.io</code>顺便附上图片希望对小白有所帮助</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/newres.jpg" alt="Repository"></p><p>​    这个名称是GitHub专门用来给用户的网站接口，每个用户只能创建一个，并且<font color="red">是免费的</font>。</p><p>回到你的GItBash下，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure><p>​    这里的yourname 是你的用户名，youremail是你注册GItHub时用的邮箱，这样GitHub才知道你是他的对应用户。</p><p>​    输入完成之后如果不放心可以用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>​    来进行检查。</p><h4 id="5-Git创建SSH"><a href="#5-Git创建SSH" class="headerlink" title="5.Git创建SSH"></a>5.Git创建SSH</h4><p>​    创建SSH同样只需要GitBash上的一个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></table></figure><p>​    如果想创建秘钥的话可以创建，但只是个人博客的话没有创建秘钥的必要，所以一路回车直接过去。</p><p>​    SSH会默认在你的/User/.ssh下创建秘钥，这里的id_rsa是这台电脑的私人秘钥，Id_rsa.pub是公钥。需要提交到GItHub上。只有秘钥公钥相互匹配是你才能顺利的传输到你的gitHub上。你可以给他直接打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后将这段代码（普遍是以ssh-rsa AAAA开头）直接复制，粘贴到个人仓库上方<code>setting</code>中的SSH目录里。这里涉及到个人隐私，所以不贴图展示了。</p><p>如果不知道是否创建成功的话，你可以直接输入以下命令进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这个代码在成功情况下回返回这样的一个结果</p><p><code>Hi Yokeso(这里是我的用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h4 id="6-将Hexo部署上去"><a href="#6-将Hexo部署上去" class="headerlink" title="6.将Hexo部署上去"></a>6.将Hexo部署上去</h4><p>​    到了这里，你已经完成一大半了，最后一步就是要将你的博客部署到GitHub上。</p><p>​    打开_config.yml，在最后你会看到一个<code>deploy</code>字段，将其修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你的账户名称&#x2F;你的账户名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​    <font color="red">千万要注意repo字段，将git上面仓库的地址直接复制过来，选择https方式，我这里在网络上没找明白，弄了好久。</font></p><p><img src="/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/https.jpg" alt="复制到repo字段"></p><p>​    在最后部署之前,先要安装<code>hexo-deployer</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nom install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li><p><code>hexo clean</code>是用来清除你之前生成的东西</p></li><li><p><code>hexo g</code>用来生成静态文章 g的全称为generate （当然可以在命令行里写hexo generate）</p></li><li><p><code>hexo d</code>用来部署文章（deploy）</p><p>过一会儿就能在http://你的注册名称.github,io上看到你的博客了！</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>​    作为智能专业的学生，很少接触网络的一些东西，这次搭建Hexo也是一时的心血来潮，想要做一些整理工作。描述下来比较简单，但在repo字段的问题上就浪费了我将近一个小时去寻找问题。同时，这也是我第一次接触markdown 以及写博客。应该有些算晚了，但对于一个工具来说，也应该没有什么早晚的区别。我也希望通过我的博客能够与大家多多交流，将自己搭建各种环境包括做各种项目时候的一些心得和大家一起分享</p><p>Code To Make World Better!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Git个人博客搭建（一）&quot;&gt;&lt;a href=&quot;#Hexo-Git个人博客搭建（一）&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Git个人博客搭建（一）&quot;&gt;&lt;/a&gt;Hexo+Git个人博客搭建（一）&lt;/h1&gt;&lt;h2 id=&quot;文章目录&quot;
      
    
    </summary>
    
    
    
      <category term="-Hexo -个人博客" scheme="http://yokeso.top/tags/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
