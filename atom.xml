<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yokeso</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-14T13:15:39.542Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BigtreeLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS_ch_1</title>
    <link href="http://yoursite.com/2020/08/14/OS-ch-1/"/>
    <id>http://yoursite.com/2020/08/14/OS-ch-1/</id>
    <published>2020-08-14T07:00:18.000Z</published>
    <updated>2020-08-14T13:15:39.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统知识点梳理"><a href="#操作系统知识点梳理" class="headerlink" title="操作系统知识点梳理"></a>操作系统知识点梳理</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/2020/08/14/OS-ch-1/1.1-1.jpg" alt="####"></p><h5 id="地位与目标："><a href="#地位与目标：" class="headerlink" title="地位与目标："></a>地位与目标：</h5><h6 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h6><p>紧贴系统硬件之上，所有其他软件之下，（是其他软件的共同环境）</p><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><ul><li><p><strong>有效性</strong>（系统管理人员的观点）：管理和分配硬件、软件资源，合理地组织计算机的工作流程</p></li><li><p><strong>方便性</strong>（用户的观点）：提供良好的、一致的用户接口，弥补硬件系统的类型和数量差别</p></li><li><p><strong>可扩充性</strong>（开放的观点）：硬件的类型和规模、操作系统本身的功能和管理策略、多个系统之间的资源共享和互操作</p></li></ul><h5 id="操作系统的定义：（没有公认的定义）"><a href="#操作系统的定义：（没有公认的定义）" class="headerlink" title="操作系统的定义：（没有公认的定义）"></a>操作系统的定义：（没有公认的定义）</h5><ul><li>是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充</li><li>是一组控制和管理计算机硬件和软件资源，方便用户使用的程序集合<ul><li>控制程序执行以防错误和不当使用</li><li>执行用户程序并提供服务</li><li>管理各种计算机资源：CPU、硬盘、内存、硬件外设等</li><li>有效解决冲突请求并确保资源公平使用</li></ul></li></ul><h5 id="几种观点"><a href="#几种观点" class="headerlink" title="几种观点"></a>几种观点</h5><ol><li>OS是计算机硬件软件的管理者</li><li>OS是用户使用系统的接口</li><li>OS是扩展机/虚拟机<ul><li>在裸机上添加：设备管理，文件管理、存储管理（外存&amp;内存）、处理机管理</li></ul></li></ol><h4 id="1-2操作系统的发展历史"><a href="#1-2操作系统的发展历史" class="headerlink" title="1.2操作系统的发展历史"></a>1.2操作系统的发展历史</h4><h5 id="人工操作系统"><a href="#人工操作系统" class="headerlink" title="人工操作系统"></a>人工操作系统</h5><p><strong>1946-50年代</strong>，（电子管）集中计算（计算中心），计算机资源昂贵</p><p>人工操作特点：</p><ul><li>用户独占全机</li><li>CPU等待人工操作</li><li>串行性</li></ul><p>缺点：</p><ul><li>昂贵组件的低利用效率</li><li>利用率 = 执行时间/（执行时间+读卡时间）</li></ul><h5 id="单道批处理系统："><a href="#单道批处理系统：" class="headerlink" title="单道批处理系统："></a>单道批处理系统：</h5><p><strong>50年代末-60年代中</strong>(晶体管)利用磁带把若干个作业分类编成作业执行序列，每个批作业由一个专门的监督程序（Monitor）自动依次处理。可使用汇编语言开发。</p><p><img src="/2020/08/14/OS-ch-1/1.2-1.jpg" alt></p><p>特征：</p><ul><li>自动性</li><li>顺序性</li><li>单道性</li></ul><p>优点：</p><ul><li>同一批内各作业的自动依次更替，改善了主机CPU和I/O设备的使用效率提高了吞吐量。</li></ul><p>缺点：</p><ul><li><p>内存中仅有一道程序运行，当该程序运行结束或出故障，由监控程序换入另一个程序。不能很好地利用系统资源。</p></li><li><p><strong>CPU</strong>和I/O设备使用忙闲不均（取决于当前作业的特性）。对计算为主的作业，外设空闲；对I/O为主的作业，CPU空闲。</p></li></ul><p><strong>单道批处理系统是最早出现的一种OS,严格来说只能算是OS的前身而不是现在理解的OS，但该系统比起人工操作的系统已经有很大的进步</strong></p><h5 id="多道批处理系统："><a href="#多道批处理系统：" class="headerlink" title="多道批处理系统："></a>多道批处理系统：</h5><p><strong>60年代中~70年代中</strong>（集成电路）利用多到批处理提高资源的利用率。</p><p><img src="/2020/08/14/OS-ch-1/1.2-2.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.2-3.jpg" alt="多道批处理特点以及优缺点"></p><p>多道程序系统的技术问题：</p><ul><li>并行程序的运行需要共享软硬件资源，需要同步和互斥机制。</li><li>多道程序需要提高内存使用效率，需要覆盖技术，交互技术，虚拟存储等技术。</li><li>多道程序在内存中要保证系统存储区和用户存储区安全可靠，需要内存保护。.   </li></ul><h5 id="分时系统："><a href="#分时系统：" class="headerlink" title="分时系统："></a>分时系统：</h5><p><strong>70年代中期至今</strong>    </p><p>多个用户分享使用同一台计算机。每个用户给一定的时间运行，然后切换到另一用户，一个轮转周期在宏观上相当短，用户感觉不到。</p><p><img src="/2020/08/14/OS-ch-1/1.2-4.jpg" alt></p><p>分时系统特征：</p><ul><li>交互性：用户与系统进行人机对话</li><li>多路性：多用户同时在各自终端上使用同一CPU</li><li>独立性：用户可彼此独立操作，互不干扰，互不混淆。</li><li>及时性：用户在短时间内可以得到系统的及时回答。</li></ul><p>影响响应时间的因素：</p><ul><li>终端数目的多少</li><li>时间片的大小</li><li>信息交换量</li><li>信息交换速度</li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li><p>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理。并控制所有事实任务协调一致的运行。</p></li><li><p>保证实时性和高可靠性，对系统的效率放在第二位。</p></li></ul><p>分类：实施控制系统，实时信息处理系统。</p><h5 id="实时系统与分时系统的比较"><a href="#实时系统与分时系统的比较" class="headerlink" title="实时系统与分时系统的比较"></a>实时系统与分时系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-5.jpg" alt></p><h5 id="多处理操作系统："><a href="#多处理操作系统：" class="headerlink" title="多处理操作系统："></a>多处理操作系统：</h5><p><img src="/2020/08/14/OS-ch-1/1.2-6.jpg" alt></p><h5 id="并行系统的类型："><a href="#并行系统的类型：" class="headerlink" title="并行系统的类型："></a>并行系统的类型：</h5><p>非对称式多重处理</p><p>对称式多重处理</p><h5 id="分布式操作系统与网络操作系统的比较"><a href="#分布式操作系统与网络操作系统的比较" class="headerlink" title="分布式操作系统与网络操作系统的比较"></a>分布式操作系统与网络操作系统的比较</h5><p><img src="/2020/08/14/OS-ch-1/1.2-7.jpg" alt></p><h4 id="1-3-操作系统的特征和服务"><a href="#1-3-操作系统的特征和服务" class="headerlink" title="1.3 操作系统的特征和服务"></a>1.3 操作系统的特征和服务</h4><h5 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h5><ul><li><p><strong>并发</strong>：多个事件在同一时间段内发生，（并行是指单处理器下宏观上并发微观上交替执行）</p></li><li><p><strong>共享</strong>：多个进程共享有限的计算机资源，操作系统要对系统资源进行合理的分配和使用，资源在一个时间段内交替被多个进程使用。</p><hr><p>并发和共享是操作系统两个最基本特征，这两者之间是互为存在条件的</p><hr></li><li><p><strong>虚拟</strong>：一个物理实体映射为若干对应逻辑实体–分时或分空间，虚拟是操作系统管理系统资源的重要手段，提高资源利用率。</p></li><li><p><strong>异步</strong>：也称不确定性，指进程的执行顺序和执行时间的不确定性</p><ul><li>进程的运行速度不可预知</li><li>判据：无论快慢，应该结果相通–通过进程互斥和同步手段来保证。</li><li>难以重现系统在某个时刻的状态（包括重现运行中的错误）</li><li>性能保证：实时系统与分时系统类似，但通过资源预留以保证性能。</li></ul></li></ul><h5 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h5><p>1 管理模块：针对不同管理对象的程序模块（操作系统核心）</p><p>2.用户接口：shell,窗口系统</p><h4 id="1-4-操作系统功能"><a href="#1-4-操作系统功能" class="headerlink" title="1.4 操作系统功能"></a>1.4 操作系统功能</h4><h5 id="1-4-1-存储管理"><a href="#1-4-1-存储管理" class="headerlink" title="1.4.1 存储管理"></a>1.4.1 存储管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-1.jpg" alt></p><h5 id="1-4-2-处理机管理"><a href="#1-4-2-处理机管理" class="headerlink" title="1.4.2 处理机管理"></a>1.4.2 处理机管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-2.jpg" alt></p><h5 id="1-4-3-设备管理"><a href="#1-4-3-设备管理" class="headerlink" title="1.4.3 设备管理"></a>1.4.3 设备管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-3.jpg" alt></p><h5 id="1-4-4-文件管理"><a href="#1-4-4-文件管理" class="headerlink" title="1.4.4 文件管理"></a>1.4.4 文件管理</h5><p><img src="/2020/08/14/OS-ch-1/1.4-4.jpg" alt></p><h5 id="1-4-5-用户接口"><a href="#1-4-5-用户接口" class="headerlink" title="1.4.5 用户接口"></a>1.4.5 用户接口</h5><p>目标：提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供给用户。</p><p>命令接口：为联机用户提供的，由一组键盘操作命令及命令解释程序所组成，又分联机和脱机用户接口。</p><p>程序接口：为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的路径。它由一组系统调用组成。</p><p>图形接口：用户可用鼠标或菜单和对话框来完成对应应用程序和文件的操作。</p><h5 id="双模式操作"><a href="#双模式操作" class="headerlink" title="双模式操作"></a>双模式操作</h5><h6 id="用户模式（目态）"><a href="#用户模式（目态）" class="headerlink" title="用户模式（目态）"></a>用户模式（目态）</h6><p>执行普通用户的应用程序</p><h6 id="系统模式（管态）"><a href="#系统模式（管态）" class="headerlink" title="系统模式（管态）"></a>系统模式（管态）</h6><p>执行操作系统核心代码</p><h6 id="分辨方式："><a href="#分辨方式：" class="headerlink" title="分辨方式："></a>分辨方式：</h6><p>在程序状态字中添加模式位指示目前所处模式：系统态(0)或用户态(1)</p><p>发生中断或故障（自陷）<font color="red">硬件</font>自动从用户态切换到系统态</p><p>当用户程序需要操作系统的服务（通过系统调用）必须由管态切换到目态。</p><p><img src="/2020/08/14/OS-ch-1/1.4-5.jpg" alt></p><p><img src="/2020/08/14/OS-ch-1/1.4-6.jpg" alt></p><h4 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h4><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex1.jpg" alt="1."></p><p>eg2</p><p><img src="/2020/08/14/OS-ch-1/ex2.jpg" alt="1."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;操作系统知识点梳理&quot;&gt;&lt;a href=&quot;#操作系统知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;操作系统知识点梳理&quot;&gt;&lt;/a&gt;操作系统知识点梳理&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是操作系统&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP Ch.3</title>
    <link href="http://yoursite.com/2020/07/26/CSAPP-Ch-3/"/>
    <id>http://yoursite.com/2020/07/26/CSAPP-Ch-3/</id>
    <published>2020-07-26T09:07:46.000Z</published>
    <updated>2020-08-14T13:16:51.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSAPP第三章"><a href="#CSAPP第三章" class="headerlink" title="CSAPP第三章"></a>CSAPP第三章</h2><h3 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h3><h4 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h4><p>Intel &amp; AMD</p><h4 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>gcc</strong>： Linux上默认的编译器</p></li><li><p><strong>-Og</strong>:   编译选项，告诉编译器使用会生成符合原始C代码整体结构的机器代码编译优化等级</p></li></ul><h5 id="gcc命令调用过程"><a href="#gcc命令调用过程" class="headerlink" title="gcc命令调用过程"></a>gcc命令调用过程</h5><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgcc%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="gcc命令调用过程"></p><p>用图片的形式描述一下就是这样的：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5Cgccppt.jpg" alt="gccppt"></p><h5 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h5><ul><li><strong>机器级编程的两种抽象</strong><ul><li>指令集体系结构或指令集架构（Instruction Set Architexture,ISA）来定义机器级程序的格式和行为，它定义了处理器状态，指令格式以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看起来像一个非常大的数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li></ul></li></ul><h5 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h5><p>以C代码文件<code>mstore.c</code>为例，在命令行上使用<code>-S</code>选项，可以看到C语言编译产生的汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure><p>这时GCC会运行编译器，产生汇编文件<code>mstore.s</code>但是不做进一步操作</p><p>如果用  <code>-c</code>命令行选项GCC会编译并汇编该代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure><p>这样就会产生目标代码文件<code>mstore.o</code>它是二进制格式的，无法直接进行查看,想要查看机器代码的内容，可以通过<code>反汇编器(disassembler)</code>进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d mstore.o</span></span><br></pre></td></tr></table></figure><p>机器代码以及反汇编表示的特性：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E7%89%B9%E6%80%A7.jpg" alt="机器代码以及反汇编表示的特性"></p><h5 id="3-2-3-关于格式的注释"><a href="#3-2-3-关于格式的注释" class="headerlink" title="3.2.3 关于格式的注释"></a>3.2.3 关于格式的注释</h5><p>以书上内容为例</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.jpg" alt="example"></p><p>所有以<font color="red"><code>.</code></font>开头的行都是指导汇编器和连接器工作的伪指令，我们通常可以忽略。</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.2.3.2.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h4><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C3.3.jpg" alt="机器代码以及反汇编表示的特性"></p><h4 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h4><h5 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h5><p>大多数指令具有一个或者多个操作符，用于指示出执行一个操作中要用的源数据值以及放置结果的目的地址值。不同种操作数可能被分为三类：</p><ul><li>立即数        <ul><li>用来表示常数值</li><li>书写方式是<code>$+标准C表示法表示的整数</code>，例如：<code>$-577，$0x1F</code></li><li>不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码</li></ul></li><li>寄存器        <ul><li>表示某个寄存器中的内容，16个寄存器的低1字节、2字节、4字节和8字节中的一个作为操作数，分别对应8位、16位、32位以及64位。</li><li>用r<sub>a</sub>来表示任意寄存器ａ，用引用R[r<sub>a</sub>]来表示它的值，（将寄存器集看做数组R）</li></ul></li><li>内存引用<ul><li>根据计算出来的地址（有效地址）访问某个内存位置。</li><li>用M<sub>b</sub>[Addr]表示对存储在内存中地址Addr开始的b个字节进行引用,为了方便通常省略下标b</li></ul></li></ul><p>操作数格式标示图如下：</p><p><img src="/2020/07/26/CSAPP-Ch-3/CSAPP-Ch-3%5C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%A4%BA%E5%9B%BE.jpg" alt="机器代码以及反汇编表示的特性"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSAPP第三章&quot;&gt;&lt;a href=&quot;#CSAPP第三章&quot; class=&quot;headerlink&quot; title=&quot;CSAPP第三章&quot;&gt;&lt;/a&gt;CSAPP第三章&lt;/h2&gt;&lt;h3 id=&quot;程序的机器级表示&quot;&gt;&lt;a href=&quot;#程序的机器级表示&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Git个人博客搭建</title>
    <link href="http://yoursite.com/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-26T15:34:47.000Z</published>
    <updated>2020-06-27T06:44:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Git个人博客搭建（一）"><a href="#Hexo-Git个人博客搭建（一）" class="headerlink" title="Hexo+Git个人博客搭建（一）"></a>Hexo+Git个人博客搭建（一）</h1><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​    拥有一个私人博客一直都是每个<del>程序员</del>的理想，恰好赶上最近不想学习，用了一下午的时间搭建<del><strong>采坑</strong></del>了Hexo+Git个人博客搭建（主要是免费啊！！！免费啊！！）遇到的一些问题以及搭建过程进行一个记录，也希望能减少后来人的掉发量（笑）。那我们现在就开始愉快的脱发之旅吧！</p><hr><h3 id="二、Hexo简介"><a href="#二、Hexo简介" class="headerlink" title="二、Hexo简介"></a>二、Hexo简介</h3><p>​    关于Hexo，我觉得没有什么比他简介中的说法能更好的解释这个软件的话语了。</p><blockquote><p>快速、简洁且高效的博客框架</p></blockquote><p>​    速度快、一键部署、支持MarkDown、可扩展插件。。最重要的是<font color="red"><strong>开源免费</strong></font>! 大写加粗的重要啊朋友们！！！开发者是台湾人，所以<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>的官网对中文支持极度友好，对英语有怨念的同学可以在官网选择中文查阅文档以及API。</p><p>​    Hexo是基于<strong>Node.js</strong>的静态博客框架，依赖少安装容易，可以很方便的生成网页托管在GitHub上或者云上，是搭建博客的首要选择。本文采用的是网页托管到GitHub上来进行博客搭建。</p><hr><h3 id="三、安装过程"><a href="#三、安装过程" class="headerlink" title="三、安装过程"></a>三、安装过程</h3><h4 id="1-系统配置"><a href="#1-系统配置" class="headerlink" title="1.系统配置"></a>1.系统配置</h4><p>​    提及安装过程不提系统以及版本的都是流氓！首先放上我自己的系统配置：</p><blockquote><p>win10_64位教育版 A卡全家桶套餐（与安装无关不详细写了）</p><p>git –version 2.27.0.windows.1</p><p>npm –version 6.14.5</p></blockquote><p>​    由于我本身是Windows版本，所以以下的安装过程主要按照windows版本来描述，但是用Linux的小伙伴的安装过程也是大同小异（具体安装方法我也会在下面提及）。特别是安装git后使用的命令行基本和linux一样，所以系统版本就没有那么重要了</p><hr><h4 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2.Node.js安装"></a>2.Node.js安装</h4><p>​    在上文说道，Hexo是基于Node.js的，所以首先就要安装Node.js的依赖。这里我直接给出Node.Js的下载网址以及Git的安装网址以方便查阅。</p><p>​                                                                          <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener"> 点击这里安装Node.js</a></p><p>​    Node.js的安装极度简单，如果直接下载.msi文件的话只要一路next就可以安装成功。这里有问题的小伙伴请自行百度谷歌</p><h4 id="3-Git安装"><a href="#3-Git安装" class="headerlink" title="3.Git安装"></a>3.Git安装</h4><p>​    下一步是Git的安装，这里一样给出git的下载网址以便下载。</p><p>​                                                                                 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">点击这里下载Git</a></p><p>​    Linux的安装方法则更加简单，以Ubuntu为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line"></span><br><span class="line">sudo apt-get install npm</span><br><span class="line"></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装后打开cmd(terminal)输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果出现了版本号，就证明你安装成功了，我的是这样的：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Git&npm.jpg" alt="我的配置"></p><p>在安装成功后就可以在Git里面敲命令行啦，比Windows本身带的cmd要好用许多。</p><h4 id="4-Hexo安装"><a href="#4-Hexo安装" class="headerlink" title="4.Hexo安装"></a>4.Hexo安装</h4><p>​    到了这里，恭喜你终于开始安装框架了，进入到了安装博客的第一步。</p><p>​    首先要在自己喜欢的位置创建一个文件夹来放你的博客，我选择的位置是D://Blog (路径习惯性的用英文可以减少不少莫名其妙的Bug)</p><p>​    在此处右键打开Git Bash，或者勤快的同学也可以从桌面cd进去</p><p>​    输入命令<code>npm install -g heso-cli</code></p><p>​    安装好后用<code>hexo -v</code>检查版本号</p><p>​    下面继续回到GIt中，初始化一下Hexo输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>​    在你选择的文件夹中应该能看到这样的文件结构（我的文件经过编译提交了，安装完后应该会比这个少几个文件）：<br><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/Hexo.jpg" alt="我的文件"></p><p>​    在这个文件列表中，</p><ul><li><p>node_modeules 是用来存放依赖包的文件</p></li><li><p>public 是用来存放生成的页面的文件</p></li><li><p>scaffold 用来生成文章的一些模板</p></li><li><p>source文件夹用来存放你的博客文件</p></li><li><p>themes是博客的主题</p></li><li><p>_config.yml是配置文件，</p><p>在推送到Git上时我们都会用到。但这都是之后的事情啦</p><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>​        这样就可以在<code>localhost:4000</code>看到你的博客啦，但是现在的博客不仅主题不好看，而且还只是在你自己电脑上运行的，并没有部署到Git上托管。</p><p>​    既然提到了博客界面很丑陋，那我们为什么不换一个主题呢？Hexo显然也考虑到了这点，为我们提供了一个很好的下载主题的网站，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>你就可以找到一个你喜欢的博客模板进行下载了。把下载的主题直接解压放在theme文件夹里，命名为你下载的主题，在_config.yml 中修改<code>theme</code>为你下载的名称。</p><p>​    比如我应用的是名称是<code>clean</code>的一个主题。那我修改的方式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: clean</span><br></pre></td></tr></table></figure><h4 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h4><p>​    我默认你在看这篇文章之前已经有一个GItHub账户了，如果没有的话直接去注册一个也很方便。如果你已经配置过Git以及SSH可以直接跳过。</p><p>在网页的右上角选择<code>new respository</code>新建一个仓库</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/GitNewRes.jpg" alt="New repository"></p><p>​    输入仓库名称为<code>UserName/UserName.git.io</code></p><p>​    可能这么说会有人不理解，那我就放上一个更直白的方式：</p><p>​    我的用户名称为Yokeso ,那我创建的库名称就为<code>Yokeso/Yokeso.git.io</code>顺便附上图片希望对小白有所帮助</p><p><img src="/2020/06/26/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/newres.jpg" alt="Repository"></p><p>​    这个名称是GitHub专门用来给用户的网站接口，每个用户只能创建一个，并且<font color="red">是免费的</font>。</p><p>回到你的GItBash下，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure><p>​    这里的yourname 是你的用户名，youremail是你注册GItHub时用的邮箱，这样GitHub才知道你是他的对应用户。</p><p>​    输入完成之后如果不放心可以用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>​    来进行检查。</p><h4 id="5-Git创建SSH"><a href="#5-Git创建SSH" class="headerlink" title="5.Git创建SSH"></a>5.Git创建SSH</h4><p>​    创建SSH同样只需要GitBash上的一个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></table></figure><p>​    如果想创建秘钥的话可以创建，但只是个人博客的话没有创建秘钥的必要，所以一路回车直接过去。</p><p>​    SSH会默认在你的/User/.ssh下创建秘钥，这里的id_rsa是这台电脑的私人秘钥，Id_rsa.pub是公钥。需要提交到GItHub上。只有秘钥公钥相互匹配是你才能顺利的传输到你的gitHub上。你可以给他直接打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后将这段代码（普遍是以ssh-rsa AAAA开头）直接复制，粘贴到个人仓库上方<code>setting</code>中的SSH目录里。这里涉及到个人隐私，所以不贴图展示了。</p><p>如果不知道是否创建成功的话，你可以直接输入以下命令进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这个代码在成功情况下回返回这样的一个结果</p><p><code>Hi Yokeso(这里是我的用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h4 id="6-将Hexo部署上去"><a href="#6-将Hexo部署上去" class="headerlink" title="6.将Hexo部署上去"></a>6.将Hexo部署上去</h4><p>​    到了这里，你已经完成一大半了，最后一步就是要将你的博客部署到GitHub上。</p><p>​    打开_config.yml，在最后你会看到一个<code>deploy</code>字段，将其修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你的账户名称&#x2F;你的账户名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​    <font color="red">千万要注意repo字段，将git上面仓库的地址直接复制过来，选择https方式，我这里在网络上没找明白，弄了好久。</font></p><p><img src="/Hexo-Git%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/https.jpg" alt="复制到repo字段"></p><p>​    在最后部署之前,先要安装<code>hexo-deployer</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nom install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li><p><code>hexo clean</code>是用来清除你之前生成的东西</p></li><li><p><code>hexo g</code>用来生成静态文章 g的全称为generate （当然可以在命令行里写hexo generate）</p></li><li><p><code>hexo d</code>用来部署文章（deploy）</p><p>过一会儿就能在http://你的注册名称.github,io上看到你的博客了！</p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>​    作为智能专业的学生，很少接触网络的一些东西，这次搭建Hexo也是一时的心血来潮，想要做一些整理工作。描述下来比较简单，但在repo字段的问题上就浪费了我将近一个小时去寻找问题。同时，这也是我第一次接触markdown 以及写博客。应该有些算晚了，但对于一个工具来说，也应该没有什么早晚的区别。我也希望通过我的博客能够与大家多多交流，将自己搭建各种环境包括做各种项目时候的一些心得和大家一起分享</p><p>Code To Make World Better!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Git个人博客搭建（一）&quot;&gt;&lt;a href=&quot;#Hexo-Git个人博客搭建（一）&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Git个人博客搭建（一）&quot;&gt;&lt;/a&gt;Hexo+Git个人博客搭建（一）&lt;/h1&gt;&lt;h2 id=&quot;文章目录&quot;
      
    
    </summary>
    
    
    
      <category term="-Hexo -个人博客" scheme="http://yoursite.com/tags/Hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
