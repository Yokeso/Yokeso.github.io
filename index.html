<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yokeso.top","root":"/","images":"/images","scheme":"Muse","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Yokeso">
<meta property="og:url" content="http://yokeso.top/index.html">
<meta property="og:site_name" content="Yokeso">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="BigtreeLiu">
<meta property="article:tag" content="Bolg,Yokeso,BigtreeLiu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yokeso.top/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Yokeso</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Yokeso" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yokeso</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BigtreeLiu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">BigtreeLiu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated"><i class="fa fa-comment"></i>
    聊天
  </a>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Yokeso" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yokeso" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yokeso@foxmail.com" title="E-Mail → mailto:yokeso@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/xing-chen-da-hai-41-66" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;xing-chen-da-hai-41-66" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/NaiveBayes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/NaiveBayes/" class="post-title-link" itemprop="url">NaiveBayes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 17:30:04" itemprop="dateCreated datePublished" datetime="2021-01-11T17:30:04+08:00">2021-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-12 21:11:06" itemprop="dateModified" datetime="2021-01-12T21:11:06+08:00">2021-01-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>366</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>logistic回归：本质是对$p(y|\vec x)$进行建模</p>
<p>贝叶斯公式：求$\vec x$和y的联合概率（联合分布）$p(y|\vec x) = \frac {p(\vec x,y)}{p(\vec x)}$</p>
<p>判别模型：对$p(y|\vec x)$进行建模，且$\sum_{y}p(y|\vec x)=1$（分类问题）</p>
<p>生成模型：对$p(\vec x,y)$进行建模，且$\sum_{y}p(\vec x,y)=1$（联合分布）</p>
<p>决策函数：$\hat y =argmax_cp(\vec x,c)=argmax_cp(c)\prod p(\vec x_i,c)$</p>
<p>样本修正（拉普拉斯修正）<br>$$<br>\breve p(x_i|c)=\frac{|D_{c_i}x_i|+1}{|D_c|+N_i}<br>$$<br>分子加1是为了避免0概率，分母则是为了将第i个特征的可能取值数添加进去</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/ANNs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/ANNs/" class="post-title-link" itemprop="url">ANNs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 17:29:06" itemprop="dateCreated datePublished" datetime="2021-01-11T17:29:06+08:00">2021-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-13 16:44:51" itemprop="dateModified" datetime="2021-01-13T16:44:51+08:00">2021-01-13</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p>神经网络解决的问题是线性不可分的问题，但线性不可分问题可以拆分为线性运算的组合</p>
<h3 id="1-神经网络结构"><a href="#1-神经网络结构" class="headerlink" title="1.神经网络结构"></a>1.神经网络结构</h3><p>可以将感知机看作是一种单层神经网络，可以解决线性问题</p>
<p>那么多层感知机就被称为神经网络，用来解决线性不可分问题</p>
<h3 id="2-模型表示（全链接）"><a href="#2-模型表示（全链接）" class="headerlink" title="2.模型表示（全链接）"></a>2.模型表示（全链接）</h3><p>假设$z_i^{(l)}$是第l层第i个神经单元的的净输入，$a_i^{(l)}$是第l层第i个神经单元的的激活值，$g_l(.)$是第l层的激活函数</p>
<p>最终模型的表达无法表示，但每一层的均可知：<br>$$<br>\vec {z^{(l)}} = (\vec{w^{(l)}})^T\vec{a^{(l-1)}}+\vec{b^{(l)}}<br>$$<br>前向传播：$\vec x =\vec {a^{(0)}}\rightarrow (\vec {z^{(1)}}\rightarrow\vec {a^{(1)}})\rightarrow……\rightarrow(\vec {z^{(l)}}\rightarrow\vec {a^{(l)}}=h_{\vec w,\vec b}(x))$</p>
<h3 id="3-损失函数（多分类为例）"><a href="#3-损失函数（多分类为例）" class="headerlink" title="3.损失函数（多分类为例）"></a>3.损失函数（多分类为例）</h3><p>设最后一层的激活函数是softmax，即$\vec {a^{(l)}} = softmax(\vec {z^{(l)}})$<br>$$<br>J_{\vec w,\vec b}(h_{\vec w,\vec b}(\vec x),\vec y) = -\frac {1}{m} \sum_{i=1}^m \sum_{c=1}^Cy^{(i)}log((h_{\vec w,\vec b}(\vec x^{(i)})_c<br>$$</p>
<h3 id="5-优化方法"><a href="#5-优化方法" class="headerlink" title="5.优化方法"></a>5.优化方法</h3><p>1.梯度下降</p>
<p>2.反向传播</p>
<h3 id="7-自动梯度计算"><a href="#7-自动梯度计算" class="headerlink" title="7.自动梯度计算"></a>7.自动梯度计算</h3><p>数值微分，符号微分（对公式求导）、自动微分$\Rightarrow$计算图</p>
<h3 id="8-激活函数"><a href="#8-激活函数" class="headerlink" title="8.激活函数"></a>8.激活函数</h3><p>1.Sigmoid<br>$$<br>Sigmoid： h_{\vec \theta}(\vec x) = \frac {1} {1+e^{-{\vec \theta}^T \vec x}}<br>$$<br>2.Softmax<br>$$<br>Softmax:h_{\vec \theta}(\vec x) = \frac {e^{-{\vec \theta}<em>c^T \vec x}} {\sum</em>{i=1}^Ne^{-{\vec \theta}^T \vec x}}<br>$$<br>3.Relu<br>$$<br>Relu(x) = \begin{cases} x&amp; x\geq0\ 0&amp; x=0 \end{cases}<br>$$<br>4.LeakyRelu<br>$$<br>LeakyRelu(x) = \begin{cases} x&amp; x\geq0\ \delta x&amp; x=0 \end{cases}<br>$$<br>5.swish函数<br>$$<br>swish(x) = x\times Sigmoid(\beta x)<br>$$<br>$\beta$是可学习固定参数或者超参数</p>
<p>6.maxout<br>$$<br>maxout(\vec z)=max_{k\in (l,k)}z_k <br>$$</p>
<h3 id="9-卷积神经网络"><a href="#9-卷积神经网络" class="headerlink" title="9.卷积神经网络"></a>9.卷积神经网络</h3><p>全连接NN无法表示局部不变特征（无法胜任图像分类）</p>
<p>所以需要卷积神经网络来进行扩展，卷积神经网络学习的参数是卷积核的参数</p>
<p>这里的卷积表示的是直接对位相乘$\vec r = \vec w *\vec x$ </p>
<p>基本结构：一般由卷积层,polling层（降采样层）和全连接层构成</p>
<h3 id="10-循环神经网络RNN"><a href="#10-循环神经网络RNN" class="headerlink" title="10.循环神经网络RNN"></a>10.循环神经网络RNN</h3><p>用来处理具有时序的数据<br>$$<br>\vec h_t=g(\vec w \vec h_{t-1}+\vec w \vec x_t +\vec b)<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/SVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/SVM/" class="post-title-link" itemprop="url">SVM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 17:28:20" itemprop="dateCreated datePublished" datetime="2021-01-11T17:28:20+08:00">2021-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-12 16:06:52" itemprop="dateModified" datetime="2021-01-12T16:06:52+08:00">2021-01-12</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h3 id="1-模型表示"><a href="#1-模型表示" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><p>支持向量机是一种二分类的广义分类器，其假设函数为<br>$$<br>h_{\vec \theta}(\vec x)=\vec \theta^T\vec x<br>$$<br>决策函数为：<br>$$<br>\hat y=sgn(h_{\vec \theta}(\vec x))<br>$$</p>
<h3 id="2-优化准则"><a href="#2-优化准则" class="headerlink" title="2.优化准则"></a>2.优化准则</h3><p>支持向量机运行的是基于边界决策的优化准则，决策边界不止一条 = 模型参数不唯一这种时候就要寻找中间线。<br>$$<br>h_{\vec \theta}(\vec x)=\vec \theta^T\vec x = \theta_0+\theta_1x_1+……+\theta_nx_n (增广形式)<br>$$<br>使$b=\theta_0$,其余部分视为$\vec w^T\vec x$的话，那么寻找中间决策线的方程就可以表述为：<br>$$<br>\vec w^T\vec x+b=\vec 0<br>$$</p>
<h4 id="1-点到超平面的距离"><a href="#1-点到超平面的距离" class="headerlink" title="1.点到超平面的距离"></a>1.点到超平面的距离</h4><p>$$<br>r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}<br>$$</p>
<p>其中，$||\vec w||$表示一个二范数的模，这个式子的大前提是同时使得正样本大于0，负样本小于0</p>
<p>在r的集合中，间隔定义为$r = min_ir^{(i)}$,间隔最大化则是求$max_{\vec w,b} r$的过程</p>
<p>最终约束条件：<br>$$<br>r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}S&gt;=r<br>$$</p>
<h3 id="3-优化目标loss"><a href="#3-优化目标loss" class="headerlink" title="3.优化目标loss"></a>3.优化目标loss</h3><p>$$<br>max_{\vec w,b} r,s.t.  r^{(i)} = \frac {|\vec w^T\vec x^{(i)}+b|}{||\vec w||}S&gt;=r<br>$$</p>
<p>loss的意义：平行超平面$\vec w^T\vec x+b_1=0$与$\vec w^T\vec x+b_2=0$之间的距离<br>$$<br>d=\frac {b_1-b_2}{\vec w}<br>$$<br>即辅助决策边界之间的距离$d=\frac{2}{||\vec w||}$</p>
<p>loss的最大化的d就是让决策边界到正负样本之间的安全距离最大</p>
<h3 id="4-参数求解（对偶优化）"><a href="#4-参数求解（对偶优化）" class="headerlink" title="4.参数求解（对偶优化）"></a>4.参数求解（对偶优化）</h3><p>原问题：<br>$$<br>min_{\vec w,b}J(\vec w)=min_{\vec w,b}\frac{1}{2}||\vec w||^2 ,\quad s.t. \quad 1-y^{(i)}(\vec w^T\vec x^{(i)}+b) \leq 0,\forall i\in (1,2…m)<br>$$<br>构造拉格朗日函数：<br>$$<br>L(\vec w,b,\vec \alpha) =\frac{1}{2}||\vec w||^2+\sum_{i=1}^m \alpha_i(1-y_i(\vec w^T\vec x^{(i)}+b))<br>$$<br>等价于：<br>$$<br>min_{\vec w,b}\quad max_{\vec \alpha}L(\vec w,b,\vec \alpha)\quad s.t. \quad \alpha_i \geq0,\forall i\in (1,2…m)<br>$$<br>由于强对偶性，交换min,max下的$\vec w,b与\vec \alpha$也同样成立</p>
<p>求解对偶问题的过程就是求拉格朗日函数的过程。</p>
<p>对偶问题的等价推广条件：KKT条件</p>
<ul>
<li>$g(\vec \theta)\leq 0$ 原问题可行</li>
<li>$\vec \alpha\geq0$ 对偶问题可行</li>
<li>$g(\vec \theta)\vec \alpha=\vec 0$互补松弛</li>
</ul>
<p>其中$\vec {\theta^*}$是$\vec \theta$的最优解</p>
<h5 id="决策函数"><a href="#决策函数" class="headerlink" title="决策函数"></a>决策函数</h5><p>$$<br>\vec {w^<em>}=\sum_{i=1}^m \alpha_i^*y^{(i)}\vec x^{(i)}\Rightarrow \alpha_i^</em>=0的样本对\vec {w^*}无贡献<br>$$</p>
<p>$$<br>\hat y = sgn(h\vec{w^<em>},b^</em>(\vec x))=sgn((\vec{w^<em>})^T\vec x+b)=sgn(\sum_{i=1}^m \alpha_i^*y^{(i)}{\vec x^{(i)}}^T\vec x^{(i)}+b^</em>)<br>$$</p>
<h3 id="5-SVM优点"><a href="#5-SVM优点" class="headerlink" title="5.SVM优点"></a>5.SVM优点</h3><ol>
<li>小样本学习（但学习过程中所有样本依然参与运算，给少量样本和大量样本意义相同）</li>
<li>分类鲁棒性高</li>
<li>理论上可得全局最优解</li>
</ol>
<h3 id="6-软间隔（线性不可分的情况）"><a href="#6-软间隔（线性不可分的情况）" class="headerlink" title="6.软间隔（线性不可分的情况）"></a>6.软间隔（线性不可分的情况）</h3><p>由于线性不可分，则无论什么分法都会将样本分错。可以设$\varepsilon$作为对难分样本的容忍度，loss就是要获得最小的$\varepsilon_i$,公式为<br>$$<br>min_{\vec w,b,\varepsilon}J(\vec w)=min_{\vec w,b,\varepsilon}\frac{1}{2}||\vec w||^2+C\sum_{i=1}^m\varepsilon_i ,\quad s.t. \quad y^{(i)}(\vec w^T\vec x^{(i)}+b) \geq 1,\forall i\in (1,2…m)\quad \varepsilon_i\geq0<br>$$<br>这里的C是一个常数，用来调和两项的系数</p>
<h4 id="软间隔的优化目标"><a href="#软间隔的优化目标" class="headerlink" title="软间隔的优化目标"></a>软间隔的优化目标</h4><p>拉格朗日函数：<br>$$<br>L(\vec w,b,\vec \varepsilon ,\vec \alpha,\vec \mu) =(\frac{1}{2}||\vec w||^2+C\sum_{i=1}^m\varepsilon_i)+\sum_{i=1}^m \alpha_i(1-y^{(i)}(\vec w^T\vec x^{(i)}+b)-\varepsilon_i)-\sum_{i=1}^m\mu+\varepsilon_i<br>$$<br>软间隔支持的向量满足：$y^{(i)}(\vec w^T\vec x^{(i)}+b)+\varepsilon_i=1$</p>
<p>优点：小样本学习，可以容忍一些难以分类的样本点</p>
<h3 id="7-核技巧解线性不可分问题"><a href="#7-核技巧解线性不可分问题" class="headerlink" title="7.核技巧解线性不可分问题"></a>7.核技巧解线性不可分问题</h3><p>核技巧的基本思想是：低维线性不可分的问题可以转化为高维线性可分的问题</p>
<p>核函数表示：<br>$$<br>k(\vec x,\vec z) = \phi(\vec x)^T \phi(\vec z)<br>$$<br>这是对特征距离的一种重新度量。</p>
<p>常用和函数：<br>$$<br>\begin{aligned}<br>k(\vec x,\vec z) &amp;= \vec x^T \vec z  \quad (线性)\<br>&amp;=(\vec x^T \vec z+c)^d \quad (多项式)\<br>&amp;=exp(-\frac{||\vec x-\vec z||_2^2}{2\delta^2}) \quad (高斯)<br>\end{aligned}<br>$$</p>
<h2 id="线性模型总结"><a href="#线性模型总结" class="headerlink" title="线性模型总结"></a>线性模型总结</h2><p><img src="/2021/01/11/SVM/image-20210112160624373.png" alt="image-20210112160624373"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/enntropy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/enntropy/" class="post-title-link" itemprop="url">enntropy</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-11 17:27:56 / 修改时间：19:29:27" itemprop="dateCreated datePublished" datetime="2021-01-11T17:27:56+08:00">2021-01-11</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>573</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="几种熵的介绍"><a href="#几种熵的介绍" class="headerlink" title="几种熵的介绍"></a>几种熵的介绍</h2><h3 id="1-信息熵"><a href="#1-信息熵" class="headerlink" title="1.信息熵"></a>1.信息熵</h3><p>给定随机变量x,在系统中可能的输出为x1,x2….xn,这些输出对应发生的概率为p(x1),p(x2)…p(xn)</p>
<p>这时x的熵的定义为：<br>$$<br>H(x) = -\sum_{i=1}^n p(x_i)log(p(x_i))<br>$$<br>这个值是非负的，意义是对于不确定性的度量。当等概率出现时，不确定性达到最大，此时系统最公平</p>
<h3 id="2-相对熵"><a href="#2-相对熵" class="headerlink" title="2.相对熵"></a>2.相对熵</h3><p>给定随机变量x，有两个离散概率分布$\vec p$和$\vec q$，$\vec p$相对于$\vec q$的相对熵定义为<br>$$<br>D_{kl}(\vec p||\vec q)=-\sum_{i=1}^n p(x_i)log(\frac{p(x_i)}{q(x_i)})<br>$$<br>这种定义的意义是对两个概率分布p和q的分布差异的度量</p>
<p>具有非负性$D_{kl}(\vec p||\vec q)$&gt;=0,并且$D_{kl}(\vec p||\vec q)\not = D_{kl}(\vec q||\vec p)$</p>
<h3 id="3-交叉熵"><a href="#3-交叉熵" class="headerlink" title="3.交叉熵"></a>3.交叉熵</h3><p>交叉熵也要给定x和离散概率分布$\vec p$和$\vec q$，则交叉熵可定义为：<br>$$<br>H(\vec p,\vec q) = H(\vec p)+D_{kl}(\vec p||\vec q)<br>$$</p>
<p>$$<br>=-\sum_{i=1}^n p(x_i)log(q(x_i))<br>$$</p>
<p>是用于估计概率分布q相对于真实概率分布p的度量，具有非负性，所以可以作为loss使用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/Perceptron/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/Perceptron/" class="post-title-link" itemprop="url">Perceptron</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-11 14:50:22 / 修改时间：17:17:39" itemprop="dateCreated datePublished" datetime="2021-01-11T14:50:22+08:00">2021-01-11</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>865</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>有证据表明，人脑就是利用相同的算法来理解不同的输入，感知机就是利用这种思想，将不同的输入放入同一个模型进行预测分析，从而得到结果。</p>
<h3 id="1-感知机模型表示"><a href="#1-感知机模型表示" class="headerlink" title="1.感知机模型表示"></a>1.感知机模型表示</h3><img src="/2021/01/11/Perceptron/1.jpg" alt="1" style="zoom: 25%;">

<h3 id="2-感知机的loss与参数学习"><a href="#2-感知机的loss与参数学习" class="headerlink" title="2.感知机的loss与参数学习"></a>2.感知机的loss与参数学习</h3><p>$$<br>J(\vec \theta) = \frac {1}{m} \sum_{i=1}^M max(0,-y^{(i)}\vec \theta^T \vec x^{(i)})<br>$$</p>
<p>$$<br>其中\vec \theta^T \vec x^{(i)}也就是h_{\vec \theta}(\vec x)<br>$$</p>
<p>准则：只有计算符号预测错误时的loss(ReLu)</p>
<p>那么，梯度下降的方式改变也就很明显了<br>$$<br>\vec \theta ：= \vec \theta-\alpha\frac {\delta J_{\vec \theta}}{\vec{\theta_j}}<br>$$</p>
<p>$$<br>\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} = \begin{cases} 0&amp; {y\vec \theta^T \vec x}&gt;=0\ -y\vec x&amp; {y\vec \theta^T \vec x}&lt;0 \end{cases}<br>$$</p>
<h3 id="4-多分类感知机"><a href="#4-多分类感知机" class="headerlink" title="4.多分类感知机"></a>4.多分类感知机</h3><p>多分类的感知机和单分类的最大区别是多分类只取损失最大的类进行更新，其损失函数为<br>$$<br>J(\vec \theta) = \frac {1}{m} \sum_{i=1}^M max(0,max_{j=0…C}(\vec \theta_j\vec x^{(i)}-\vec \theta_{y^{(i)}}^T \vec x^{(i)}))<br>$$</p>
<p>$$<br>\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} = \begin{cases} 0&amp; c’=y^{(i)} \ \vec x^{(i)}&amp; j=c’ \-\vec x^{(i)}&amp; j=y^{(i)}\end{cases} 其中C’=argmax_{j=1.2..C}\theta_j^T \vec x<br>$$</p>
<p>损失函数特点：（要和极大似然函数分清）</p>
<ul>
<li>J&gt;=0(非负性)</li>
<li>J可导但不要求处处可倒</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/11/logistic%E5%9B%9E%E5%BD%92%E4%B8%8Esoftmax%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/logistic%E5%9B%9E%E5%BD%92%E4%B8%8Esoftmax%E5%9B%9E%E5%BD%92/" class="post-title-link" itemprop="url">logistic回归与softmax回归</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 09:59:06" itemprop="dateCreated datePublished" datetime="2021-01-11T09:59:06+08:00">2021-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 23:33:34" itemprop="dateModified" datetime="2021-03-08T23:33:34+08:00">2021-03-08</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>逻辑回归问题不是回归问题，而是一种分类问题，默认为二分类</p>
<h3 id="1-模型表示"><a href="#1-模型表示" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><p>$$<br>Sigmoid： h_{\vec \theta}(\vec x) = \frac {1} {1+e^{-{\vec \theta}^T \vec x}}<br>$$</p>
<p>物理意义：这是$h_{\vec \theta}(\vec x)$是$\vec x$为正样本的概率（输出为1的概率）是人为规定的，用指数形式表示是为了加大两个概率之间的区别。</p>
<h3 id="2-分类的决策"><a href="#2-分类的决策" class="headerlink" title="2.分类的决策"></a>2.分类的决策</h3><p>在分类问题中，函数只会输出$h_{\vec \theta}(\vec x)$中$\vec x$属于某一种类的概率，但没有给出样本究竟属于哪一类，所以就需要利用决策函数进行分类。</p>
<p>决策函数：$\hat y = f(x)= \begin{cases} 0&amp; \text{g(z)&lt;0.5}\ 1&amp; \text{g(z) &gt;= 0.5} \end{cases}$</p>
<h3 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3.损失函数"></a>3.损失函数</h3><p>$$<br>loss：Cost(h_{\vec \theta}(\vec x^{(i)}),y^{(i)})\begin{cases} -log(h_{\vec \theta}(\vec x^{(i)})&amp; \text{y^{(i)}=1}\ -log(1-h_{\vec \theta}(\vec x^{(i)})&amp; \text{y =0} \end{cases}<br>$$<br>类似于$-p_ilogq_i$这种形式，我们称为交叉熵，它表示了预测值与真实值之间的差异,其中$-p_i$表示真实值，$logq_i$表示预测值</p>
<p>上式可以同一形式变化为<br>$$<br>J(\vec \theta) = \frac {1}{m} \sum_{i=1}^N [-y^{(i)}log(h_{\vec \theta}(\vec x^{(i)})-(1-y^{(i)})log(1-h_{\vec \theta}(\vec x^{(i)})]<br>$$</p>
<h3 id="4-梯度下降优化"><a href="#4-梯度下降优化" class="headerlink" title="4.梯度下降优化"></a>4.梯度下降优化</h3><p>$$<br>\frac {\delta J_{\vec \theta} }{\vec{\theta_j} } =\frac {1}{m} \sum_{i=1}^N\frac {\delta J_{\vec \theta} }{\delta h_{\vec \theta}(\vec x^{(i)})}\frac {\delta h_{\vec \theta}(\vec x^{(i)})}{ {\delta \vec \theta}^T \vec x^{(i)}}\frac { {\delta \vec \theta}^T \vec x^{(i)} }{\delta \vec{\theta_j} }<br>$$</p>
<p>$$<br>=\frac {1}{m}\sum_{i=1}^N(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}<br>$$<br>那么梯度下降的跟新规则即为<br>$$<br>\vec \theta=\vec \theta-\alpha\frac {1}{m}\sum_{i=1}^N(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}<br>$$</p>
<h3 id="5-随机梯度下降优化"><a href="#5-随机梯度下降优化" class="headerlink" title="5.随机梯度下降优化"></a>5.随机梯度下降优化</h3><p>随机梯度下降优化是随机选择一个样本进行梯度计算，然后更新权重，并重复下一过程</p>
<h3 id="6-小批量梯度下降法"><a href="#6-小批量梯度下降法" class="headerlink" title="6.小批量梯度下降法"></a>6.小批量梯度下降法</h3><p>这个方法最常用，是GD与SGD的这种方法，取一个小批量的数据对参数进行更改。</p>
<h3 id="7-牛顿法"><a href="#7-牛顿法" class="headerlink" title="7.牛顿法"></a>7.牛顿法</h3><p>$$θ:=θ−f(θ)f′(θ)$$</p>
<h3 id="8-二分类评价指标"><a href="#8-二分类评价指标" class="headerlink" title="8.二分类评价指标"></a>8.二分类评价指标</h3><table>
<thead>
<tr>
<th></th>
<th>$y_{gt}=1$</th>
<th>$y_{gt}\not= 1$</th>
</tr>
</thead>
<tbody><tr>
<td>$\hat y=1$</td>
<td>True Positive (TP)</td>
<td>Flase Positive (FP)</td>
</tr>
<tr>
<td>$\hat y\not=1$</td>
<td>Flase Negative(FN)</td>
<td>True Negative (TN)</td>
</tr>
</tbody></table>
<p>$$<br>precision(精确率，查找率)= \frac{TP}{TP+FP} 【\hat y=1的所有项】 高代表找的更对<br>$$</p>
<p>$$<br>Recall(召回率)=\frac{TP}{TP+FN} 【y_{gt}=1的所有项】 高代表保证不漏<br>$$</p>
<p>这两个参数不可兼得，需要根据实际情况来。</p>
<h2 id="SoftMax分类"><a href="#SoftMax分类" class="headerlink" title="SoftMax分类"></a>SoftMax分类</h2><p>Softmax是一种多分类问题的解决方法，是logistics的一种多维形式的推广，多维分类通常采用独热码表示。</p>
<h3 id="1-模型表示-1"><a href="#1-模型表示-1" class="headerlink" title="1.模型表示"></a>1.模型表示</h3><p>$$<br>Softmax:h_{\vec \theta}(\vec x) = \frac {e^{-{\vec \theta}<em>c^T \vec x} } {\sum</em>{i=1}^Ne^{-{\vec \theta}^T \vec x} }<br>$$</p>
<h3 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h3><p>$$<br>loss: J(\vec \theta) = -\frac {1}{m} \sum_{i=1}^m \sum_{c=1}^Cy^{(i)}log(h_{\vec \theta}(\vec x^{(i)})<br>$$</p>
<p>$$<br>=-\frac {1}{m} \sum_{i=1}^m(y^{(i)})^Tlog(h_{\vec \theta}(\vec x^{(i)})<br>$$</p>
<p>实际上只算了$y_c^{(i)}$为1的那个loss</p>
<h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><p>$$<br>\vec \theta=\vec \theta-\alpha\frac {1}{m}\sum_{i=1}^N{x_j}^{(i)}(h_{\vec \theta}({\vec x}^{(i)})-y^{(i)})<br>$$</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="1-过拟合："><a href="#1-过拟合：" class="headerlink" title="1.过拟合："></a>1.过拟合：</h3><p>可能是因为模型过于复杂，模型可以很好的拟合训练数据，但不能拟合预测数据。可能会导致预测失败。</p>
<h3 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2.解决方法："></a>2.解决方法：</h3><p>1.减少特征数量 </p>
<p>2.正则化（通过降低$J_{\vec \theta}$的值来改变一些高次特征）</p>
<h3 id="3-正则项"><a href="#3-正则项" class="headerlink" title="3.正则项"></a>3.正则项</h3><p>通式：<br>$$<br>J(\theta)=\frac {1}{2m} [\sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^N\theta_j^2]<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/10/linear-regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/10/linear-regression/" class="post-title-link" itemprop="url">linear-regression</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-10 15:39:59" itemprop="dateCreated datePublished" datetime="2021-01-10T15:39:59+08:00">2021-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-08 16:32:52" itemprop="dateModified" datetime="2021-03-08T16:32:52+08:00">2021-03-08</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="机器学习之线性回归"><a href="#机器学习之线性回归" class="headerlink" title="机器学习之线性回归"></a>机器学习之线性回归</h2><h3 id="什么是线性回归"><a href="#什么是线性回归" class="headerlink" title="什么是线性回归"></a>什么是线性回归</h3><p>线性回归问题作为机器学习的经典，是一种有监督学习</p>
<p>所谓的线性回归问题就是希望用线性模型去拟合数据，利用回归方法从而得到回归方程，从而预测结果</p>
<p>线性回归的学习可以用如下公式表示<br>$$<br>\hat y = h_\theta(x)<br>$$<br>其中<code>x</code>是输入，<code>y</code>是输出/目标，$\theta$是要学习的参数。$h_\theta()$是指和$\theta$相关的模型，h()由模型给定。</p>
<p>当$\hat y$是连续的，且$h_\theta()$是线性的，那么这个模型就是线性回归模型。线性模型表示为<br>$$<br>h(x) = \theta_0+\theta_1x<br>$$<br>其中$\theta_0,\theta_1$可以表示为向量$\theta = (\theta_0,\theta_1)^T$</p>
<p>则有$h_{\vec \theta}(x)=\theta_0+\theta_1x$</p>
<h3 id="监督学习框架"><a href="#监督学习框架" class="headerlink" title="监督学习框架"></a>监督学习框架</h3><h4 id="训练："><a href="#训练：" class="headerlink" title="训练："></a>训练：</h4><p>$$<br>训练集(x,y) \rightarrow 学习算法 \rightarrow h:假设函数 \hat y = h_\theta(x)<br>$$</p>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>$$<br>x_{new} \rightarrow \hat y=h_\theta(x_{New})<br>$$</p>
<h4 id="启发式评估："><a href="#启发式评估：" class="headerlink" title="启发式评估："></a>启发式评估：</h4><p>Evaluation</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>由于训练的最终目标是让$h_\theta$与y越接近越好，那么损失函数可以定义为：<br>$$<br>J(\theta)=\frac {1}{2m} \sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2<br>$$<br>平方误差最小准则：优化问题就是找到使$J(\theta)$最小的解</p>
<h3 id="求闭式解"><a href="#求闭式解" class="headerlink" title="求闭式解"></a>求闭式解</h3><p>$$<br>J(\theta)=\frac {1}{2m} \sum_{i=1}^N (h_\theta(x^{(i)})-y^{(i)})^2<br>$$</p>
<p>$$<br>=\frac {1}{2m} \sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})^2<br>$$</p>
<p>$$<br>\frac {\delta J}{\delta \theta_0}=\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})<br>$$</p>
<p>$$<br>\frac {\delta J}{\delta \theta_1}=\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})x^{(i)}<br>$$</p>
<p>令(8)与(9)为0，解得：<br>$$<br>\theta_0=\frac{1}{m}\sum_{i=1}^N (y^{(i)}-\theta_1(x^{(i)}))<br>$$</p>
<p>$$<br>\theta_1=\frac{\sum_{i=1}^N (y^{(i)}-\theta_0) x^{(i)}}{\sum_{i=1}^N {x^{(i)}}^2}<br>$$</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>沿着梯度反方向改变（函数值下降最快的地方）即<br>$$<br>\theta_j = \theta_j-\alpha \frac {\delta J(\theta_0,\theta_1)}{\theta_j}<br>$$<br>这种方式让每次都算出$\theta_j$再进行下一轮更新，但可能出现局部最优解</p>
<h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><p>$$<br>\frac {\delta J(\theta_0,\theta_1)}{\theta} =\frac{1}{m}\sum_{i=1}^N (\theta_0+\theta_1(x^{(i)})-y^{(i)})(x^{(i)})<br>$$</p>
<h3 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h3><p>假设函数为$h_\theta(x)=\theta_0+\theta_1x+……\theta_nx$</p>
<p>即$h_{\vec \theta}(x)=\vec \theta^T \vec x $</p>
<h3 id="多元梯度："><a href="#多元梯度：" class="headerlink" title="多元梯度："></a>多元梯度：</h3><p>$$<br>\frac {\delta J_{\vec \theta}}{\vec{\theta_j}} =\frac {1}{m} \sum_{i=1}^N (h_{\vec \theta}({\vec x}^{(i)})-y^{(i)}){x_j}^{(i)}<br>$$</p>
<h3 id="多元闭式解"><a href="#多元闭式解" class="headerlink" title="多元闭式解"></a>多元闭式解</h3><p>$$<br>{ J_{\vec \theta}} =\frac {1}{2m} \sum_{i=1}^N (h_{\vec \theta}({\vec x}^{(i)})-y^{(i)})^2 = \frac{1}{2}(\vec x \vec \theta -\vec y)^T(\vec x \vec \theta -\vec y)<br>$$</p>
<p>$$<br>\bigtriangledown_\theta J(\vec \theta) = \bigtriangledown_\theta\frac{1}{2}(\vec x \vec \theta -\vec y)^T(\vec x \vec \theta -\vec y)<br>$$</p>
<p>$$<br>{\vec x}^T\vec x\vec \theta-{\vec x}^T\vec y = 0 \Rightarrow \vec \theta =  { {\vec x}^T\vec x}^{-1}{\vec x}^T\vec y<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/06/scala/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/06/scala/" class="post-title-link" itemprop="url">scala</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-06 10:51:57" itemprop="dateCreated datePublished" datetime="2021-01-06T10:51:57+08:00">2021-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-07 22:11:13" itemprop="dateModified" datetime="2021-01-07T22:11:13+08:00">2021-01-07</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Scala编程方法简化版"><a href="#Scala编程方法简化版" class="headerlink" title="Scala编程方法简化版"></a>Scala编程方法简化版</h2><h3 id="1-变量常量"><a href="#1-变量常量" class="headerlink" title="1.变量常量"></a>1.变量常量</h3><p>字符数字标识符：字母或者下划线开头，<code>$</code>被认作字母</p>
<h6 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h6><p>先乘除后加减</p>
<p>先算数，后移位，最后位运算</p>
<p>指针最优，单目优于双目</p>
<p>var 声明变量，val声明常量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hellostr=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">//hellostr:string = Hello World</span></span><br><span class="line"><span class="comment">//定义后不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hellostr1=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">//hellostr1:string = Hello World</span></span><br></pre></td></tr></table></figure>

<p>在声明变量和常量不一定需要指定数据类型，没有指明时通过初始值推断。<strong>变量常量必须付初始值，否则会报错</strong></p>
<p>可以用val声明一个元组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mr=(<span class="string">&quot;key&quot;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="comment">//mr:(string,int)=(key,22)</span></span><br></pre></td></tr></table></figure>

<p>Scala与Java有相同的变量类型，但是首字母必须大写，因为是对象，例如Int,String,Boolean</p>
<p>可以直接用<code>0x</code>表示16进制，<code>0</code>表示8进制，表示<code>Long</code>用<code>L</code>或者<code>l</code>作为后缀，表示<code>float</code>用<code>F/f</code>否则默认为double</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="number">41</span></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">0x29</span></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">051</span></span><br><span class="line"><span class="comment">//x:Int=41</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">0777</span>l</span><br><span class="line"><span class="comment">//x:Long=511</span></span><br><span class="line"><span class="keyword">val</span> f = <span class="number">3.14</span>f</span><br><span class="line"><span class="comment">//f:Float=3.14</span></span><br><span class="line"><span class="keyword">val</span> f=<span class="number">3.14</span><span class="comment">//0.314e1</span></span><br><span class="line"><span class="comment">//f:Double=3.14</span></span><br></pre></td></tr></table></figure>

<p>单字符用‘ ’引用，特殊字符要添加转义字符\，双引号同理</p>
<p>Scala还提供一种原样字符内容输出方法，用<code>“&quot;&quot;</code>的方式来表述</p>
<p><img src="/2021/01/06/scala/image-20210107142102498.png" alt="image-20210107142102498"></p>
<h3 id="2-流程控制与函数"><a href="#2-流程控制与函数" class="headerlink" title="2.流程控制与函数"></a>2.流程控制与函数</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句与C++相似，有if,if…else…,if…elseif…else</p>
<p>但if可以作为表达式使用：且可以直接赋值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="keyword">if</span>(<span class="string">&quot;hello&quot;</span>==<span class="string">&quot;hell&quot;</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="comment">//x:Int=0</span></span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><p>Scala中while与C++同，唯一不一样的是有返回值且恒为Unit(相当于void，<code>Unit=()</code>)</p>
<h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>for循环Scala有自己的风格，基础格式为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-表达式)&#123;</span><br><span class="line">	<span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.其中<code>&lt;-</code>称为生成器（generator），而for循环实际上是通过集合遍历来实现循环的</p>
<p> 2.表达式调用<code>RichInt</code>中的<code>to，until</code>方法来实现遍历，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>) println(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line"><span class="comment">//i=1</span></span><br><span class="line"><span class="comment">//i=2</span></span><br><span class="line"><span class="comment">//i=3</span></span><br><span class="line"><span class="comment">//i=4</span></span><br><span class="line"><span class="comment">//i=5</span></span><br></pre></td></tr></table></figure>

<p>3.如果希望集合右开，[1,5)则用<code>1 until 5</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> until (<span class="number">10</span>,<span class="number">2</span>)) print(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line"><span class="comment">//这里的2是步长</span></span><br></pre></td></tr></table></figure>

<p>4.引入break：Scala没有break,continue，但实现类似操作有两种方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入scala.util.control.Breaks类</span></span><br><span class="line"><span class="comment">//有条件过滤的for循环格式为</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">40</span> <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>);<span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>))&#123;<span class="comment">//这里中间是&amp;&amp;关系</span></span><br><span class="line">	println(<span class="string">&quot;i=&quot;</span>+i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=20</span></span><br><span class="line"><span class="comment">//i=40</span></span><br></pre></td></tr></table></figure>

<p>5.多重for循环：Scala支持for循环嵌套</p>
<p>6.for表达式：与yield配合使用执行完后有返回值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x =<span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>) <span class="keyword">yield</span> i/<span class="number">2</span></span><br><span class="line"><span class="comment">//x:scala.collection.immutable.IndexedSeq[Int]=vector(0,1,1,2,2)</span></span><br></pre></td></tr></table></figure>

<h5 id="函数声明，定义和调用"><a href="#函数声明，定义和调用" class="headerlink" title="函数声明，定义和调用"></a>函数声明，定义和调用</h5><h6 id="包："><a href="#包：" class="headerlink" title="包："></a>包：</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义包</span></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">package</span> com.baidu</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">package</span> com.dubai1&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用包</span></span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="type">Color</span></span><br><span class="line"><span class="keyword">import</span> java.awt_<span class="comment">//引入包内所有成员</span></span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(&#123;参数列表&#125;):[<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>]</span></span><br><span class="line"><span class="class"><span class="comment">//定义</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">fun</span>(<span class="params">&#123;参数列表&#125;</span>)</span>:[<span class="keyword">return</span> <span class="class"><span class="keyword">type</span>]</span>=&#123;</span><br><span class="line">    function body</span><br><span class="line">    <span class="keyword">return</span> [expr]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的格式</span></span><br><span class="line">fun(参数列表)</span><br><span class="line"><span class="comment">//如果函数使用了实例的对象来调用，可以使用类似java的格式 (使用 . 号)：</span></span><br><span class="line">[instance.]fun(参数列表)</span><br></pre></td></tr></table></figure>

<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>Scala用New来创建对象</p>
<p>类的第一个字母大写，方法的第一个字母小写</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">   <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">      x = x + dx</span><br><span class="line">      y = y + dy</span><br><span class="line">      println (<span class="string">&quot;Point x location : &quot;</span> + x);</span><br><span class="line">      println (<span class="string">&quot;Point y location : &quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> pt = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Move to a new location</span></span><br><span class="line">      pt.move(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Point x location:20</span></span><br><span class="line"><span class="comment">//Point y location:30</span></span><br></pre></td></tr></table></figure>

<p>类继承：extend  隐形类：impact  </p>
<h3 id="集合：数组、列表与映射"><a href="#集合：数组、列表与映射" class="headerlink" title="集合：数组、列表与映射"></a>集合：数组、列表与映射</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> z = <span class="type">Array</span>(<span class="string">&quot;Hello&quot;</span>，<span class="string">&quot;Cruel&quot;</span>，<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">z(<span class="number">0</span>)=<span class="string">&quot;Hello&quot;</span>;z(<span class="number">1</span>)=<span class="string">&quot;Cruel&quot;</span>;z(<span class="number">4</span>/<span class="number">2</span>)=<span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="comment">//多维数组</span></span><br><span class="line"><span class="keyword">var</span> myMatrix = ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//简单数组操作：</span></span><br><span class="line"><span class="comment">//合并：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span></span>[<span class="type">T</span>]( xss: <span class="type">Array</span>[<span class="type">T</span>]* ): <span class="type">Array</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//复制：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>( src: <span class="type">AnyRef</span>, srcPos: <span class="type">Int</span>, dest: <span class="type">AnyRef</span>, destPos: <span class="type">Int</span>, length: <span class="type">Int</span> ): <span class="type">Unit</span></span><br><span class="line"><span class="comment">//mkString方法：</span></span><br><span class="line">mkString（“&lt;”,”,”,”&gt;”）</span><br><span class="line"><span class="comment">//得用&lt;&gt;所扩，”，”分隔的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串列表</span></span><br><span class="line"><span class="keyword">val</span> site: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Baidu&quot;</span>)</span><br><span class="line"><span class="comment">// 整型列表</span></span><br><span class="line"><span class="keyword">val</span> nums: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 二维列表</span></span><br><span class="line"><span class="keyword">val</span> dim: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] =</span><br><span class="line">	<span class="type">List</span>(</span><br><span class="line">		<span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="type">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	)</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(i&lt;-<span class="type">List</span>)</span><br><span class="line"><span class="comment">//创建列表</span></span><br><span class="line"><span class="keyword">val</span> nums =<span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span></span><br><span class="line"><span class="comment">//nums:List[Int]=List(1,2,3,4)</span></span><br><span class="line"><span class="comment">//获取第一个第二个，最后一个元素</span></span><br><span class="line"><span class="type">List</span>.head <span class="type">List</span>.tail <span class="type">List</span>.last</span><br><span class="line"><span class="comment">//连接操作</span></span><br><span class="line"><span class="type">List1</span>:::<span class="type">List2</span></span><br><span class="line"><span class="comment">//获取和丢弃</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/06/scala/image-20210107152128223.png" alt="image-20210107152128223"></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>•Scala中的映射是键/值对的集合。任何值可以根据它的键进行检索。键是在映射唯一的，但值不一定是唯一的。</p>
<p>•映射也被称为哈希表。有两种类型的映射，不可变以及可变的。可变和不可变的对象之间的区别在于，当一个对象是不可变的，对象本身不能被改变。</p>
<p>•默认情况下，Scala中使用不可变的映射。如果想使用可变集，必须明确地导入scala.collection.mutable.Map类。但是可以通过生成新的映射来对原来的值进行改变。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> colors = <span class="type">Map</span>(<span class="string">&quot;red&quot;</span> -&gt; <span class="string">&quot;#FF0000&quot;</span>, <span class="string">&quot;azure&quot;</span> -&gt; <span class="string">&quot;#F0FFFF&quot;</span>)</span><br><span class="line"><span class="comment">//colors:scala.collection.immutable.Map[String,String]=Map(red-&gt;#FF0000,azure-&gt;#F0FFFF)</span></span><br></pre></td></tr></table></figure>

<p>基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keys</td>
<td>返回 Map 所有的键(key)</td>
</tr>
<tr>
<td>values</td>
<td>返回 Map 所有的值(value)</td>
</tr>
<tr>
<td>isEmpty</td>
<td>在 Map 为空时返回true</td>
</tr>
</tbody></table>
<p>使用++运算符或Map.++()来连接两个map ,Map合并时会移除重复的Key</p>
<p><img src="/2021/01/06/scala/image-20210107152502957.png" alt="image-20210107152502957"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/06/spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/06/spark/" class="post-title-link" itemprop="url">spark</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-06 10:51:09" itemprop="dateCreated datePublished" datetime="2021-01-06T10:51:09+08:00">2021-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-08 12:15:47" itemprop="dateModified" datetime="2021-01-08T12:15:47+08:00">2021-01-08</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SPARK"><a href="#SPARK" class="headerlink" title="SPARK"></a>SPARK</h2><h3 id="1-为什么要用Spark"><a href="#1-为什么要用Spark" class="headerlink" title="1.为什么要用Spark"></a>1.为什么要用Spark</h3><ol>
<li><p>speed ：比Hadoop快100倍，比disk快十倍</p>
</li>
<li><p>Ease of use：比java,Scala,Python,R写程序块</p>
</li>
<li><p>Generality</p>
</li>
<li><p>Runs Everywhere:可跑在Hadoop，standalone等，可以接受包括HDFS，Cassandra,HBase等数据来源</p>
</li>
</ol>
<h3 id="2-与Hadoop差异"><a href="#2-与Hadoop差异" class="headerlink" title="2.与Hadoop差异"></a>2.与Hadoop差异</h3><ol>
<li>Spark把中间数据放在内存中，迭代运算效率高，MapReduce中计算结果需要存在磁盘上，影响整体速度。Spark支持DAG图分布式并行计算的编程框架，减少迭代过程数据落地</li>
<li>Spark容错性高：引进弹性分布式数据集RDD的抽象。它是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“血统”（即充许基于数据衍生过程）对它们进行重建。</li>
<li>Spark更加通用。不像Hadoop只提供了Map和Redu ce两种操作，Spark提供的数据集操作类型有很多种，大致分为：Transformations和Actions两大类。Transformations包括Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort和PartionBy等多种操作类型，同时还提供Count, Actions包括Collect、Reduce、Lookup和Save等操作。另外各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名、物化，控制中间结果的存储、分区等。</li>
</ol>
<h3 id="3-Spark体系结构与运行模式"><a href="#3-Spark体系结构与运行模式" class="headerlink" title="3.Spark体系结构与运行模式"></a>3.Spark体系结构与运行模式</h3><p><img src="/2021/01/06/spark/image-20210106130224820.png" alt="image-20210106130224820"></p>
<p><img src="/2021/01/06/spark/image-20210106130320155.png" alt="image-20210106130320155"></p>
<h3 id="4-RDD"><a href="#4-RDD" class="headerlink" title="4.RDD"></a>4.RDD</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RDD是spark最基本的抽象，是对分布式内存的抽象使用。实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD表示了已被分区，不可变的能够并行操作的数据集合，不同数据格式对应不同的RDD实现。RDD必须可序列化，可以cache到内存中，每次RDD的结果都放在内存中，下次可以直接从内存中输入，省去MapReduce的大量磁盘IO操作。对于迭代常见的机器学习和交互式数据挖掘效率提升很大。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>来源：从持久存储获取或者从其他RDD生成</li>
<li>只读：状态不可变，不能修改</li>
<li>分区：支持元素根据key分区，保存到多个节点上</li>
<li>路径：RDD中叫世族或者血统，即RDD有充足的信息关于如何从其他RDD产生</li>
<li>持久化：控制存储级别来进行持久化</li>
<li>操作：丰富的动作：Count,Reduce,Collect,Save等</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="/2021/01/06/spark/image-20210106164259353.png" alt="image-20210106164259353"></p>
<h4 id="例子：控制台日志挖掘"><a href="#例子：控制台日志挖掘" class="headerlink" title="例子：控制台日志挖掘"></a>例子：控制台日志挖掘</h4><p>假设网站中的一个 WebService 出现错误，我们想要从数以 TB 的 HDFS 日志文件中找到问题的原因，此时我们就可以用 Spark 加载日志文件到一组结点组成集群的 RAM 中，并交互式地进行查询。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = spark.textFile(<span class="string">&quot;hdfs://...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这行从HDFS文件中创建出一个RDD</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors = line.fliter(_.startWith(<span class="string">&quot;Error&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>这行衍生出一个经过某种条件过滤的RDD（挑选出头为<code>Error</code>的值）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errors.persisit()</span><br></pre></td></tr></table></figure>

<p>这行将上一行出来的RDD errors缓存到内存中，但不会将第一个lines放到缓存中，因为文件可能比较大，缓存放不下，但是Error的集合比较小，缓存足以装进全部内存</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Count errors mentioning MySQL</span></span><br><span class="line">errors.filter(._contains(<span class="string">&quot;MySQL&quot;</span>)).count</span><br></pre></td></tr></table></figure>

<p>这行统计errors中包含MySQL 字样的总行数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return time fields of errors mentioning</span></span><br><span class="line"><span class="comment">//HDFS as an array (assuming time is field number 3 in a tab-separated format):</span></span><br><span class="line">errors.filter(._contains(<span class="string">&quot;HDFS&quot;</span>))</span><br><span class="line">	.map(._split(&#x27;\t&#x27;)(<span class="number">3</span>))</span><br><span class="line">	.collect()</span><br></pre></td></tr></table></figure>

<p>取出包含HDFS字样的行的第三列时间，并保存成一个集合</p>
<h4 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h4><p>RDD是Spark的核心抽象，所有计算都是围绕这RDD进行的</p>
<ul>
<li>转换：一个RDD经过计算后生成新的RDD，比如wordcount中的flatmap,map和ReduceByKey</li>
<li>动作：返回结果到Driver程序中，意味着RDD的计算结果，比如wordcount的collect操作</li>
</ul>
<p>转换是lazy模式，要等到有action操作时运行启动计算过程计算</p>
<p>action会返回结果或把RDD写到存储系统中，是触发Spark运算的动因</p>
<p><img src="/2021/01/06/spark/image-20210106195342838.png" alt="image-20210106195342838"></p>
<p><img src="/2021/01/06/spark/image-20210106195354883.png" alt="image-20210106195354883"></p>
<h4 id="传递函数参数"><a href="#传递函数参数" class="headerlink" title="传递函数参数"></a>传递函数参数</h4><p><img src="/2021/01/06/spark/image-20210106201542727.png" alt="image-20210106201542727"></p>
<p><img src="/2021/01/06/spark/image-20210106202040819.png" alt="image-20210106202040819"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">  <span class="comment">//设置数据路径</span></span><br><span class="line">  <span class="keyword">val</span> text = sc.textFile(<span class="string">&quot;./GoneWithTheWind&quot;</span>)</span><br><span class="line">  <span class="comment">//将文本数据按行处理，每行按空格拆成一个数组</span></span><br><span class="line">  <span class="comment">// flatMap会将各个数组中元素合成一个大的集合</span></span><br><span class="line">  <span class="keyword">val</span> textSplit = text.flatMap(line =&gt;line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">  <span class="comment">//处理合并后的集合中的元素，每个元素的值为1，返回一个元组（key,value）</span></span><br><span class="line">  <span class="comment">//其中key为单词，value这里是1，即该单词出现一次</span></span><br><span class="line">  <span class="keyword">val</span> textSplitFlag = textSplit.map(word =&gt; (word,<span class="number">1</span>))</span><br><span class="line">  <span class="comment">//reduceByKey会将textSplitFlag中的key相同的放在一起处理</span></span><br><span class="line">  <span class="comment">//传入的（x,y）中，x是上一次统计后的value，y是本次单词中的value，即每一次是x+1</span></span><br><span class="line">  <span class="keyword">val</span> countWord = textSplitFlag.reduceByKey((x,y)=&gt;x+y)</span><br><span class="line">  <span class="comment">//将计算后的结果存在项目目录下的result目录中</span></span><br><span class="line">  countWord.saveAsTextFile(<span class="string">&quot;./result&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="宽依赖和窄依赖"><a href="#宽依赖和窄依赖" class="headerlink" title="宽依赖和窄依赖"></a>宽依赖和窄依赖</h4><ul>
<li><p>窄依赖</p>
<ul>
<li>子RDD的每个分区依赖于常数个父分区（即与数据规模无关）</li>
<li>输入输出一对一的算子，且结果RDD的分区结构不变，主要是map,flatmap</li>
<li>输入输出一对一，但结果RDD的分区结构发生变化，如union,coalesce</li>
<li>从输入中选择部分元素的算子，如flater,distinct,subract,sample</li>
</ul>
</li>
<li><p>宽依赖</p>
<ul>
<li>子RDD的每个分区依赖于所有父分区</li>
<li>对单个RDD基于Key进行重组和reduce，如groupByKey,reduceByKey</li>
<li>对两个RDD基于Key进行join和重组，如join</li>
</ul>
</li>
</ul>
<h3 id="5-Shuffle"><a href="#5-Shuffle" class="headerlink" title="5.Shuffle"></a>5.Shuffle</h3><p><strong>当一个RDD的一个分区依赖前一个RDD的所有分区</strong>时，例如，对于单词Spark出现次数汇总时，该单词可能出现在所有分区中，需要将所有分区中Spark出现的键值汇总到某一数据节点进行汇总，这个过程叫做shuffle</p>
<h3 id="6-Spark内存管理"><a href="#6-Spark内存管理" class="headerlink" title="6.Spark内存管理"></a>6.Spark内存管理</h3><p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前<strong>记录</strong>这些内存，我们来看其具体流程：</p>
<p><strong>申请内存</strong>：</p>
<p>Spark 在代码中 new 一个对象实例</p>
<p>JVM 从堆内内存分配空间，创建对象并返回对象引用</p>
<p>Spark 保存该对象的引用，记录该对象占用的内存</p>
<p><strong>释放内存</strong>：</p>
<p>Spark 记录该对象释放的内存，删除该对象的引用</p>
<p>等待 JVM 的垃圾回收机制释放该对象占用的堆内内存</p>
<p><img src="/2021/01/06/spark/image-20210106212352334.png" alt="image-20210106212352334"></p>
<p>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。利用 JDK Unsafe API（从 Spark 2.0 开始，在管理堆外的存储内存时不再基于 Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现[3]），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放，而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p>
<p>在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。</p>
<p><img src="/2021/01/06/spark/image-20210106212503514.png" alt="image-20210106212503514"></p>
<h4 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h4><p><img src="/2021/01/06/spark/image-20210106212901176.png" alt="image-20210106212901176"></p>
<h4 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h4><h5 id="RDD的持久化机制："><a href="#RDD的持久化机制：" class="headerlink" title="RDD的持久化机制："></a>RDD的持久化机制：</h5><p>弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的 RDD 上执行转换（Transformation）操作产生一个新的 RDD。转换后的 RDD 与原始的 RDD 之间产生的依赖关系，构成了血统（Lineage）。凭借血统，Spark 保证了每一个 RDD 都可以被重新恢复。但 RDD 的所有转换都是惰性的，即只有当一个返回结果给 Driver 的行动（Action）发生时，Spark 才会创建任务读取 RDD，然后真正触发转换的执行。<br> Task 在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查 Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist 或 cache 方法，在内存或磁盘中持久化或缓存这个 RDD，从而在后面的行动时提升计算速度。事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 <strong>堆内和堆外存储内存的设计，便可以对缓存</strong> <strong>RDD</strong> <strong>时使用的内存做统一的规划和管 理</strong> （存储内存的其他应用场景，如缓存 broadcast 数据，暂时不在本文的讨论范围之内）。</p>
<p>RDD 的持久化由 Spark 的 Storage 模块 [7] 负责，实现了 RDD 与物理存储的解耦合。Storage 模块负责管理 Spark 在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时 Driver 端和 Executor 端的 Storage 模块构成了主从式的架构，即 Driver 端的 BlockManager 为 Master，Executor 端的 BlockManager 为 Slave。Storage 模块在逻辑上以 Block 为基本存储单位，RDD 的每个 Partition 经过处理后唯一对应一个 Block（BlockId 的格式为 rdd_RDD-ID_PARTITION-ID ）。Master 负责整个 Spark 应用程序的 Block 的元数据信息的管理和维护，而 Slave 需要将 Block 的更新等状态上报到 Master，同时接收 Master 的命令，例如新增或删除一个 RDD。</p>
<h4 id="RDD缓存过程"><a href="#RDD缓存过程" class="headerlink" title="RDD缓存过程"></a>RDD缓存过程</h4><p>在缓存到存储内存之前，partition中数据用Iterator访问。可以获取分区中每一条序列化或者非序列化的数据项，他们逻辑上占用JVM堆内的other部分空间，同一partition的不同Record空间并不连续</p>
<p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，所有Record 在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</p>
<p>因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的 Unroll 空间来临时占位，空间不足则 Unroll 失败，空间足够时可以继续进行。对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。而非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间</p>
<p><img src="/2021/01/06/spark/image-20210107104530406.png" alt="image-20210107104530406"></p>
<h4 id="淘汰和落盘"><a href="#淘汰和落盘" class="headerlink" title="淘汰和落盘"></a>淘汰和落盘</h4><p>存储内存的淘汰规则为：</p>
<p>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存</p>
<p>新旧 Block 不能属于同一个 RDD，避免循环淘汰</p>
<p>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题</p>
<p>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。其中 LRU 是 LinkedHashMap 的特性。</p>
<p>落盘的流程则比较简单，如果其存储级别符合_useDisk 为 true 的条件，再根据其_deserialized 判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在 Storage 模块中更新其信息。</p>
<ul>
<li>由于同一个 Executor 的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对 LinkedHashMap 中的旧 Block 进行淘汰（Eviction），而被淘汰的 Block 如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该 Block。</li>
</ul>
<h4 id="执行内存管理"><a href="#执行内存管理" class="headerlink" title="执行内存管理"></a>执行内存管理</h4><p>Executor 内运行的任务同样共享执行内存，Spark 用一个 HashMap 结构保存了任务到内存耗费的映射。每个任务可占用的执行内存大小的范围为 1/2N ~ 1/N，其中 N 为当前 Executor 内正在运行的任务的个数。每个任务在启动之时，要向 MemoryManager 请求申请最少为 1/2N 的执行内存，如果不能被满足要求则该任务被阻塞，直到有其他任务释放了足够的执行内存，该任务才可以被唤醒</p>
<h4 id="shuffle内存占用"><a href="#shuffle内存占用" class="headerlink" title="shuffle内存占用"></a>shuffle内存占用</h4><p>·在 ExternalSorter 和 Aggregator 中，Spark 会使用一种叫 AppendOnlyMap 的哈希表在堆内执行内存中存储数据，但在 Shuffle 过程中所有数据并不能都保存到该哈希表中，当这个哈希表占用的内存会进行周期性地采样估算，当其大到一定程度，无法再从 MemoryManager 申请到新的执行内存时，Spark 就会将其全部内容存储到磁盘文件中，这个过程被称为溢存(Spill)，溢存到磁盘的文件最后会被归并(Merge)。</p>
<p>Shuffle Write 阶段中用到的 Tungsten 是 Databricks 公司提出的对 Spark 优化内存和 CPU 使用的计划[9]，解决了一些 JVM 在性能上的限制和弊端。Spark 会根据 Shuffle 的情况来自动选择是否采用 Tungsten 排序。Tungsten 采用的页式内存管理机制建立在 MemoryManager 之上，即 Tungsten 对执行内存的使用进行了一步的抽象，这样在 Shuffle 过程中无需关心数据具体存储在堆内还是堆外。每个内存页用一个 MemoryBlock 来定义，并用 Object obj 和 long offset 这两个变量统一标识一个内存页在系统内存中的地址。堆内的 MemoryBlock 是以 long 型数组的形式分配的内存，其 obj 的值为是这个数组的对象引用，offset 是 long 型数组的在 JVM 中的初始偏移地址，两者配合使用可以定位这个数组在堆内的绝对地址；堆外的 MemoryBlock 是直接申请到的内存块，其 obj 为 null，offset 是这个内存块在系统内存中的 64 位绝对地址。Spark 用 MemoryBlock 巧妙地将堆内和堆外内存页统一抽象封装，并用页表(pageTable)管理每个 Task 申请到的内存页。</p>
<p>•执行内存主要用来存储任务在执行 Shuffle 时占用的内存，Shuffle 是按照一定规则对 RDD 数据重新分区的过程，我们来看 Shuffle 的 Write 和 Read 两阶段对执行内存的使用</p>
<p>•Shuffle Write：若在 map 端选择普通的排序方式，会采用 ExternalSorter 进行外排，在内存中存储数据时主要占用堆内执行空间。若在 map 端选择 Tungsten 的排序方式，则采用 ShuffleExternalSorter 直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。</p>
<p>•Shuffle Read：在对 reduce 端的数据进行聚合时，要将数据交给 Aggregator 处理，在内存中存储数据时占用堆内执行空间。如果需要进行最终结果排序，则要将再次将数据交给 ExternalSorter 处理，占用堆内执行空间。</p>
<h4 id="BlackManager在spark中扮演的角色"><a href="#BlackManager在spark中扮演的角色" class="headerlink" title="BlackManager在spark中扮演的角色"></a>BlackManager在spark中扮演的角色</h4><p>shuffle过程用到了BlackManager作为数据中转站</p>
<p>spark board cast调度task到多个executor的时候，broadcast底层使用的时数据存储层</p>
<p>如果我们对一个rdd进行cache，cacheManager也是把数据放在blockmanager中，截断了对计算链依赖，后续task运行的时候可以直接从cachemanager中获取到cacherdd，不用从头计算</p>
<h4 id="block和partition的关系"><a href="#block和partition的关系" class="headerlink" title="block和partition的关系"></a>block和partition的关系</h4><ul>
<li><p>RDD的运算基于partition每个task代表一个分区上的一个stage内的运算闭包，task被分别调度到多个executor上去运行，</p>
</li>
<li><p>如果 Block 在 BlockManager 中存在， 就会从 BlockManager 中获取，如果不存在， 就进行计算这个Block, 然后在 BlockManager 中进行存储持久化， 方便下次使用。</p>
</li>
<li><p>首先根据RDD id和partition index构造出block id (rdd_xx_xx)，接着从BlockManager中取出相应的block。</p>
<ul>
<li>如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。</li>
<li>如果该block不存在则需要调用RDD的computeOrReadCheckpoint()函数计算出新的block，并将其存储到BlockManager中。</li>
</ul>
</li>
<li><p>需要注意的是block的计算和存储是阻塞的，若另一线程也需要用到此block则需等到该线程block的loading结束。</p>
</li>
<li><p>获取的时候是先从本地的 BlockManager 中获取， 如果本地没有， 然后再 从 remote 获取， 先从 driver 上获取到元数据 Block的位置， 然后去到真正的节点上fetch。</p>
</li>
<li><p>如果没有，就进行计算，然后根据存储级别，存储到计算节点本地的BlockManager 的内存或磁盘中，这样RDD的transformation、action就和block数据建立了联系，虽然抽象上我们的操作是在partition层面上进行的，但是partition最终还是被映射成为block，因此实际上我们的所有操作都是对block的处理和存取。</p>
</li>
</ul>
<h4 id="SparkCache过程总结"><a href="#SparkCache过程总结" class="headerlink" title="SparkCache过程总结"></a>SparkCache过程总结</h4><p>存在则取出即可，不存在则计算下次使用同一个rdd时从分布式直接取出</p>
<p>rdd 计算的时候， 首先根据RDD id和partition index构造出block id (rdd_xx_xx)， 接着从BlockManager中取出相应的block， 如果该block存在，表示此RDD在之前已经被计算过和存储在BlockManager中，因此取出即可，无需再重新计算。 如果 block 不存在我们可以 计算出来， 然后吧 block 通过 doPutIterator 函数存储在 节点上的 BlockManager上面， 汇报block信息到 driver, 下次如果使用同一个 rdd, 就可以直接从分布式存储中 直接取出相应的 block。</p>
<p><img src="/2021/01/06/spark/image-20210107134919314.png" alt="image-20210107134919314"></p>
<p><img src="/2021/01/06/spark/image-20210107134926188.png" alt="image-20210107134926188"></p>
<p><img src="/2021/01/06/spark/image-20210107134932364.png" alt="image-20210107134932364"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yokeso.top/2021/01/04/MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="BigtreeLiu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yokeso">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/04/MapReduce/" class="post-title-link" itemprop="url">MapReduce</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-04 16:36:14" itemprop="dateCreated datePublished" datetime="2021-01-04T16:36:14+08:00">2021-01-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-07 21:44:37" itemprop="dateModified" datetime="2021-01-07T21:44:37+08:00">2021-01-07</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MapReduce原理及介绍"><a href="#MapReduce原理及介绍" class="headerlink" title="MapReduce原理及介绍"></a>MapReduce原理及介绍</h2><p>MapReduce是一个软件框架，可以支持大规模数据集上的并行和分布式运算。抽象了分布式计算系统上运行一个并行程序的数据流，以函数形式提供给用户两个接口：Map（映射）和Reduce（化简）用户可以重载这两个函数以实现交互和操纵其中的程序数据流</p>
<h4 id="MapReduce形式化定义"><a href="#MapReduce形式化定义" class="headerlink" title="MapReduce形式化定义"></a>MapReduce形式化定义</h4><p>MapReduce软件框架向用户提供了一个具有数据流和控制流的抽象层，并隐藏了数据流的实现步骤。但抽象层提供了Map和Reduce两个函数，用户可以通过重载这两个主函数达到特定目标</p>
<p>用户首先重载Map和Reduce函数，然后调用<code>MapReduce（Spec，&amp;Results）</code>来开始数据流，其中<code>Spec</code>先在用户程序中初始化，然后用户编写代码来填入输入和输出文件名以及其他可选调节参数。这个对象还填入了Map和Reduce函数的名字，以识别这些用户定义的函数和MapReduce库里提供的函数</p>
<p><img src="/2021/01/04/MapReduce/image-20210105164548758.png" alt="image-20210105164548758"></p>
<h4 id="MapReduce逻辑数据流"><a href="#MapReduce逻辑数据流" class="headerlink" title="MapReduce逻辑数据流"></a>MapReduce逻辑数据流</h4><p>Map的输入数据是以<code>（key,value）</code>对形式出现，输出数据的结构类似于<code>（key,value）</code>对，称为中间<code>（key,value）</code>对，换句话说，用户自定义Map函数处理每个<code>（key,value）</code>对，并产生很多<code>（zero,one,ormore）</code>中间<code>（key,value）</code>对。目的是为了Map函数并行处理所有的<code>（key,value）</code>对</p>
<p><img src="/2021/01/04/MapReduce/image-20210105170548205.png" alt="image-20210105170548205"></p>
<p>反过来，Reduce函数以中间值群组的形式接受中间<code>（key,value）</code>对，这些中间值群组和一个中间key<code>（key,[set of values]）</code>相关。实际上，MapReduce框架形成了这些群组，先对中间<code>（key,value）</code>对排序，然后用key来对value分组</p>
<p><strong>注意，排序是为了简化分组</strong></p>
<p>reduce 函数处理每个<code>（key,[set of values]）</code>群组，并产生<code>（key,value）</code>对集合作为输出。</p>
<h4 id="单词计数顺序"><a href="#单词计数顺序" class="headerlink" title="单词计数顺序"></a>单词计数顺序</h4><p><img src="/2021/01/04/MapReduce/image-20210105191718304.png" alt="image-20210105191718304"></p>
<p><strong>符号化</strong>：（key1,val1）-Map函数-&gt;List(key2,val2)</p>
<p>​                （key2,List(val2)）-Reduce函数-&gt;List（val2）</p>
<h4 id="MapReduce真实数据和控制流"><a href="#MapReduce真实数据和控制流" class="headerlink" title="MapReduce真实数据和控制流"></a>MapReduce真实数据和控制流</h4><p>1.数据分区：MapReduce库将已存入GFS的输入数据分割成m份，M也即映射任务的数量。</p>
<p>2.计算分区：计算模块强迫用户以Map和Reduce函数的形式编写程序，并在框架中隐式处理，所以MapReduce库只生成用户程序的多个复制（fork），包含MAp和Reduce函数，然后在多个可用的计算引擎上分配。</p>
<p>3.决定主服务器（master）和服务器（worker）：MapReduce基于主服务器-服务器模式，一个用户程序的复制变为主服务器，其余是服务器。主服务器挑选空闲服务器，分配MapReduce任务给他们。</p>
<p>4.读取输入数据（数据分发）：每一个映射服务器读取其输入数据的相应部分，即输入数据分割，然后输入至其Map函数。虽然一个映射服务器可能运行多个Map函数，这意味着它分到了不止一个输入数据分割；通常每个服务器只分到一个输入分割。</p>
<p>5.Map函数：用<code>（key,value）</code>对集合的形式收到输入数据分割，来处理并产生中间<code>（key,value）</code>对。</p>
<p>6.Combiner函数：映射服务器中一个可选的本地函数。适用于中间的<code>（key,value）</code>对。用户可以在用户程序里调用。Combiner运行与Reduce一样的功能。合并每个映射服务器的本地数据然后送到网络传输。</p>
<p>7.Partitioning函数：分块是由Partitioning（分区）函数完成，并能保证有相同键值的所有<code>（key,value）</code>对都能存储在同一区域内。因此，由于化简服务器i读取所有映射服务器区域i中的数据，有相同key的所有<code>（key,value）</code>对将由相应的化简服务器i收集。 </p>
<p><img src="/2021/01/04/MapReduce/image-20210105201025104.png" alt="image-20210105201025104"></p>
<p>8.同步：当所有映射任务完成，他们之间的通信开始</p>
<p>9.通信：Reduce服务器i已经知道所有映射服务器的区域i的位置，使用远程过程调用来从所有映射服务器的各个区域中读取数据。由于所有化简服务器从所有映射服务器中读取数据，映射和化简服务器之间的多对多通信在网络中进行，会引发网络拥塞。这个问题是提高此类系统性能的一个主要瓶颈。</p>
<p>10.排序和分组：当化简服务器完成读取输入数据的过程时，数据首先在化简服务器的本地磁盘中缓冲。然后化简服务器根据key将数据排序来对中间(key, value)对进行分组，之后对出现的所有相同key进行分组。注意，缓冲数据已经排序并分组，因为一个映射服务器产生的唯一key的数量可能会多于R个区域，所以在每个映射服务器区域中可能有不止一个key。</p>
<p>11.Reduce函数：简化服务器在已分组的<code>（key,value）</code>对上的迭代。对于每一个唯一的key，把key对应的value发送给Reduce函数，然后把这个函数出来输入数据，最后的结果存入用户程序指定的文件中。</p>
<p><img src="/2021/01/04/MapReduce/image-20210105205303260.png" alt="image-20210105205303260"></p>
<h4 id="来自Apache的Hadoop软件库"><a href="#来自Apache的Hadoop软件库" class="headerlink" title="来自Apache的Hadoop软件库"></a>来自Apache的Hadoop软件库</h4><p>Hadoop是Apache用Java实现的MapReduce开源实现，使用HDFS作为底层，MapReduce引擎是运行在HDFS上的计算引擎，HDFS是他的数据存储管理器。</p>
<p>HDFS：源于GFS的分布式文件系统，分布式计算系统上管理文件和存储数据</p>
<p><img src="/2021/01/04/MapReduce/image-20210106100205802.png" alt="image-20210106100205802"></p>
<p>HDFS体系结构：主从体系结构，包括单个NameNode(master)和多个DataNode(slave)。HDFS将文件分为固定大小的块，并存放在工作机中，块的映射由Namenode决定。master也管理文件系统的元数据和命名空间，在系统中，命名空间是维护元数据的区域，元数据是指一个文件系统存储的所有信息。是所有文件的全面管理所需要的。</p>
<p><img src="/2021/01/04/MapReduce/image-20210106103330168.png" alt="image-20210106103330168"></p>
<p>HDFS特性：HDFS不支持安全性，主要讨论两个特性</p>
<ul>
<li><p>容错能力：Hadoop设计时默认部署在廉价的硬件上，系统故障很常见。</p>
<ul>
<li>块复制：HDFS把文件存储为一个块集，每个块都有备份并且在整个集群上分发。</li>
<li>备份布置：提供更大的可靠性，但通信成本稍高</li>
<li>HeartBeat和LockReport消息：这两个消息都由DataNode传输给NameNode，收到Heartbeat意味着DataNode正常运行，而每个Blockreport包括DataNode上所有块的清单</li>
</ul>
</li>
<li><p>高吞吐量访问大规模数据集：因为是为批处理设计而非交互式处理，所以吞吐量比延时更重要。</p>
</li>
</ul>
<p>HDFS操作：控制流能正确突出在管理操作中NameNode和DataNode的角色</p>
<ul>
<li>读取文件：用户发送Open请求给NameNode来获取文件块位置信息</li>
<li>写入文件：用户发送create请求给NameNode来在命名空间里创建文件</li>
</ul>
<h4 id="Hadoop里运行作业"><a href="#Hadoop里运行作业" class="headerlink" title="Hadoop里运行作业"></a>Hadoop里运行作业</h4><p><img src="/2021/01/04/MapReduce/image-20210105214423025.png" alt="image-20210105214423025"></p>
<ul>
<li><p>作业提交：每个作业由用户提交到master</p>
<ul>
<li>用户从master请求新ID，并计算输入文件分块</li>
<li>用户复制资源l比如用户的JAR文件、配置文件和计算输入分块，至JobTracker文件系统。</li>
<li>用户节点通过调用submitJob()函数提交任务至JobTracker。</li>
</ul>
</li>
<li><p>任务分配：JobTracker为用户节点的每个计算输入块建立一个映射任务，并分配给TaskTracker的执行槽。当分配映射任务给TaskTracker时，JobTracker会考虑数据的定位。JobTracker也会创建化简任务，并分配给TaskTracker。 </p>
</li>
<li><p>任务执行：把作业JAR文件复制到其文件系统之后，在TaskTracker执行一个任务（不管映射还是化简）的控制流就开始了。在启动Java虚拟机（Java Virtual Machine，JVM）来运行它的映射或化简任务后，就开始执行作业JAR文件里的指令。</p>
</li>
<li><p>任务运行校验：通过接收从TaskTracker到JobTracker的周期性心跳监听消息来完成任务运行校验。每个心跳监听会告知JobTracker传送中的TaskTracker是可用的，以及传送中的TaskTracker是否准备好运行一个新的任务。 </p>
</li>
</ul>
<p><img src="/2021/01/04/MapReduce/image-20210106104041624.png" alt="image-20210106104041624"></p>
<p><img src="/2021/01/04/MapReduce/image-20210106104054859.png" alt="image-20210106104054859"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yokeso</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">84k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
